// This file was autogenerated by some hot garbage in the `uniffi` crate.
// Trust me, you don't want to mess with it!
import Foundation

// Depending on the consumer's build setup, the low-level FFI code
// might be in a separate module, or it might be compiled inline into
// this module. This is a bit of light hackery to work with both.
#if canImport(ProseCoreFFIFFI)
    import ProseCoreFFIFFI
#endif

private extension RustBuffer {
    // Allocate a new buffer, copying the contents of a `UInt8` array.
    init(bytes: [UInt8]) {
        let rbuf = bytes.withUnsafeBufferPointer { ptr in
            RustBuffer.from(ptr)
        }
        self.init(capacity: rbuf.capacity, len: rbuf.len, data: rbuf.data)
    }

    static func from(_ ptr: UnsafeBufferPointer<UInt8>) -> RustBuffer {
        try! rustCall { ffi_prose_core_ffi_3ba6_rustbuffer_from_bytes(ForeignBytes(bufferPointer: ptr), $0) }
    }

    // Frees the buffer in place.
    // The buffer must not be used after this is called.
    func deallocate() {
        try! rustCall { ffi_prose_core_ffi_3ba6_rustbuffer_free(self, $0) }
    }
}

private extension ForeignBytes {
    init(bufferPointer: UnsafeBufferPointer<UInt8>) {
        self.init(len: Int32(bufferPointer.count), data: bufferPointer.baseAddress)
    }
}

// For every type used in the interface, we provide helper methods for conveniently
// lifting and lowering that type from C-compatible data, and for reading and writing
// values of that type in a buffer.

// Helper classes/extensions that don't change.
// Someday, this will be in a library of its own.

private extension Data {
    init(rustBuffer: RustBuffer) {
        // TODO: This copies the buffer. Can we read directly from a
        // Rust buffer?
        self.init(bytes: rustBuffer.data!, count: Int(rustBuffer.len))
    }
}

// Define reader functionality.  Normally this would be defined in a class or
// struct, but we use standalone functions instead in order to make external
// types work.
//
// With external types, one swift source file needs to be able to call the read
// method on another source file's FfiConverter, but then what visibility
// should Reader have?
// - If Reader is fileprivate, then this means the read() must also
//   be fileprivate, which doesn't work with external types.
// - If Reader is internal/public, we'll get compile errors since both source
//   files will try define the same type.
//
// Instead, the read() method and these helper functions input a tuple of data

private func createReader(data: Data) -> (data: Data, offset: Data.Index) {
    (data: data, offset: 0)
}

// Reads an integer at the current offset, in big-endian order, and advances
// the offset on success. Throws if reading the integer would move the
// offset past the end of the buffer.
private func readInt<T: FixedWidthInteger>(_ reader: inout (data: Data, offset: Data.Index)) throws -> T {
    let range = reader.offset ..< reader.offset + MemoryLayout<T>.size
    guard reader.data.count >= range.upperBound else {
        throw UniffiInternalError.bufferOverflow
    }
    if T.self == UInt8.self {
        let value = reader.data[reader.offset]
        reader.offset += 1
        return value as! T
    }
    var value: T = 0
    let _ = withUnsafeMutableBytes(of: &value) { reader.data.copyBytes(to: $0, from: range) }
    reader.offset = range.upperBound
    return value.bigEndian
}

// Reads an arbitrary number of bytes, to be used to read
// raw bytes, this is useful when lifting strings
private func readBytes(_ reader: inout (data: Data, offset: Data.Index), count: Int) throws -> [UInt8] {
    let range = reader.offset ..< (reader.offset + count)
    guard reader.data.count >= range.upperBound else {
        throw UniffiInternalError.bufferOverflow
    }
    var value = [UInt8](repeating: 0, count: count)
    value.withUnsafeMutableBufferPointer { buffer in
        reader.data.copyBytes(to: buffer, from: range)
    }
    reader.offset = range.upperBound
    return value
}

// Reads a float at the current offset.
private func readFloat(_ reader: inout (data: Data, offset: Data.Index)) throws -> Float {
    return try Float(bitPattern: readInt(&reader))
}

// Reads a float at the current offset.
private func readDouble(_ reader: inout (data: Data, offset: Data.Index)) throws -> Double {
    return try Double(bitPattern: readInt(&reader))
}

// Indicates if the offset has reached the end of the buffer.
private func hasRemaining(_ reader: (data: Data, offset: Data.Index)) -> Bool {
    return reader.offset < reader.data.count
}

// Define writer functionality.  Normally this would be defined in a class or
// struct, but we use standalone functions instead in order to make external
// types work.  See the above discussion on Readers for details.

private func createWriter() -> [UInt8] {
    return []
}

private func writeBytes<S>(_ writer: inout [UInt8], _ byteArr: S) where S: Sequence, S.Element == UInt8 {
    writer.append(contentsOf: byteArr)
}

// Writes an integer in big-endian order.
//
// Warning: make sure what you are trying to write
// is in the correct type!
private func writeInt<T: FixedWidthInteger>(_ writer: inout [UInt8], _ value: T) {
    var value = value.bigEndian
    withUnsafeBytes(of: &value) { writer.append(contentsOf: $0) }
}

private func writeFloat(_ writer: inout [UInt8], _ value: Float) {
    writeInt(&writer, value.bitPattern)
}

private func writeDouble(_ writer: inout [UInt8], _ value: Double) {
    writeInt(&writer, value.bitPattern)
}

// Protocol for types that transfer other types across the FFI. This is
// analogous go the Rust trait of the same name.
private protocol FfiConverter {
    associatedtype FfiType
    associatedtype SwiftType

    static func lift(_ value: FfiType) throws -> SwiftType
    static func lower(_ value: SwiftType) -> FfiType
    static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType
    static func write(_ value: SwiftType, into buf: inout [UInt8])
}

// Types conforming to `Primitive` pass themselves directly over the FFI.
private protocol FfiConverterPrimitive: FfiConverter where FfiType == SwiftType {}

extension FfiConverterPrimitive {
    public static func lift(_ value: FfiType) throws -> SwiftType {
        return value
    }

    public static func lower(_ value: SwiftType) -> FfiType {
        return value
    }
}

// Types conforming to `FfiConverterRustBuffer` lift and lower into a `RustBuffer`.
// Used for complex types where it's hard to write a custom lift/lower.
private protocol FfiConverterRustBuffer: FfiConverter where FfiType == RustBuffer {}

extension FfiConverterRustBuffer {
    public static func lift(_ buf: RustBuffer) throws -> SwiftType {
        var reader = createReader(data: Data(rustBuffer: buf))
        let value = try read(from: &reader)
        if hasRemaining(reader) {
            throw UniffiInternalError.incompleteData
        }
        buf.deallocate()
        return value
    }

    public static func lower(_ value: SwiftType) -> RustBuffer {
        var writer = createWriter()
        write(value, into: &writer)
        return RustBuffer(bytes: writer)
    }
}

// An error type for FFI errors. These errors occur at the UniFFI level, not
// the library level.
private enum UniffiInternalError: LocalizedError {
    case bufferOverflow
    case incompleteData
    case unexpectedOptionalTag
    case unexpectedEnumCase
    case unexpectedNullPointer
    case unexpectedRustCallStatusCode
    case unexpectedRustCallError
    case unexpectedStaleHandle
    case rustPanic(_ message: String)

    public var errorDescription: String? {
        switch self {
        case .bufferOverflow: return "Reading the requested value would read past the end of the buffer"
        case .incompleteData: return "The buffer still has data after lifting its containing value"
        case .unexpectedOptionalTag: return "Unexpected optional tag; should be 0 or 1"
        case .unexpectedEnumCase: return "Raw enum value doesn't match any cases"
        case .unexpectedNullPointer: return "Raw pointer value was null"
        case .unexpectedRustCallStatusCode: return "Unexpected RustCallStatus code"
        case .unexpectedRustCallError: return "CALL_ERROR but no errorClass specified"
        case .unexpectedStaleHandle: return "The object in the handle map has been dropped already"
        case let .rustPanic(message): return message
        }
    }
}

private let CALL_SUCCESS: Int8 = 0
private let CALL_ERROR: Int8 = 1
private let CALL_PANIC: Int8 = 2

private extension RustCallStatus {
    init() {
        self.init(
            code: CALL_SUCCESS,
            errorBuf: RustBuffer(
                capacity: 0,
                len: 0,
                data: nil
            )
        )
    }
}

private func rustCall<T>(_ callback: (UnsafeMutablePointer<RustCallStatus>) -> T) throws -> T {
    try makeRustCall(callback, errorHandler: {
        $0.deallocate()
        return UniffiInternalError.unexpectedRustCallError
    })
}

private func rustCallWithError<T, F: FfiConverter>
(_ errorFfiConverter: F.Type, _ callback: (UnsafeMutablePointer<RustCallStatus>) -> T) throws -> T
    where F.SwiftType: Error, F.FfiType == RustBuffer
{
    try makeRustCall(callback, errorHandler: { try errorFfiConverter.lift($0) })
}

private func makeRustCall<T>(_ callback: (UnsafeMutablePointer<RustCallStatus>) -> T, errorHandler: (RustBuffer) throws -> Error) throws -> T {
    var callStatus = RustCallStatus()
    let returnedVal = callback(&callStatus)
    switch callStatus.code {
    case CALL_SUCCESS:
        return returnedVal

    case CALL_ERROR:
        throw try errorHandler(callStatus.errorBuf)

    case CALL_PANIC:
        // When the rust code sees a panic, it tries to construct a RustBuffer
        // with the message.  But if that code panics, then it just sends back
        // an empty buffer.
        if callStatus.errorBuf.len > 0 {
            throw try UniffiInternalError.rustPanic(FfiConverterString.lift(callStatus.errorBuf))
        } else {
            callStatus.errorBuf.deallocate()
            throw UniffiInternalError.rustPanic("Rust panic")
        }

    default:
        throw UniffiInternalError.unexpectedRustCallStatusCode
    }
}

// Public interface members begin here.

private struct FfiConverterInt64: FfiConverterPrimitive {
    typealias FfiType = Int64
    typealias SwiftType = Int64

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Int64 {
        return try lift(readInt(&buf))
    }

    public static func write(_ value: Int64, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}

private struct FfiConverterBool: FfiConverter {
    typealias FfiType = Int8
    typealias SwiftType = Bool

    public static func lift(_ value: Int8) throws -> Bool {
        return value != 0
    }

    public static func lower(_ value: Bool) -> Int8 {
        return value ? 1 : 0
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Bool {
        return try lift(readInt(&buf))
    }

    public static func write(_ value: Bool, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}

private struct FfiConverterString: FfiConverter {
    typealias SwiftType = String
    typealias FfiType = RustBuffer

    public static func lift(_ value: RustBuffer) throws -> String {
        defer {
            value.deallocate()
        }
        if value.data == nil {
            return String()
        }
        let bytes = UnsafeBufferPointer<UInt8>(start: value.data!, count: Int(value.len))
        return String(bytes: bytes, encoding: String.Encoding.utf8)!
    }

    public static func lower(_ value: String) -> RustBuffer {
        return value.utf8CString.withUnsafeBufferPointer { ptr in
            // The swift string gives us int8_t, we want uint8_t.
            ptr.withMemoryRebound(to: UInt8.self) { ptr in
                // The swift string gives us a trailing null byte, we don't want it.
                let buf = UnsafeBufferPointer(rebasing: ptr.prefix(upTo: ptr.count - 1))
                return RustBuffer.from(buf)
            }
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> String {
        let len: Int32 = try readInt(&buf)
        return try String(bytes: readBytes(&buf, count: Int(len)), encoding: String.Encoding.utf8)!
    }

    public static func write(_ value: String, into buf: inout [UInt8]) {
        let len = Int32(value.utf8.count)
        writeInt(&buf, len)
        writeBytes(&buf, value.utf8)
    }
}

public protocol AccountBookmarksClientProtocol {
    func loadBookmarks() throws -> [AccountBookmark]
    func addBookmark(jid: BareJid, selectBookmark: Bool) throws
    func removeBookmark(jid: BareJid) throws
    func selectBookmark(jid: BareJid) throws
}

public class AccountBookmarksClient: AccountBookmarksClientProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    public convenience init(bookmarksPath: PathBuf) {
        self.init(unsafeFromRawPointer: try! rustCall {
            prose_core_ffi_3ba6_AccountBookmarksClient_new(
                FfiConverterTypePathBuf.lower(bookmarksPath), $0
            )
        })
    }

    deinit {
        try! rustCall { ffi_prose_core_ffi_3ba6_AccountBookmarksClient_object_free(pointer, $0) }
    }

    public func loadBookmarks() throws -> [AccountBookmark] {
        return try FfiConverterSequenceTypeAccountBookmark.lift(
            rustCallWithError(FfiConverterTypeClientError.self) {
                prose_core_ffi_3ba6_AccountBookmarksClient_load_bookmarks(self.pointer, $0)
            }
        )
    }

    public func addBookmark(jid: BareJid, selectBookmark: Bool) throws {
        try
            rustCallWithError(FfiConverterTypeClientError.self) {
                prose_core_ffi_3ba6_AccountBookmarksClient_add_bookmark(self.pointer,
                                                                        FfiConverterTypeBareJid.lower(jid),
                                                                        FfiConverterBool.lower(selectBookmark), $0)
            }
    }

    public func removeBookmark(jid: BareJid) throws {
        try
            rustCallWithError(FfiConverterTypeClientError.self) {
                prose_core_ffi_3ba6_AccountBookmarksClient_remove_bookmark(self.pointer,
                                                                           FfiConverterTypeBareJid.lower(jid), $0)
            }
    }

    public func selectBookmark(jid: BareJid) throws {
        try
            rustCallWithError(FfiConverterTypeClientError.self) {
                prose_core_ffi_3ba6_AccountBookmarksClient_select_bookmark(self.pointer,
                                                                           FfiConverterTypeBareJid.lower(jid), $0)
            }
    }
}

public struct FfiConverterTypeAccountBookmarksClient: FfiConverter {
    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = AccountBookmarksClient

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> AccountBookmarksClient {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if ptr == nil {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: AccountBookmarksClient, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> AccountBookmarksClient {
        return AccountBookmarksClient(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: AccountBookmarksClient) -> UnsafeMutableRawPointer {
        return value.pointer
    }
}

public func FfiConverterTypeAccountBookmarksClient_lift(_ pointer: UnsafeMutableRawPointer) throws -> AccountBookmarksClient {
    return try FfiConverterTypeAccountBookmarksClient.lift(pointer)
}

public func FfiConverterTypeAccountBookmarksClient_lower(_ value: AccountBookmarksClient) -> UnsafeMutableRawPointer {
    return FfiConverterTypeAccountBookmarksClient.lower(value)
}

public protocol ClientProtocol {
    func connect(password: String) async throws
    func disconnect() async throws
    func jid() -> FullJid
    func loadAvatar(from: BareJid) async throws -> PathBuf?
    func loadComposingUsers(conversation: BareJid) async throws -> [BareJid]
    func loadContacts() async throws -> [Contact]
    func loadLatestMessages(from: BareJid, since: MessageId?, loadFromServer: Bool) async throws -> [Message]
    func loadMessagesBefore(from: BareJid, before: MessageId) async throws -> MessagesPage
    func loadMessagesWithIds(conversation: BareJid, ids: [MessageId]) async throws -> [Message]
    func loadProfile(from: BareJid) async throws -> UserProfile
    func retractMessage(conversation: BareJid, id: MessageId) async throws
    func saveAvatar(imagePath: PathBuf) async throws
    func saveProfile(profile: UserProfile) async throws
    func sendMessage(to: BareJid, body: String) async throws
    func setUserIsComposing(conversation: BareJid, isComposing: Bool) async throws
    func toggleReactionToMessage(conversation: BareJid, id: MessageId, emoji: Emoji) async throws
    func updateMessage(conversation: BareJid, id: MessageId, body: String) async throws
}

public class Client: ClientProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    public convenience init(jid: FullJid, cacheDir: String, delegate: ClientDelegate?) throws {
        try self.init(unsafeFromRawPointer: rustCallWithError(FfiConverterTypeClientError.self) {
            prose_core_ffi_3ba6_Client_new(
                FfiConverterTypeFullJid.lower(jid),
                FfiConverterString.lower(cacheDir),
                FfiConverterOptionCallbackInterfaceClientDelegate.lower(delegate), $0
            )
        })
    }

    deinit {
        try! rustCall { ffi_prose_core_ffi_3ba6_Client_object_free(pointer, $0) }
    }

    public func connect(password: String) async throws {
        let future = try
            rustCallWithError(FfiConverterTypeConnectionError.self) {
                _uniffi_prose_core_ffi_impl_Client_connect_5f8b(self.pointer,
                                                                FfiConverterString.lower(password), $0)
            }

        return try await withCheckedThrowingContinuation { continuation in
            let env = Unmanaged.passRetained(_UniFFI_Client_Connect_Env(rustyFuture: future, continuation: continuation))
            _UniFFI_Client_Connect_waker(raw_env: env.toOpaque())
        }
    }

    public func disconnect() async throws {
        let future = try
            rustCallWithError(FfiConverterTypeClientError.self) {
                _uniffi_prose_core_ffi_impl_Client_disconnect_10c0(self.pointer, $0)
            }

        return try await withCheckedThrowingContinuation { continuation in
            let env = Unmanaged.passRetained(_UniFFI_Client_Disconnect_Env(rustyFuture: future, continuation: continuation))
            _UniFFI_Client_Disconnect_waker(raw_env: env.toOpaque())
        }
    }

    public func jid() -> FullJid {
        return try! FfiConverterTypeFullJid.lift(
            try!
                rustCall {
                    _uniffi_prose_core_ffi_impl_Client_jid_5c1a(self.pointer, $0)
                }
        )
    }

    public func loadAvatar(from: BareJid) async throws -> PathBuf? {
        let future = try
            rustCallWithError(FfiConverterTypeClientError.self) {
                _uniffi_prose_core_ffi_impl_Client_load_avatar_e49a(self.pointer,
                                                                    FfiConverterTypeBareJid.lower(from), $0)
            }

        return try await withCheckedThrowingContinuation { continuation in
            let env = Unmanaged.passRetained(_UniFFI_Client_LoadAvatar_Env(rustyFuture: future, continuation: continuation))
            _UniFFI_Client_LoadAvatar_waker(raw_env: env.toOpaque())
        }
    }

    public func loadComposingUsers(conversation: BareJid) async throws -> [BareJid] {
        let future = try
            rustCallWithError(FfiConverterTypeClientError.self) {
                _uniffi_prose_core_ffi_impl_Client_load_composing_users_ae9e(self.pointer,
                                                                             FfiConverterTypeBareJid.lower(conversation), $0)
            }

        return try await withCheckedThrowingContinuation { continuation in
            let env = Unmanaged.passRetained(_UniFFI_Client_LoadComposingUsers_Env(rustyFuture: future, continuation: continuation))
            _UniFFI_Client_LoadComposingUsers_waker(raw_env: env.toOpaque())
        }
    }

    public func loadContacts() async throws -> [Contact] {
        let future = try
            rustCallWithError(FfiConverterTypeClientError.self) {
                _uniffi_prose_core_ffi_impl_Client_load_contacts_5bc5(self.pointer, $0)
            }

        return try await withCheckedThrowingContinuation { continuation in
            let env = Unmanaged.passRetained(_UniFFI_Client_LoadContacts_Env(rustyFuture: future, continuation: continuation))
            _UniFFI_Client_LoadContacts_waker(raw_env: env.toOpaque())
        }
    }

    public func loadLatestMessages(from: BareJid, since: MessageId?, loadFromServer: Bool) async throws -> [Message] {
        let future = try
            rustCallWithError(FfiConverterTypeClientError.self) {
                _uniffi_prose_core_ffi_impl_Client_load_latest_messages_7960(self.pointer,
                                                                             FfiConverterTypeBareJid.lower(from),
                                                                             FfiConverterOptionTypeMessageId.lower(since),
                                                                             FfiConverterBool.lower(loadFromServer), $0)
            }

        return try await withCheckedThrowingContinuation { continuation in
            let env = Unmanaged.passRetained(_UniFFI_Client_LoadLatestMessages_Env(rustyFuture: future, continuation: continuation))
            _UniFFI_Client_LoadLatestMessages_waker(raw_env: env.toOpaque())
        }
    }

    public func loadMessagesBefore(from: BareJid, before: MessageId) async throws -> MessagesPage {
        let future = try
            rustCallWithError(FfiConverterTypeClientError.self) {
                _uniffi_prose_core_ffi_impl_Client_load_messages_before_5eed(self.pointer,
                                                                             FfiConverterTypeBareJid.lower(from),
                                                                             FfiConverterTypeMessageId.lower(before), $0)
            }

        return try await withCheckedThrowingContinuation { continuation in
            let env = Unmanaged.passRetained(_UniFFI_Client_LoadMessagesBefore_Env(rustyFuture: future, continuation: continuation))
            _UniFFI_Client_LoadMessagesBefore_waker(raw_env: env.toOpaque())
        }
    }

    public func loadMessagesWithIds(conversation: BareJid, ids: [MessageId]) async throws -> [Message] {
        let future = try
            rustCallWithError(FfiConverterTypeClientError.self) {
                _uniffi_prose_core_ffi_impl_Client_load_messages_with_ids_fc47(self.pointer,
                                                                               FfiConverterTypeBareJid.lower(conversation),
                                                                               FfiConverterSequenceTypeMessageId.lower(ids), $0)
            }

        return try await withCheckedThrowingContinuation { continuation in
            let env = Unmanaged.passRetained(_UniFFI_Client_LoadMessagesWithIds_Env(rustyFuture: future, continuation: continuation))
            _UniFFI_Client_LoadMessagesWithIds_waker(raw_env: env.toOpaque())
        }
    }

    public func loadProfile(from: BareJid) async throws -> UserProfile {
        let future = try
            rustCallWithError(FfiConverterTypeClientError.self) {
                _uniffi_prose_core_ffi_impl_Client_load_profile_8146(self.pointer,
                                                                     FfiConverterTypeBareJid.lower(from), $0)
            }

        return try await withCheckedThrowingContinuation { continuation in
            let env = Unmanaged.passRetained(_UniFFI_Client_LoadProfile_Env(rustyFuture: future, continuation: continuation))
            _UniFFI_Client_LoadProfile_waker(raw_env: env.toOpaque())
        }
    }

    public func retractMessage(conversation: BareJid, id: MessageId) async throws {
        let future = try
            rustCallWithError(FfiConverterTypeClientError.self) {
                _uniffi_prose_core_ffi_impl_Client_retract_message_340e(self.pointer,
                                                                        FfiConverterTypeBareJid.lower(conversation),
                                                                        FfiConverterTypeMessageId.lower(id), $0)
            }

        return try await withCheckedThrowingContinuation { continuation in
            let env = Unmanaged.passRetained(_UniFFI_Client_RetractMessage_Env(rustyFuture: future, continuation: continuation))
            _UniFFI_Client_RetractMessage_waker(raw_env: env.toOpaque())
        }
    }

    public func saveAvatar(imagePath: PathBuf) async throws {
        let future = try
            rustCallWithError(FfiConverterTypeClientError.self) {
                _uniffi_prose_core_ffi_impl_Client_save_avatar_b078(self.pointer,
                                                                    FfiConverterTypePathBuf.lower(imagePath), $0)
            }

        return try await withCheckedThrowingContinuation { continuation in
            let env = Unmanaged.passRetained(_UniFFI_Client_SaveAvatar_Env(rustyFuture: future, continuation: continuation))
            _UniFFI_Client_SaveAvatar_waker(raw_env: env.toOpaque())
        }
    }

    public func saveProfile(profile: UserProfile) async throws {
        let future = try
            rustCallWithError(FfiConverterTypeClientError.self) {
                _uniffi_prose_core_ffi_impl_Client_save_profile_aee2(self.pointer,
                                                                     FfiConverterTypeUserProfile.lower(profile), $0)
            }

        return try await withCheckedThrowingContinuation { continuation in
            let env = Unmanaged.passRetained(_UniFFI_Client_SaveProfile_Env(rustyFuture: future, continuation: continuation))
            _UniFFI_Client_SaveProfile_waker(raw_env: env.toOpaque())
        }
    }

    public func sendMessage(to: BareJid, body: String) async throws {
        let future = try
            rustCallWithError(FfiConverterTypeClientError.self) {
                _uniffi_prose_core_ffi_impl_Client_send_message_d23e(self.pointer,
                                                                     FfiConverterTypeBareJid.lower(to),
                                                                     FfiConverterString.lower(body), $0)
            }

        return try await withCheckedThrowingContinuation { continuation in
            let env = Unmanaged.passRetained(_UniFFI_Client_SendMessage_Env(rustyFuture: future, continuation: continuation))
            _UniFFI_Client_SendMessage_waker(raw_env: env.toOpaque())
        }
    }

    public func setUserIsComposing(conversation: BareJid, isComposing: Bool) async throws {
        let future = try
            rustCallWithError(FfiConverterTypeClientError.self) {
                _uniffi_prose_core_ffi_impl_Client_set_user_is_composing_c2f7(self.pointer,
                                                                              FfiConverterTypeBareJid.lower(conversation),
                                                                              FfiConverterBool.lower(isComposing), $0)
            }

        return try await withCheckedThrowingContinuation { continuation in
            let env = Unmanaged.passRetained(_UniFFI_Client_SetUserIsComposing_Env(rustyFuture: future, continuation: continuation))
            _UniFFI_Client_SetUserIsComposing_waker(raw_env: env.toOpaque())
        }
    }

    public func toggleReactionToMessage(conversation: BareJid, id: MessageId, emoji: Emoji) async throws {
        let future = try
            rustCallWithError(FfiConverterTypeClientError.self) {
                _uniffi_prose_core_ffi_impl_Client_toggle_reaction_to_message_3fd2(self.pointer,
                                                                                   FfiConverterTypeBareJid.lower(conversation),
                                                                                   FfiConverterTypeMessageId.lower(id),
                                                                                   FfiConverterTypeEmoji.lower(emoji), $0)
            }

        return try await withCheckedThrowingContinuation { continuation in
            let env = Unmanaged.passRetained(_UniFFI_Client_ToggleReactionToMessage_Env(rustyFuture: future, continuation: continuation))
            _UniFFI_Client_ToggleReactionToMessage_waker(raw_env: env.toOpaque())
        }
    }

    public func updateMessage(conversation: BareJid, id: MessageId, body: String) async throws {
        let future = try
            rustCallWithError(FfiConverterTypeClientError.self) {
                _uniffi_prose_core_ffi_impl_Client_update_message_d453(self.pointer,
                                                                       FfiConverterTypeBareJid.lower(conversation),
                                                                       FfiConverterTypeMessageId.lower(id),
                                                                       FfiConverterString.lower(body), $0)
            }

        return try await withCheckedThrowingContinuation { continuation in
            let env = Unmanaged.passRetained(_UniFFI_Client_UpdateMessage_Env(rustyFuture: future, continuation: continuation))
            _UniFFI_Client_UpdateMessage_waker(raw_env: env.toOpaque())
        }
    }
}

private class _UniFFI_Client_Connect_Env {
    var rustFuture: OpaquePointer
    var continuation: CheckedContinuation<Void, Error>

    init(rustyFuture: OpaquePointer, continuation: CheckedContinuation<Void, Error>) {
        rustFuture = rustyFuture
        self.continuation = continuation
    }

    deinit {
        try! rustCall {
            _uniffi_prose_core_ffi_impl_Client_connect_5f8b_drop(self.rustFuture, $0)
        }
    }
}

private func _UniFFI_Client_Connect_waker(raw_env: UnsafeMutableRawPointer?) {
    Task {
        let env = Unmanaged<_UniFFI_Client_Connect_Env>.fromOpaque(raw_env!)
        let env_ref = env.takeUnretainedValue()
        let polledResult = UnsafeMutableRawPointer.allocate(byteCount: 0, alignment: 0)
        do {
            let isReady = try rustCallWithError(FfiConverterTypeConnectionError.self) {
                _uniffi_prose_core_ffi_impl_Client_connect_5f8b_poll(
                    env_ref.rustFuture,
                    _UniFFI_Client_Connect_waker,
                    env.toOpaque(),
                    polledResult,
                    $0
                )
            }

            if isReady {
                env_ref.continuation.resume(returning: ())
                polledResult.deallocate()
                env.release()
            }
        } catch {
            env_ref.continuation.resume(throwing: error)
            polledResult.deallocate()
            env.release()
        }
    }
}

private class _UniFFI_Client_Disconnect_Env {
    var rustFuture: OpaquePointer
    var continuation: CheckedContinuation<Void, Error>

    init(rustyFuture: OpaquePointer, continuation: CheckedContinuation<Void, Error>) {
        rustFuture = rustyFuture
        self.continuation = continuation
    }

    deinit {
        try! rustCall {
            _uniffi_prose_core_ffi_impl_Client_disconnect_10c0_drop(self.rustFuture, $0)
        }
    }
}

private func _UniFFI_Client_Disconnect_waker(raw_env: UnsafeMutableRawPointer?) {
    Task {
        let env = Unmanaged<_UniFFI_Client_Disconnect_Env>.fromOpaque(raw_env!)
        let env_ref = env.takeUnretainedValue()
        let polledResult = UnsafeMutableRawPointer.allocate(byteCount: 0, alignment: 0)
        do {
            let isReady = try rustCallWithError(FfiConverterTypeClientError.self) {
                _uniffi_prose_core_ffi_impl_Client_disconnect_10c0_poll(
                    env_ref.rustFuture,
                    _UniFFI_Client_Disconnect_waker,
                    env.toOpaque(),
                    polledResult,
                    $0
                )
            }

            if isReady {
                env_ref.continuation.resume(returning: ())
                polledResult.deallocate()
                env.release()
            }
        } catch {
            env_ref.continuation.resume(throwing: error)
            polledResult.deallocate()
            env.release()
        }
    }
}

private class _UniFFI_Client_LoadAvatar_Env {
    var rustFuture: OpaquePointer
    var continuation: CheckedContinuation<PathBuf?, Error>

    init(rustyFuture: OpaquePointer, continuation: CheckedContinuation<PathBuf?, Error>) {
        rustFuture = rustyFuture
        self.continuation = continuation
    }

    deinit {
        try! rustCall {
            _uniffi_prose_core_ffi_impl_Client_load_avatar_e49a_drop(self.rustFuture, $0)
        }
    }
}

private func _UniFFI_Client_LoadAvatar_waker(raw_env: UnsafeMutableRawPointer?) {
    Task {
        let env = Unmanaged<_UniFFI_Client_LoadAvatar_Env>.fromOpaque(raw_env!)
        let env_ref = env.takeUnretainedValue()
        let polledResult = UnsafeMutablePointer<RustBuffer>.allocate(capacity: 1)
        do {
            let isReady = try rustCallWithError(FfiConverterTypeClientError.self) {
                _uniffi_prose_core_ffi_impl_Client_load_avatar_e49a_poll(
                    env_ref.rustFuture,
                    _UniFFI_Client_LoadAvatar_waker,
                    env.toOpaque(),
                    polledResult,
                    $0
                )
            }

            if isReady {
                env_ref.continuation.resume(returning: try! FfiConverterOptionTypePathBuf.lift(polledResult.move()))
                polledResult.deallocate()
                env.release()
            }
        } catch {
            env_ref.continuation.resume(throwing: error)
            polledResult.deallocate()
            env.release()
        }
    }
}

private class _UniFFI_Client_LoadComposingUsers_Env {
    var rustFuture: OpaquePointer
    var continuation: CheckedContinuation<[BareJid], Error>

    init(rustyFuture: OpaquePointer, continuation: CheckedContinuation<[BareJid], Error>) {
        rustFuture = rustyFuture
        self.continuation = continuation
    }

    deinit {
        try! rustCall {
            _uniffi_prose_core_ffi_impl_Client_load_composing_users_ae9e_drop(self.rustFuture, $0)
        }
    }
}

private func _UniFFI_Client_LoadComposingUsers_waker(raw_env: UnsafeMutableRawPointer?) {
    Task {
        let env = Unmanaged<_UniFFI_Client_LoadComposingUsers_Env>.fromOpaque(raw_env!)
        let env_ref = env.takeUnretainedValue()
        let polledResult = UnsafeMutablePointer<RustBuffer>.allocate(capacity: 1)
        do {
            let isReady = try rustCallWithError(FfiConverterTypeClientError.self) {
                _uniffi_prose_core_ffi_impl_Client_load_composing_users_ae9e_poll(
                    env_ref.rustFuture,
                    _UniFFI_Client_LoadComposingUsers_waker,
                    env.toOpaque(),
                    polledResult,
                    $0
                )
            }

            if isReady {
                env_ref.continuation.resume(returning: try! FfiConverterSequenceTypeBareJid.lift(polledResult.move()))
                polledResult.deallocate()
                env.release()
            }
        } catch {
            env_ref.continuation.resume(throwing: error)
            polledResult.deallocate()
            env.release()
        }
    }
}

private class _UniFFI_Client_LoadContacts_Env {
    var rustFuture: OpaquePointer
    var continuation: CheckedContinuation<[Contact], Error>

    init(rustyFuture: OpaquePointer, continuation: CheckedContinuation<[Contact], Error>) {
        rustFuture = rustyFuture
        self.continuation = continuation
    }

    deinit {
        try! rustCall {
            _uniffi_prose_core_ffi_impl_Client_load_contacts_5bc5_drop(self.rustFuture, $0)
        }
    }
}

private func _UniFFI_Client_LoadContacts_waker(raw_env: UnsafeMutableRawPointer?) {
    Task {
        let env = Unmanaged<_UniFFI_Client_LoadContacts_Env>.fromOpaque(raw_env!)
        let env_ref = env.takeUnretainedValue()
        let polledResult = UnsafeMutablePointer<RustBuffer>.allocate(capacity: 1)
        do {
            let isReady = try rustCallWithError(FfiConverterTypeClientError.self) {
                _uniffi_prose_core_ffi_impl_Client_load_contacts_5bc5_poll(
                    env_ref.rustFuture,
                    _UniFFI_Client_LoadContacts_waker,
                    env.toOpaque(),
                    polledResult,
                    $0
                )
            }

            if isReady {
                env_ref.continuation.resume(returning: try! FfiConverterSequenceTypeContact.lift(polledResult.move()))
                polledResult.deallocate()
                env.release()
            }
        } catch {
            env_ref.continuation.resume(throwing: error)
            polledResult.deallocate()
            env.release()
        }
    }
}

private class _UniFFI_Client_LoadLatestMessages_Env {
    var rustFuture: OpaquePointer
    var continuation: CheckedContinuation<[Message], Error>

    init(rustyFuture: OpaquePointer, continuation: CheckedContinuation<[Message], Error>) {
        rustFuture = rustyFuture
        self.continuation = continuation
    }

    deinit {
        try! rustCall {
            _uniffi_prose_core_ffi_impl_Client_load_latest_messages_7960_drop(self.rustFuture, $0)
        }
    }
}

private func _UniFFI_Client_LoadLatestMessages_waker(raw_env: UnsafeMutableRawPointer?) {
    Task {
        let env = Unmanaged<_UniFFI_Client_LoadLatestMessages_Env>.fromOpaque(raw_env!)
        let env_ref = env.takeUnretainedValue()
        let polledResult = UnsafeMutablePointer<RustBuffer>.allocate(capacity: 1)
        do {
            let isReady = try rustCallWithError(FfiConverterTypeClientError.self) {
                _uniffi_prose_core_ffi_impl_Client_load_latest_messages_7960_poll(
                    env_ref.rustFuture,
                    _UniFFI_Client_LoadLatestMessages_waker,
                    env.toOpaque(),
                    polledResult,
                    $0
                )
            }

            if isReady {
                env_ref.continuation.resume(returning: try! FfiConverterSequenceTypeMessage.lift(polledResult.move()))
                polledResult.deallocate()
                env.release()
            }
        } catch {
            env_ref.continuation.resume(throwing: error)
            polledResult.deallocate()
            env.release()
        }
    }
}

private class _UniFFI_Client_LoadMessagesBefore_Env {
    var rustFuture: OpaquePointer
    var continuation: CheckedContinuation<MessagesPage, Error>

    init(rustyFuture: OpaquePointer, continuation: CheckedContinuation<MessagesPage, Error>) {
        rustFuture = rustyFuture
        self.continuation = continuation
    }

    deinit {
        try! rustCall {
            _uniffi_prose_core_ffi_impl_Client_load_messages_before_5eed_drop(self.rustFuture, $0)
        }
    }
}

private func _UniFFI_Client_LoadMessagesBefore_waker(raw_env: UnsafeMutableRawPointer?) {
    Task {
        let env = Unmanaged<_UniFFI_Client_LoadMessagesBefore_Env>.fromOpaque(raw_env!)
        let env_ref = env.takeUnretainedValue()
        let polledResult = UnsafeMutablePointer<RustBuffer>.allocate(capacity: 1)
        do {
            let isReady = try rustCallWithError(FfiConverterTypeClientError.self) {
                _uniffi_prose_core_ffi_impl_Client_load_messages_before_5eed_poll(
                    env_ref.rustFuture,
                    _UniFFI_Client_LoadMessagesBefore_waker,
                    env.toOpaque(),
                    polledResult,
                    $0
                )
            }

            if isReady {
                env_ref.continuation.resume(returning: try! FfiConverterTypeMessagesPage.lift(polledResult.move()))
                polledResult.deallocate()
                env.release()
            }
        } catch {
            env_ref.continuation.resume(throwing: error)
            polledResult.deallocate()
            env.release()
        }
    }
}

private class _UniFFI_Client_LoadMessagesWithIds_Env {
    var rustFuture: OpaquePointer
    var continuation: CheckedContinuation<[Message], Error>

    init(rustyFuture: OpaquePointer, continuation: CheckedContinuation<[Message], Error>) {
        rustFuture = rustyFuture
        self.continuation = continuation
    }

    deinit {
        try! rustCall {
            _uniffi_prose_core_ffi_impl_Client_load_messages_with_ids_fc47_drop(self.rustFuture, $0)
        }
    }
}

private func _UniFFI_Client_LoadMessagesWithIds_waker(raw_env: UnsafeMutableRawPointer?) {
    Task {
        let env = Unmanaged<_UniFFI_Client_LoadMessagesWithIds_Env>.fromOpaque(raw_env!)
        let env_ref = env.takeUnretainedValue()
        let polledResult = UnsafeMutablePointer<RustBuffer>.allocate(capacity: 1)
        do {
            let isReady = try rustCallWithError(FfiConverterTypeClientError.self) {
                _uniffi_prose_core_ffi_impl_Client_load_messages_with_ids_fc47_poll(
                    env_ref.rustFuture,
                    _UniFFI_Client_LoadMessagesWithIds_waker,
                    env.toOpaque(),
                    polledResult,
                    $0
                )
            }

            if isReady {
                env_ref.continuation.resume(returning: try! FfiConverterSequenceTypeMessage.lift(polledResult.move()))
                polledResult.deallocate()
                env.release()
            }
        } catch {
            env_ref.continuation.resume(throwing: error)
            polledResult.deallocate()
            env.release()
        }
    }
}

private class _UniFFI_Client_LoadProfile_Env {
    var rustFuture: OpaquePointer
    var continuation: CheckedContinuation<UserProfile, Error>

    init(rustyFuture: OpaquePointer, continuation: CheckedContinuation<UserProfile, Error>) {
        rustFuture = rustyFuture
        self.continuation = continuation
    }

    deinit {
        try! rustCall {
            _uniffi_prose_core_ffi_impl_Client_load_profile_8146_drop(self.rustFuture, $0)
        }
    }
}

private func _UniFFI_Client_LoadProfile_waker(raw_env: UnsafeMutableRawPointer?) {
    Task {
        let env = Unmanaged<_UniFFI_Client_LoadProfile_Env>.fromOpaque(raw_env!)
        let env_ref = env.takeUnretainedValue()
        let polledResult = UnsafeMutablePointer<RustBuffer>.allocate(capacity: 1)
        do {
            let isReady = try rustCallWithError(FfiConverterTypeClientError.self) {
                _uniffi_prose_core_ffi_impl_Client_load_profile_8146_poll(
                    env_ref.rustFuture,
                    _UniFFI_Client_LoadProfile_waker,
                    env.toOpaque(),
                    polledResult,
                    $0
                )
            }

            if isReady {
                env_ref.continuation.resume(returning: try! FfiConverterTypeUserProfile.lift(polledResult.move()))
                polledResult.deallocate()
                env.release()
            }
        } catch {
            env_ref.continuation.resume(throwing: error)
            polledResult.deallocate()
            env.release()
        }
    }
}

private class _UniFFI_Client_RetractMessage_Env {
    var rustFuture: OpaquePointer
    var continuation: CheckedContinuation<Void, Error>

    init(rustyFuture: OpaquePointer, continuation: CheckedContinuation<Void, Error>) {
        rustFuture = rustyFuture
        self.continuation = continuation
    }

    deinit {
        try! rustCall {
            _uniffi_prose_core_ffi_impl_Client_retract_message_340e_drop(self.rustFuture, $0)
        }
    }
}

private func _UniFFI_Client_RetractMessage_waker(raw_env: UnsafeMutableRawPointer?) {
    Task {
        let env = Unmanaged<_UniFFI_Client_RetractMessage_Env>.fromOpaque(raw_env!)
        let env_ref = env.takeUnretainedValue()
        let polledResult = UnsafeMutableRawPointer.allocate(byteCount: 0, alignment: 0)
        do {
            let isReady = try rustCallWithError(FfiConverterTypeClientError.self) {
                _uniffi_prose_core_ffi_impl_Client_retract_message_340e_poll(
                    env_ref.rustFuture,
                    _UniFFI_Client_RetractMessage_waker,
                    env.toOpaque(),
                    polledResult,
                    $0
                )
            }

            if isReady {
                env_ref.continuation.resume(returning: ())
                polledResult.deallocate()
                env.release()
            }
        } catch {
            env_ref.continuation.resume(throwing: error)
            polledResult.deallocate()
            env.release()
        }
    }
}

private class _UniFFI_Client_SaveAvatar_Env {
    var rustFuture: OpaquePointer
    var continuation: CheckedContinuation<Void, Error>

    init(rustyFuture: OpaquePointer, continuation: CheckedContinuation<Void, Error>) {
        rustFuture = rustyFuture
        self.continuation = continuation
    }

    deinit {
        try! rustCall {
            _uniffi_prose_core_ffi_impl_Client_save_avatar_b078_drop(self.rustFuture, $0)
        }
    }
}

private func _UniFFI_Client_SaveAvatar_waker(raw_env: UnsafeMutableRawPointer?) {
    Task {
        let env = Unmanaged<_UniFFI_Client_SaveAvatar_Env>.fromOpaque(raw_env!)
        let env_ref = env.takeUnretainedValue()
        let polledResult = UnsafeMutableRawPointer.allocate(byteCount: 0, alignment: 0)
        do {
            let isReady = try rustCallWithError(FfiConverterTypeClientError.self) {
                _uniffi_prose_core_ffi_impl_Client_save_avatar_b078_poll(
                    env_ref.rustFuture,
                    _UniFFI_Client_SaveAvatar_waker,
                    env.toOpaque(),
                    polledResult,
                    $0
                )
            }

            if isReady {
                env_ref.continuation.resume(returning: ())
                polledResult.deallocate()
                env.release()
            }
        } catch {
            env_ref.continuation.resume(throwing: error)
            polledResult.deallocate()
            env.release()
        }
    }
}

private class _UniFFI_Client_SaveProfile_Env {
    var rustFuture: OpaquePointer
    var continuation: CheckedContinuation<Void, Error>

    init(rustyFuture: OpaquePointer, continuation: CheckedContinuation<Void, Error>) {
        rustFuture = rustyFuture
        self.continuation = continuation
    }

    deinit {
        try! rustCall {
            _uniffi_prose_core_ffi_impl_Client_save_profile_aee2_drop(self.rustFuture, $0)
        }
    }
}

private func _UniFFI_Client_SaveProfile_waker(raw_env: UnsafeMutableRawPointer?) {
    Task {
        let env = Unmanaged<_UniFFI_Client_SaveProfile_Env>.fromOpaque(raw_env!)
        let env_ref = env.takeUnretainedValue()
        let polledResult = UnsafeMutableRawPointer.allocate(byteCount: 0, alignment: 0)
        do {
            let isReady = try rustCallWithError(FfiConverterTypeClientError.self) {
                _uniffi_prose_core_ffi_impl_Client_save_profile_aee2_poll(
                    env_ref.rustFuture,
                    _UniFFI_Client_SaveProfile_waker,
                    env.toOpaque(),
                    polledResult,
                    $0
                )
            }

            if isReady {
                env_ref.continuation.resume(returning: ())
                polledResult.deallocate()
                env.release()
            }
        } catch {
            env_ref.continuation.resume(throwing: error)
            polledResult.deallocate()
            env.release()
        }
    }
}

private class _UniFFI_Client_SendMessage_Env {
    var rustFuture: OpaquePointer
    var continuation: CheckedContinuation<Void, Error>

    init(rustyFuture: OpaquePointer, continuation: CheckedContinuation<Void, Error>) {
        rustFuture = rustyFuture
        self.continuation = continuation
    }

    deinit {
        try! rustCall {
            _uniffi_prose_core_ffi_impl_Client_send_message_d23e_drop(self.rustFuture, $0)
        }
    }
}

private func _UniFFI_Client_SendMessage_waker(raw_env: UnsafeMutableRawPointer?) {
    Task {
        let env = Unmanaged<_UniFFI_Client_SendMessage_Env>.fromOpaque(raw_env!)
        let env_ref = env.takeUnretainedValue()
        let polledResult = UnsafeMutableRawPointer.allocate(byteCount: 0, alignment: 0)
        do {
            let isReady = try rustCallWithError(FfiConverterTypeClientError.self) {
                _uniffi_prose_core_ffi_impl_Client_send_message_d23e_poll(
                    env_ref.rustFuture,
                    _UniFFI_Client_SendMessage_waker,
                    env.toOpaque(),
                    polledResult,
                    $0
                )
            }

            if isReady {
                env_ref.continuation.resume(returning: ())
                polledResult.deallocate()
                env.release()
            }
        } catch {
            env_ref.continuation.resume(throwing: error)
            polledResult.deallocate()
            env.release()
        }
    }
}

private class _UniFFI_Client_SetUserIsComposing_Env {
    var rustFuture: OpaquePointer
    var continuation: CheckedContinuation<Void, Error>

    init(rustyFuture: OpaquePointer, continuation: CheckedContinuation<Void, Error>) {
        rustFuture = rustyFuture
        self.continuation = continuation
    }

    deinit {
        try! rustCall {
            _uniffi_prose_core_ffi_impl_Client_set_user_is_composing_c2f7_drop(self.rustFuture, $0)
        }
    }
}

private func _UniFFI_Client_SetUserIsComposing_waker(raw_env: UnsafeMutableRawPointer?) {
    Task {
        let env = Unmanaged<_UniFFI_Client_SetUserIsComposing_Env>.fromOpaque(raw_env!)
        let env_ref = env.takeUnretainedValue()
        let polledResult = UnsafeMutableRawPointer.allocate(byteCount: 0, alignment: 0)
        do {
            let isReady = try rustCallWithError(FfiConverterTypeClientError.self) {
                _uniffi_prose_core_ffi_impl_Client_set_user_is_composing_c2f7_poll(
                    env_ref.rustFuture,
                    _UniFFI_Client_SetUserIsComposing_waker,
                    env.toOpaque(),
                    polledResult,
                    $0
                )
            }

            if isReady {
                env_ref.continuation.resume(returning: ())
                polledResult.deallocate()
                env.release()
            }
        } catch {
            env_ref.continuation.resume(throwing: error)
            polledResult.deallocate()
            env.release()
        }
    }
}

private class _UniFFI_Client_ToggleReactionToMessage_Env {
    var rustFuture: OpaquePointer
    var continuation: CheckedContinuation<Void, Error>

    init(rustyFuture: OpaquePointer, continuation: CheckedContinuation<Void, Error>) {
        rustFuture = rustyFuture
        self.continuation = continuation
    }

    deinit {
        try! rustCall {
            _uniffi_prose_core_ffi_impl_Client_toggle_reaction_to_message_3fd2_drop(self.rustFuture, $0)
        }
    }
}

private func _UniFFI_Client_ToggleReactionToMessage_waker(raw_env: UnsafeMutableRawPointer?) {
    Task {
        let env = Unmanaged<_UniFFI_Client_ToggleReactionToMessage_Env>.fromOpaque(raw_env!)
        let env_ref = env.takeUnretainedValue()
        let polledResult = UnsafeMutableRawPointer.allocate(byteCount: 0, alignment: 0)
        do {
            let isReady = try rustCallWithError(FfiConverterTypeClientError.self) {
                _uniffi_prose_core_ffi_impl_Client_toggle_reaction_to_message_3fd2_poll(
                    env_ref.rustFuture,
                    _UniFFI_Client_ToggleReactionToMessage_waker,
                    env.toOpaque(),
                    polledResult,
                    $0
                )
            }

            if isReady {
                env_ref.continuation.resume(returning: ())
                polledResult.deallocate()
                env.release()
            }
        } catch {
            env_ref.continuation.resume(throwing: error)
            polledResult.deallocate()
            env.release()
        }
    }
}

private class _UniFFI_Client_UpdateMessage_Env {
    var rustFuture: OpaquePointer
    var continuation: CheckedContinuation<Void, Error>

    init(rustyFuture: OpaquePointer, continuation: CheckedContinuation<Void, Error>) {
        rustFuture = rustyFuture
        self.continuation = continuation
    }

    deinit {
        try! rustCall {
            _uniffi_prose_core_ffi_impl_Client_update_message_d453_drop(self.rustFuture, $0)
        }
    }
}

private func _UniFFI_Client_UpdateMessage_waker(raw_env: UnsafeMutableRawPointer?) {
    Task {
        let env = Unmanaged<_UniFFI_Client_UpdateMessage_Env>.fromOpaque(raw_env!)
        let env_ref = env.takeUnretainedValue()
        let polledResult = UnsafeMutableRawPointer.allocate(byteCount: 0, alignment: 0)
        do {
            let isReady = try rustCallWithError(FfiConverterTypeClientError.self) {
                _uniffi_prose_core_ffi_impl_Client_update_message_d453_poll(
                    env_ref.rustFuture,
                    _UniFFI_Client_UpdateMessage_waker,
                    env.toOpaque(),
                    polledResult,
                    $0
                )
            }

            if isReady {
                env_ref.continuation.resume(returning: ())
                polledResult.deallocate()
                env.release()
            }
        } catch {
            env_ref.continuation.resume(throwing: error)
            polledResult.deallocate()
            env.release()
        }
    }
}

public struct FfiConverterTypeClient: FfiConverter {
    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = Client

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Client {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if ptr == nil {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: Client, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> Client {
        return Client(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: Client) -> UnsafeMutableRawPointer {
        return value.pointer
    }
}

public func FfiConverterTypeClient_lift(_ pointer: UnsafeMutableRawPointer) throws -> Client {
    return try FfiConverterTypeClient.lift(pointer)
}

public func FfiConverterTypeClient_lower(_ value: Client) -> UnsafeMutableRawPointer {
    return FfiConverterTypeClient.lower(value)
}

public struct AccountBookmark {
    public var jid: BareJid
    public var isSelected: Bool

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(jid: BareJid, isSelected: Bool) {
        self.jid = jid
        self.isSelected = isSelected
    }
}

extension AccountBookmark: Equatable, Hashable {
    public static func == (lhs: AccountBookmark, rhs: AccountBookmark) -> Bool {
        if lhs.jid != rhs.jid {
            return false
        }
        if lhs.isSelected != rhs.isSelected {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(jid)
        hasher.combine(isSelected)
    }
}

public struct FfiConverterTypeAccountBookmark: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> AccountBookmark {
        return try AccountBookmark(
            jid: FfiConverterTypeBareJid.read(from: &buf),
            isSelected: FfiConverterBool.read(from: &buf)
        )
    }

    public static func write(_ value: AccountBookmark, into buf: inout [UInt8]) {
        FfiConverterTypeBareJid.write(value.jid, into: &buf)
        FfiConverterBool.write(value.isSelected, into: &buf)
    }
}

public func FfiConverterTypeAccountBookmark_lift(_ buf: RustBuffer) throws -> AccountBookmark {
    return try FfiConverterTypeAccountBookmark.lift(buf)
}

public func FfiConverterTypeAccountBookmark_lower(_ value: AccountBookmark) -> RustBuffer {
    return FfiConverterTypeAccountBookmark.lower(value)
}

public struct Address {
    public var locality: String?
    public var country: String?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(locality: String?, country: String?) {
        self.locality = locality
        self.country = country
    }
}

extension Address: Equatable, Hashable {
    public static func == (lhs: Address, rhs: Address) -> Bool {
        if lhs.locality != rhs.locality {
            return false
        }
        if lhs.country != rhs.country {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(locality)
        hasher.combine(country)
    }
}

public struct FfiConverterTypeAddress: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Address {
        return try Address(
            locality: FfiConverterOptionString.read(from: &buf),
            country: FfiConverterOptionString.read(from: &buf)
        )
    }

    public static func write(_ value: Address, into buf: inout [UInt8]) {
        FfiConverterOptionString.write(value.locality, into: &buf)
        FfiConverterOptionString.write(value.country, into: &buf)
    }
}

public func FfiConverterTypeAddress_lift(_ buf: RustBuffer) throws -> Address {
    return try FfiConverterTypeAddress.lift(buf)
}

public func FfiConverterTypeAddress_lower(_ value: Address) -> RustBuffer {
    return FfiConverterTypeAddress.lower(value)
}

public struct BareJid {
    public var node: String?
    public var domain: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(node: String?, domain: String) {
        self.node = node
        self.domain = domain
    }
}

extension BareJid: Equatable, Hashable {
    public static func == (lhs: BareJid, rhs: BareJid) -> Bool {
        if lhs.node != rhs.node {
            return false
        }
        if lhs.domain != rhs.domain {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(node)
        hasher.combine(domain)
    }
}

public struct FfiConverterTypeBareJid: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> BareJid {
        return try BareJid(
            node: FfiConverterOptionString.read(from: &buf),
            domain: FfiConverterString.read(from: &buf)
        )
    }

    public static func write(_ value: BareJid, into buf: inout [UInt8]) {
        FfiConverterOptionString.write(value.node, into: &buf)
        FfiConverterString.write(value.domain, into: &buf)
    }
}

public func FfiConverterTypeBareJid_lift(_ buf: RustBuffer) throws -> BareJid {
    return try FfiConverterTypeBareJid.lift(buf)
}

public func FfiConverterTypeBareJid_lower(_ value: BareJid) -> RustBuffer {
    return FfiConverterTypeBareJid.lower(value)
}

public struct Contact {
    public var jid: BareJid
    public var name: String
    public var avatar: PathBuf?
    public var availability: Availability
    public var status: String?
    public var groups: [String]

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(jid: BareJid, name: String, avatar: PathBuf?, availability: Availability, status: String?, groups: [String]) {
        self.jid = jid
        self.name = name
        self.avatar = avatar
        self.availability = availability
        self.status = status
        self.groups = groups
    }
}

extension Contact: Equatable, Hashable {
    public static func == (lhs: Contact, rhs: Contact) -> Bool {
        if lhs.jid != rhs.jid {
            return false
        }
        if lhs.name != rhs.name {
            return false
        }
        if lhs.avatar != rhs.avatar {
            return false
        }
        if lhs.availability != rhs.availability {
            return false
        }
        if lhs.status != rhs.status {
            return false
        }
        if lhs.groups != rhs.groups {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(jid)
        hasher.combine(name)
        hasher.combine(avatar)
        hasher.combine(availability)
        hasher.combine(status)
        hasher.combine(groups)
    }
}

public struct FfiConverterTypeContact: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Contact {
        return try Contact(
            jid: FfiConverterTypeBareJid.read(from: &buf),
            name: FfiConverterString.read(from: &buf),
            avatar: FfiConverterOptionTypePathBuf.read(from: &buf),
            availability: FfiConverterTypeAvailability.read(from: &buf),
            status: FfiConverterOptionString.read(from: &buf),
            groups: FfiConverterSequenceString.read(from: &buf)
        )
    }

    public static func write(_ value: Contact, into buf: inout [UInt8]) {
        FfiConverterTypeBareJid.write(value.jid, into: &buf)
        FfiConverterString.write(value.name, into: &buf)
        FfiConverterOptionTypePathBuf.write(value.avatar, into: &buf)
        FfiConverterTypeAvailability.write(value.availability, into: &buf)
        FfiConverterOptionString.write(value.status, into: &buf)
        FfiConverterSequenceString.write(value.groups, into: &buf)
    }
}

public func FfiConverterTypeContact_lift(_ buf: RustBuffer) throws -> Contact {
    return try FfiConverterTypeContact.lift(buf)
}

public func FfiConverterTypeContact_lower(_ value: Contact) -> RustBuffer {
    return FfiConverterTypeContact.lower(value)
}

public struct FullJid {
    public var node: String?
    public var domain: String
    public var resource: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(node: String?, domain: String, resource: String) {
        self.node = node
        self.domain = domain
        self.resource = resource
    }
}

extension FullJid: Equatable, Hashable {
    public static func == (lhs: FullJid, rhs: FullJid) -> Bool {
        if lhs.node != rhs.node {
            return false
        }
        if lhs.domain != rhs.domain {
            return false
        }
        if lhs.resource != rhs.resource {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(node)
        hasher.combine(domain)
        hasher.combine(resource)
    }
}

public struct FfiConverterTypeFullJid: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> FullJid {
        return try FullJid(
            node: FfiConverterOptionString.read(from: &buf),
            domain: FfiConverterString.read(from: &buf),
            resource: FfiConverterString.read(from: &buf)
        )
    }

    public static func write(_ value: FullJid, into buf: inout [UInt8]) {
        FfiConverterOptionString.write(value.node, into: &buf)
        FfiConverterString.write(value.domain, into: &buf)
        FfiConverterString.write(value.resource, into: &buf)
    }
}

public func FfiConverterTypeFullJid_lift(_ buf: RustBuffer) throws -> FullJid {
    return try FfiConverterTypeFullJid.lift(buf)
}

public func FfiConverterTypeFullJid_lower(_ value: FullJid) -> RustBuffer {
    return FfiConverterTypeFullJid.lower(value)
}

public struct Message {
    public var id: MessageId
    public var stanzaId: StanzaId?
    public var from: BareJid
    public var body: String
    public var timestamp: DateTime
    public var isRead: Bool
    public var isEdited: Bool
    public var isDelivered: Bool
    public var reactions: [Reaction]

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(id: MessageId, stanzaId: StanzaId?, from: BareJid, body: String, timestamp: DateTime, isRead: Bool, isEdited: Bool, isDelivered: Bool, reactions: [Reaction]) {
        self.id = id
        self.stanzaId = stanzaId
        self.from = from
        self.body = body
        self.timestamp = timestamp
        self.isRead = isRead
        self.isEdited = isEdited
        self.isDelivered = isDelivered
        self.reactions = reactions
    }
}

extension Message: Equatable, Hashable {
    public static func == (lhs: Message, rhs: Message) -> Bool {
        if lhs.id != rhs.id {
            return false
        }
        if lhs.stanzaId != rhs.stanzaId {
            return false
        }
        if lhs.from != rhs.from {
            return false
        }
        if lhs.body != rhs.body {
            return false
        }
        if lhs.timestamp != rhs.timestamp {
            return false
        }
        if lhs.isRead != rhs.isRead {
            return false
        }
        if lhs.isEdited != rhs.isEdited {
            return false
        }
        if lhs.isDelivered != rhs.isDelivered {
            return false
        }
        if lhs.reactions != rhs.reactions {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(id)
        hasher.combine(stanzaId)
        hasher.combine(from)
        hasher.combine(body)
        hasher.combine(timestamp)
        hasher.combine(isRead)
        hasher.combine(isEdited)
        hasher.combine(isDelivered)
        hasher.combine(reactions)
    }
}

public struct FfiConverterTypeMessage: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Message {
        return try Message(
            id: FfiConverterTypeMessageId.read(from: &buf),
            stanzaId: FfiConverterOptionTypeStanzaId.read(from: &buf),
            from: FfiConverterTypeBareJid.read(from: &buf),
            body: FfiConverterString.read(from: &buf),
            timestamp: FfiConverterTypeDateTime.read(from: &buf),
            isRead: FfiConverterBool.read(from: &buf),
            isEdited: FfiConverterBool.read(from: &buf),
            isDelivered: FfiConverterBool.read(from: &buf),
            reactions: FfiConverterSequenceTypeReaction.read(from: &buf)
        )
    }

    public static func write(_ value: Message, into buf: inout [UInt8]) {
        FfiConverterTypeMessageId.write(value.id, into: &buf)
        FfiConverterOptionTypeStanzaId.write(value.stanzaId, into: &buf)
        FfiConverterTypeBareJid.write(value.from, into: &buf)
        FfiConverterString.write(value.body, into: &buf)
        FfiConverterTypeDateTime.write(value.timestamp, into: &buf)
        FfiConverterBool.write(value.isRead, into: &buf)
        FfiConverterBool.write(value.isEdited, into: &buf)
        FfiConverterBool.write(value.isDelivered, into: &buf)
        FfiConverterSequenceTypeReaction.write(value.reactions, into: &buf)
    }
}

public func FfiConverterTypeMessage_lift(_ buf: RustBuffer) throws -> Message {
    return try FfiConverterTypeMessage.lift(buf)
}

public func FfiConverterTypeMessage_lower(_ value: Message) -> RustBuffer {
    return FfiConverterTypeMessage.lower(value)
}

public struct MessagesPage {
    public var messages: [Message]
    public var isComplete: Bool

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(messages: [Message], isComplete: Bool) {
        self.messages = messages
        self.isComplete = isComplete
    }
}

extension MessagesPage: Equatable, Hashable {
    public static func == (lhs: MessagesPage, rhs: MessagesPage) -> Bool {
        if lhs.messages != rhs.messages {
            return false
        }
        if lhs.isComplete != rhs.isComplete {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(messages)
        hasher.combine(isComplete)
    }
}

public struct FfiConverterTypeMessagesPage: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> MessagesPage {
        return try MessagesPage(
            messages: FfiConverterSequenceTypeMessage.read(from: &buf),
            isComplete: FfiConverterBool.read(from: &buf)
        )
    }

    public static func write(_ value: MessagesPage, into buf: inout [UInt8]) {
        FfiConverterSequenceTypeMessage.write(value.messages, into: &buf)
        FfiConverterBool.write(value.isComplete, into: &buf)
    }
}

public func FfiConverterTypeMessagesPage_lift(_ buf: RustBuffer) throws -> MessagesPage {
    return try FfiConverterTypeMessagesPage.lift(buf)
}

public func FfiConverterTypeMessagesPage_lower(_ value: MessagesPage) -> RustBuffer {
    return FfiConverterTypeMessagesPage.lower(value)
}

public struct Reaction {
    public var emoji: Emoji
    public var from: [BareJid]

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(emoji: Emoji, from: [BareJid]) {
        self.emoji = emoji
        self.from = from
    }
}

extension Reaction: Equatable, Hashable {
    public static func == (lhs: Reaction, rhs: Reaction) -> Bool {
        if lhs.emoji != rhs.emoji {
            return false
        }
        if lhs.from != rhs.from {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(emoji)
        hasher.combine(from)
    }
}

public struct FfiConverterTypeReaction: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Reaction {
        return try Reaction(
            emoji: FfiConverterTypeEmoji.read(from: &buf),
            from: FfiConverterSequenceTypeBareJid.read(from: &buf)
        )
    }

    public static func write(_ value: Reaction, into buf: inout [UInt8]) {
        FfiConverterTypeEmoji.write(value.emoji, into: &buf)
        FfiConverterSequenceTypeBareJid.write(value.from, into: &buf)
    }
}

public func FfiConverterTypeReaction_lift(_ buf: RustBuffer) throws -> Reaction {
    return try FfiConverterTypeReaction.lift(buf)
}

public func FfiConverterTypeReaction_lower(_ value: Reaction) -> RustBuffer {
    return FfiConverterTypeReaction.lower(value)
}

public struct UserProfile {
    public var fullName: String?
    public var nickname: String?
    public var org: String?
    public var title: String?
    public var email: String?
    public var tel: String?
    public var url: Url?
    public var address: Address?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(fullName: String?, nickname: String?, org: String?, title: String?, email: String?, tel: String?, url: Url?, address: Address?) {
        self.fullName = fullName
        self.nickname = nickname
        self.org = org
        self.title = title
        self.email = email
        self.tel = tel
        self.url = url
        self.address = address
    }
}

extension UserProfile: Equatable, Hashable {
    public static func == (lhs: UserProfile, rhs: UserProfile) -> Bool {
        if lhs.fullName != rhs.fullName {
            return false
        }
        if lhs.nickname != rhs.nickname {
            return false
        }
        if lhs.org != rhs.org {
            return false
        }
        if lhs.title != rhs.title {
            return false
        }
        if lhs.email != rhs.email {
            return false
        }
        if lhs.tel != rhs.tel {
            return false
        }
        if lhs.url != rhs.url {
            return false
        }
        if lhs.address != rhs.address {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(fullName)
        hasher.combine(nickname)
        hasher.combine(org)
        hasher.combine(title)
        hasher.combine(email)
        hasher.combine(tel)
        hasher.combine(url)
        hasher.combine(address)
    }
}

public struct FfiConverterTypeUserProfile: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> UserProfile {
        return try UserProfile(
            fullName: FfiConverterOptionString.read(from: &buf),
            nickname: FfiConverterOptionString.read(from: &buf),
            org: FfiConverterOptionString.read(from: &buf),
            title: FfiConverterOptionString.read(from: &buf),
            email: FfiConverterOptionString.read(from: &buf),
            tel: FfiConverterOptionString.read(from: &buf),
            url: FfiConverterOptionTypeUrl.read(from: &buf),
            address: FfiConverterOptionTypeAddress.read(from: &buf)
        )
    }

    public static func write(_ value: UserProfile, into buf: inout [UInt8]) {
        FfiConverterOptionString.write(value.fullName, into: &buf)
        FfiConverterOptionString.write(value.nickname, into: &buf)
        FfiConverterOptionString.write(value.org, into: &buf)
        FfiConverterOptionString.write(value.title, into: &buf)
        FfiConverterOptionString.write(value.email, into: &buf)
        FfiConverterOptionString.write(value.tel, into: &buf)
        FfiConverterOptionTypeUrl.write(value.url, into: &buf)
        FfiConverterOptionTypeAddress.write(value.address, into: &buf)
    }
}

public func FfiConverterTypeUserProfile_lift(_ buf: RustBuffer) throws -> UserProfile {
    return try FfiConverterTypeUserProfile.lift(buf)
}

public func FfiConverterTypeUserProfile_lower(_ value: UserProfile) -> RustBuffer {
    return FfiConverterTypeUserProfile.lower(value)
}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
public enum Availability {
    case available
    case unavailable
    case doNotDisturb
    case away
}

public struct FfiConverterTypeAvailability: FfiConverterRustBuffer {
    typealias SwiftType = Availability

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Availability {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        case 1: return .available

        case 2: return .unavailable

        case 3: return .doNotDisturb

        case 4: return .away

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: Availability, into buf: inout [UInt8]) {
        switch value {
        case .available:
            writeInt(&buf, Int32(1))

        case .unavailable:
            writeInt(&buf, Int32(2))

        case .doNotDisturb:
            writeInt(&buf, Int32(3))

        case .away:
            writeInt(&buf, Int32(4))
        }
    }
}

public func FfiConverterTypeAvailability_lift(_ buf: RustBuffer) throws -> Availability {
    return try FfiConverterTypeAvailability.lift(buf)
}

public func FfiConverterTypeAvailability_lower(_ value: Availability) -> RustBuffer {
    return FfiConverterTypeAvailability.lower(value)
}

extension Availability: Equatable, Hashable {}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
public enum ClientEvent {
    case composingUsersChanged(conversation: BareJid)
    case connectionStatusChanged(event: ConnectionEvent)
    case contactChanged(jid: BareJid)
    case messagesAppended(conversation: BareJid, messageIds: [MessageId])
    case messagesUpdated(conversation: BareJid, messageIds: [MessageId])
    case messagesDeleted(conversation: BareJid, messageIds: [MessageId])
}

public struct FfiConverterTypeClientEvent: FfiConverterRustBuffer {
    typealias SwiftType = ClientEvent

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ClientEvent {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        case 1: return try .composingUsersChanged(
                conversation: FfiConverterTypeBareJid.read(from: &buf)
            )

        case 2: return try .connectionStatusChanged(
                event: FfiConverterTypeConnectionEvent.read(from: &buf)
            )

        case 3: return try .contactChanged(
                jid: FfiConverterTypeBareJid.read(from: &buf)
            )

        case 4: return try .messagesAppended(
                conversation: FfiConverterTypeBareJid.read(from: &buf),
                messageIds: FfiConverterSequenceTypeMessageId.read(from: &buf)
            )

        case 5: return try .messagesUpdated(
                conversation: FfiConverterTypeBareJid.read(from: &buf),
                messageIds: FfiConverterSequenceTypeMessageId.read(from: &buf)
            )

        case 6: return try .messagesDeleted(
                conversation: FfiConverterTypeBareJid.read(from: &buf),
                messageIds: FfiConverterSequenceTypeMessageId.read(from: &buf)
            )

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: ClientEvent, into buf: inout [UInt8]) {
        switch value {
        case let .composingUsersChanged(conversation):
            writeInt(&buf, Int32(1))
            FfiConverterTypeBareJid.write(conversation, into: &buf)

        case let .connectionStatusChanged(event):
            writeInt(&buf, Int32(2))
            FfiConverterTypeConnectionEvent.write(event, into: &buf)

        case let .contactChanged(jid):
            writeInt(&buf, Int32(3))
            FfiConverterTypeBareJid.write(jid, into: &buf)

        case let .messagesAppended(conversation, messageIds):
            writeInt(&buf, Int32(4))
            FfiConverterTypeBareJid.write(conversation, into: &buf)
            FfiConverterSequenceTypeMessageId.write(messageIds, into: &buf)

        case let .messagesUpdated(conversation, messageIds):
            writeInt(&buf, Int32(5))
            FfiConverterTypeBareJid.write(conversation, into: &buf)
            FfiConverterSequenceTypeMessageId.write(messageIds, into: &buf)

        case let .messagesDeleted(conversation, messageIds):
            writeInt(&buf, Int32(6))
            FfiConverterTypeBareJid.write(conversation, into: &buf)
            FfiConverterSequenceTypeMessageId.write(messageIds, into: &buf)
        }
    }
}

public func FfiConverterTypeClientEvent_lift(_ buf: RustBuffer) throws -> ClientEvent {
    return try FfiConverterTypeClientEvent.lift(buf)
}

public func FfiConverterTypeClientEvent_lower(_ value: ClientEvent) -> RustBuffer {
    return FfiConverterTypeClientEvent.lower(value)
}

extension ClientEvent: Equatable, Hashable {}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
public enum ConnectionEvent {
    case connect
    case disconnect(error: ConnectionError)
}

public struct FfiConverterTypeConnectionEvent: FfiConverterRustBuffer {
    typealias SwiftType = ConnectionEvent

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ConnectionEvent {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        case 1: return .connect

        case 2: return try .disconnect(
                error: FfiConverterTypeConnectionError.read(from: &buf)
            )

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: ConnectionEvent, into buf: inout [UInt8]) {
        switch value {
        case .connect:
            writeInt(&buf, Int32(1))

        case let .disconnect(error):
            writeInt(&buf, Int32(2))
            FfiConverterTypeConnectionError.write(error, into: &buf)
        }
    }
}

public func FfiConverterTypeConnectionEvent_lift(_ buf: RustBuffer) throws -> ConnectionEvent {
    return try FfiConverterTypeConnectionEvent.lift(buf)
}

public func FfiConverterTypeConnectionEvent_lower(_ value: ConnectionEvent) -> RustBuffer {
    return FfiConverterTypeConnectionEvent.lower(value)
}

extension ConnectionEvent: Equatable, Hashable {}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
public enum LogLevel {
    case trace
    case debug
    case info
    case warn
    case error
}

public struct FfiConverterTypeLogLevel: FfiConverterRustBuffer {
    typealias SwiftType = LogLevel

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> LogLevel {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        case 1: return .trace

        case 2: return .debug

        case 3: return .info

        case 4: return .warn

        case 5: return .error

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: LogLevel, into buf: inout [UInt8]) {
        switch value {
        case .trace:
            writeInt(&buf, Int32(1))

        case .debug:
            writeInt(&buf, Int32(2))

        case .info:
            writeInt(&buf, Int32(3))

        case .warn:
            writeInt(&buf, Int32(4))

        case .error:
            writeInt(&buf, Int32(5))
        }
    }
}

public func FfiConverterTypeLogLevel_lift(_ buf: RustBuffer) throws -> LogLevel {
    return try FfiConverterTypeLogLevel.lift(buf)
}

public func FfiConverterTypeLogLevel_lower(_ value: LogLevel) -> RustBuffer {
    return FfiConverterTypeLogLevel.lower(value)
}

extension LogLevel: Equatable, Hashable {}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
public enum Subscription {
    case none
    case to
    case from
    case both
}

public struct FfiConverterTypeSubscription: FfiConverterRustBuffer {
    typealias SwiftType = Subscription

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Subscription {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        case 1: return .none

        case 2: return .to

        case 3: return .from

        case 4: return .both

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: Subscription, into buf: inout [UInt8]) {
        switch value {
        case .none:
            writeInt(&buf, Int32(1))

        case .to:
            writeInt(&buf, Int32(2))

        case .from:
            writeInt(&buf, Int32(3))

        case .both:
            writeInt(&buf, Int32(4))
        }
    }
}

public func FfiConverterTypeSubscription_lift(_ buf: RustBuffer) throws -> Subscription {
    return try FfiConverterTypeSubscription.lift(buf)
}

public func FfiConverterTypeSubscription_lower(_ value: Subscription) -> RustBuffer {
    return FfiConverterTypeSubscription.lower(value)
}

extension Subscription: Equatable, Hashable {}

public enum ClientError {
    case Generic(msg: String)
}

public struct FfiConverterTypeClientError: FfiConverterRustBuffer {
    typealias SwiftType = ClientError

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ClientError {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        case 1: return try .Generic(
                msg: FfiConverterString.read(from: &buf)
            )

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: ClientError, into buf: inout [UInt8]) {
        switch value {
        case let .Generic(msg):
            writeInt(&buf, Int32(1))
            FfiConverterString.write(msg, into: &buf)
        }
    }
}

extension ClientError: Equatable, Hashable {}

extension ClientError: Error {}

public enum ConnectionError {
    case TimedOut
    case InvalidCredentials
    case Generic(msg: String)
}

public struct FfiConverterTypeConnectionError: FfiConverterRustBuffer {
    typealias SwiftType = ConnectionError

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ConnectionError {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        case 1: return .TimedOut
        case 2: return .InvalidCredentials
        case 3: return try .Generic(
                msg: FfiConverterString.read(from: &buf)
            )

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: ConnectionError, into buf: inout [UInt8]) {
        switch value {
        case .TimedOut:
            writeInt(&buf, Int32(1))

        case .InvalidCredentials:
            writeInt(&buf, Int32(2))

        case let .Generic(msg):
            writeInt(&buf, Int32(3))
            FfiConverterString.write(msg, into: &buf)
        }
    }
}

extension ConnectionError: Equatable, Hashable {}

extension ConnectionError: Error {}

public enum JidParseError {
    // Simple error enums only carry a message
    case NoDomain(message: String)

    // Simple error enums only carry a message
    case NoResource(message: String)

    // Simple error enums only carry a message
    case EmptyNode(message: String)

    // Simple error enums only carry a message
    case EmptyResource(message: String)
}

public struct FfiConverterTypeJidParseError: FfiConverterRustBuffer {
    typealias SwiftType = JidParseError

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> JidParseError {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        case 1: return try .NoDomain(
                message: FfiConverterString.read(from: &buf)
            )

        case 2: return try .NoResource(
                message: FfiConverterString.read(from: &buf)
            )

        case 3: return try .EmptyNode(
                message: FfiConverterString.read(from: &buf)
            )

        case 4: return try .EmptyResource(
                message: FfiConverterString.read(from: &buf)
            )

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: JidParseError, into buf: inout [UInt8]) {
        switch value {
        case let .NoDomain(message):
            writeInt(&buf, Int32(1))
            FfiConverterString.write(message, into: &buf)
        case let .NoResource(message):
            writeInt(&buf, Int32(2))
            FfiConverterString.write(message, into: &buf)
        case let .EmptyNode(message):
            writeInt(&buf, Int32(3))
            FfiConverterString.write(message, into: &buf)
        case let .EmptyResource(message):
            writeInt(&buf, Int32(4))
            FfiConverterString.write(message, into: &buf)
        }
    }
}

extension JidParseError: Equatable, Hashable {}

extension JidParseError: Error {}

private extension NSLock {
    func withLock<T>(f: () throws -> T) rethrows -> T {
        lock()
        defer { self.unlock() }
        return try f()
    }
}

private typealias UniFFICallbackHandle = UInt64
private class UniFFICallbackHandleMap<T> {
    private var leftMap: [UniFFICallbackHandle: T] = [:]
    private var counter: [UniFFICallbackHandle: UInt64] = [:]
    private var rightMap: [ObjectIdentifier: UniFFICallbackHandle] = [:]

    private let lock = NSLock()
    private var currentHandle: UniFFICallbackHandle = 0
    private let stride: UniFFICallbackHandle = 1

    func insert(obj: T) -> UniFFICallbackHandle {
        lock.withLock {
            let id = ObjectIdentifier(obj as AnyObject)
            let handle = rightMap[id] ?? {
                currentHandle += stride
                let handle = currentHandle
                leftMap[handle] = obj
                rightMap[id] = handle
                return handle
            }()
            counter[handle] = (counter[handle] ?? 0) + 1
            return handle
        }
    }

    func get(handle: UniFFICallbackHandle) -> T? {
        lock.withLock {
            leftMap[handle]
        }
    }

    func delete(handle: UniFFICallbackHandle) {
        remove(handle: handle)
    }

    @discardableResult
    func remove(handle: UniFFICallbackHandle) -> T? {
        lock.withLock {
            defer { counter[handle] = (counter[handle] ?? 1) - 1 }
            guard counter[handle] == 1 else { return leftMap[handle] }
            let obj = leftMap.removeValue(forKey: handle)
            if let obj = obj {
                rightMap.removeValue(forKey: ObjectIdentifier(obj as AnyObject))
            }
            return obj
        }
    }
}

// Magic number for the Rust proxy to call using the same mechanism as every other method,
// to free the callback once it's dropped by Rust.
private let IDX_CALLBACK_FREE: Int32 = 0
// Callback return codes
private let UNIFFI_CALLBACK_SUCCESS: Int32 = 0
private let UNIFFI_CALLBACK_ERROR: Int32 = 1
private let UNIFFI_CALLBACK_UNEXPECTED_ERROR: Int32 = 2

// Declaration and FfiConverters for ClientDelegate Callback Interface

public protocol ClientDelegate: AnyObject {
    func handleEvent(event: ClientEvent)
}

// The ForeignCallback that is passed to Rust.
private let foreignCallbackCallbackInterfaceClientDelegate: ForeignCallback =
    { (handle: UniFFICallbackHandle, method: Int32, argsData: UnsafePointer<UInt8>, argsLen: Int32, out_buf: UnsafeMutablePointer<RustBuffer>) -> Int32 in

        func invokeHandleEvent(_ swiftCallbackInterface: ClientDelegate, _ argsData: UnsafePointer<UInt8>, _ argsLen: Int32, _: UnsafeMutablePointer<RustBuffer>) throws -> Int32 {
            var reader = createReader(data: Data(bytes: argsData, count: Int(argsLen)))
            func makeCall() throws -> Int32 {
                try swiftCallbackInterface.handleEvent(
                    event: FfiConverterTypeClientEvent.read(from: &reader)
                )
                return UNIFFI_CALLBACK_SUCCESS
            }
            return try makeCall()
        }

        switch method {
        case IDX_CALLBACK_FREE:
            FfiConverterCallbackInterfaceClientDelegate.drop(handle: handle)
            // Sucessful return
            // See docs of ForeignCallback in `uniffi_core/src/ffi/foreigncallbacks.rs`
            return UNIFFI_CALLBACK_SUCCESS
        case 1:
            let cb: ClientDelegate
            do {
                cb = try FfiConverterCallbackInterfaceClientDelegate.lift(handle)
            } catch {
                out_buf.pointee = FfiConverterString.lower("ClientDelegate: Invalid handle")
                return UNIFFI_CALLBACK_UNEXPECTED_ERROR
            }
            do {
                return try invokeHandleEvent(cb, argsData, argsLen, out_buf)
            } catch {
                out_buf.pointee = FfiConverterString.lower(String(describing: error))
                return UNIFFI_CALLBACK_UNEXPECTED_ERROR
            }

        // This should never happen, because an out of bounds method index won't
        // ever be used. Once we can catch errors, we should return an InternalError.
        // https://github.com/mozilla/uniffi-rs/issues/351
        default:
            // An unexpected error happened.
            // See docs of ForeignCallback in `uniffi_core/src/ffi/foreigncallbacks.rs`
            return UNIFFI_CALLBACK_UNEXPECTED_ERROR
        }
    }

// FfiConverter protocol for callback interfaces
private enum FfiConverterCallbackInterfaceClientDelegate {
    private static let initCallbackOnce: () = {
        // Swift ensures this initializer code will once run once, even when accessed by multiple threads.
        try! rustCall { (err: UnsafeMutablePointer<RustCallStatus>) in
            ffi_prose_core_ffi_3ba6_ClientDelegate_init_callback(foreignCallbackCallbackInterfaceClientDelegate, err)
        }
    }()

    private static func ensureCallbackinitialized() {
        _ = initCallbackOnce
    }

    static func drop(handle: UniFFICallbackHandle) {
        handleMap.remove(handle: handle)
    }

    private static var handleMap = UniFFICallbackHandleMap<ClientDelegate>()
}

extension FfiConverterCallbackInterfaceClientDelegate: FfiConverter {
    typealias SwiftType = ClientDelegate
    // We can use Handle as the FfiType because it's a typealias to UInt64
    typealias FfiType = UniFFICallbackHandle

    public static func lift(_ handle: UniFFICallbackHandle) throws -> SwiftType {
        ensureCallbackinitialized()
        guard let callback = handleMap.get(handle: handle) else {
            throw UniffiInternalError.unexpectedStaleHandle
        }
        return callback
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        ensureCallbackinitialized()
        let handle: UniFFICallbackHandle = try readInt(&buf)
        return try lift(handle)
    }

    public static func lower(_ v: SwiftType) -> UniFFICallbackHandle {
        ensureCallbackinitialized()
        return handleMap.insert(obj: v)
    }

    public static func write(_ v: SwiftType, into buf: inout [UInt8]) {
        ensureCallbackinitialized()
        writeInt(&buf, lower(v))
    }
}

// Declaration and FfiConverters for Logger Callback Interface

public protocol Logger: AnyObject {
    func log(level: LogLevel, message: String)
}

// The ForeignCallback that is passed to Rust.
private let foreignCallbackCallbackInterfaceLogger: ForeignCallback =
    { (handle: UniFFICallbackHandle, method: Int32, argsData: UnsafePointer<UInt8>, argsLen: Int32, out_buf: UnsafeMutablePointer<RustBuffer>) -> Int32 in

        func invokeLog(_ swiftCallbackInterface: Logger, _ argsData: UnsafePointer<UInt8>, _ argsLen: Int32, _: UnsafeMutablePointer<RustBuffer>) throws -> Int32 {
            var reader = createReader(data: Data(bytes: argsData, count: Int(argsLen)))
            func makeCall() throws -> Int32 {
                try swiftCallbackInterface.log(
                    level: FfiConverterTypeLogLevel.read(from: &reader),
                    message: FfiConverterString.read(from: &reader)
                )
                return UNIFFI_CALLBACK_SUCCESS
            }
            return try makeCall()
        }

        switch method {
        case IDX_CALLBACK_FREE:
            FfiConverterCallbackInterfaceLogger.drop(handle: handle)
            // Sucessful return
            // See docs of ForeignCallback in `uniffi_core/src/ffi/foreigncallbacks.rs`
            return UNIFFI_CALLBACK_SUCCESS
        case 1:
            let cb: Logger
            do {
                cb = try FfiConverterCallbackInterfaceLogger.lift(handle)
            } catch {
                out_buf.pointee = FfiConverterString.lower("Logger: Invalid handle")
                return UNIFFI_CALLBACK_UNEXPECTED_ERROR
            }
            do {
                return try invokeLog(cb, argsData, argsLen, out_buf)
            } catch {
                out_buf.pointee = FfiConverterString.lower(String(describing: error))
                return UNIFFI_CALLBACK_UNEXPECTED_ERROR
            }

        // This should never happen, because an out of bounds method index won't
        // ever be used. Once we can catch errors, we should return an InternalError.
        // https://github.com/mozilla/uniffi-rs/issues/351
        default:
            // An unexpected error happened.
            // See docs of ForeignCallback in `uniffi_core/src/ffi/foreigncallbacks.rs`
            return UNIFFI_CALLBACK_UNEXPECTED_ERROR
        }
    }

// FfiConverter protocol for callback interfaces
private enum FfiConverterCallbackInterfaceLogger {
    private static let initCallbackOnce: () = {
        // Swift ensures this initializer code will once run once, even when accessed by multiple threads.
        try! rustCall { (err: UnsafeMutablePointer<RustCallStatus>) in
            ffi_prose_core_ffi_3ba6_Logger_init_callback(foreignCallbackCallbackInterfaceLogger, err)
        }
    }()

    private static func ensureCallbackinitialized() {
        _ = initCallbackOnce
    }

    static func drop(handle: UniFFICallbackHandle) {
        handleMap.remove(handle: handle)
    }

    private static var handleMap = UniFFICallbackHandleMap<Logger>()
}

extension FfiConverterCallbackInterfaceLogger: FfiConverter {
    typealias SwiftType = Logger
    // We can use Handle as the FfiType because it's a typealias to UInt64
    typealias FfiType = UniFFICallbackHandle

    public static func lift(_ handle: UniFFICallbackHandle) throws -> SwiftType {
        ensureCallbackinitialized()
        guard let callback = handleMap.get(handle: handle) else {
            throw UniffiInternalError.unexpectedStaleHandle
        }
        return callback
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        ensureCallbackinitialized()
        let handle: UniFFICallbackHandle = try readInt(&buf)
        return try lift(handle)
    }

    public static func lower(_ v: SwiftType) -> UniFFICallbackHandle {
        ensureCallbackinitialized()
        return handleMap.insert(obj: v)
    }

    public static func write(_ v: SwiftType, into buf: inout [UInt8]) {
        ensureCallbackinitialized()
        writeInt(&buf, lower(v))
    }
}

private struct FfiConverterOptionString: FfiConverterRustBuffer {
    typealias SwiftType = String?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterString.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterString.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

private struct FfiConverterOptionTypeAddress: FfiConverterRustBuffer {
    typealias SwiftType = Address?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeAddress.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeAddress.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

private struct FfiConverterOptionCallbackInterfaceClientDelegate: FfiConverterRustBuffer {
    typealias SwiftType = ClientDelegate?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterCallbackInterfaceClientDelegate.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterCallbackInterfaceClientDelegate.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

private struct FfiConverterOptionTypeMessageId: FfiConverterRustBuffer {
    typealias SwiftType = MessageId?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeMessageId.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeMessageId.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

private struct FfiConverterOptionTypePathBuf: FfiConverterRustBuffer {
    typealias SwiftType = PathBuf?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypePathBuf.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypePathBuf.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

private struct FfiConverterOptionTypeStanzaId: FfiConverterRustBuffer {
    typealias SwiftType = StanzaId?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeStanzaId.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeStanzaId.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

private struct FfiConverterOptionTypeUrl: FfiConverterRustBuffer {
    typealias SwiftType = Url?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeUrl.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeUrl.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

private struct FfiConverterSequenceString: FfiConverterRustBuffer {
    typealias SwiftType = [String]

    public static func write(_ value: [String], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterString.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [String] {
        let len: Int32 = try readInt(&buf)
        var seq = [String]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            try seq.append(FfiConverterString.read(from: &buf))
        }
        return seq
    }
}

private struct FfiConverterSequenceTypeAccountBookmark: FfiConverterRustBuffer {
    typealias SwiftType = [AccountBookmark]

    public static func write(_ value: [AccountBookmark], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeAccountBookmark.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [AccountBookmark] {
        let len: Int32 = try readInt(&buf)
        var seq = [AccountBookmark]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            try seq.append(FfiConverterTypeAccountBookmark.read(from: &buf))
        }
        return seq
    }
}

private struct FfiConverterSequenceTypeBareJid: FfiConverterRustBuffer {
    typealias SwiftType = [BareJid]

    public static func write(_ value: [BareJid], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeBareJid.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [BareJid] {
        let len: Int32 = try readInt(&buf)
        var seq = [BareJid]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            try seq.append(FfiConverterTypeBareJid.read(from: &buf))
        }
        return seq
    }
}

private struct FfiConverterSequenceTypeContact: FfiConverterRustBuffer {
    typealias SwiftType = [Contact]

    public static func write(_ value: [Contact], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeContact.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [Contact] {
        let len: Int32 = try readInt(&buf)
        var seq = [Contact]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            try seq.append(FfiConverterTypeContact.read(from: &buf))
        }
        return seq
    }
}

private struct FfiConverterSequenceTypeMessage: FfiConverterRustBuffer {
    typealias SwiftType = [Message]

    public static func write(_ value: [Message], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeMessage.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [Message] {
        let len: Int32 = try readInt(&buf)
        var seq = [Message]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            try seq.append(FfiConverterTypeMessage.read(from: &buf))
        }
        return seq
    }
}

private struct FfiConverterSequenceTypeReaction: FfiConverterRustBuffer {
    typealias SwiftType = [Reaction]

    public static func write(_ value: [Reaction], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeReaction.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [Reaction] {
        let len: Int32 = try readInt(&buf)
        var seq = [Reaction]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            try seq.append(FfiConverterTypeReaction.read(from: &buf))
        }
        return seq
    }
}

private struct FfiConverterSequenceTypeMessageId: FfiConverterRustBuffer {
    typealias SwiftType = [MessageId]

    public static func write(_ value: [MessageId], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeMessageId.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [MessageId] {
        let len: Int32 = try readInt(&buf)
        var seq = [MessageId]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            try seq.append(FfiConverterTypeMessageId.read(from: &buf))
        }
        return seq
    }
}

/**
 * Typealias from the type name used in the UDL file to the custom type.  This
 * is needed because the UDL type name is used in function/method signatures.
 */
public typealias DateTime = Date

public struct FfiConverterTypeDateTime: FfiConverter {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> DateTime {
        let builtinValue = try FfiConverterInt64.read(from: &buf)
        return Date(timeIntervalSince1970: TimeInterval(builtinValue) / 1000)
    }

    public static func write(_ value: DateTime, into buf: inout [UInt8]) {
        let builtinValue = Int64(value.timeIntervalSince1970 * 1000)
        return FfiConverterInt64.write(builtinValue, into: &buf)
    }

    public static func lift(_ value: Int64) throws -> DateTime {
        let builtinValue = try FfiConverterInt64.lift(value)
        return Date(timeIntervalSince1970: TimeInterval(builtinValue) / 1000)
    }

    public static func lower(_ value: DateTime) -> Int64 {
        let builtinValue = Int64(value.timeIntervalSince1970 * 1000)
        return FfiConverterInt64.lower(builtinValue)
    }
}

public func FfiConverterTypeDateTime_lift(_ value: Int64) throws -> DateTime {
    return try FfiConverterTypeDateTime.lift(value)
}

public func FfiConverterTypeDateTime_lower(_ value: DateTime) -> Int64 {
    return FfiConverterTypeDateTime.lower(value)
}

public struct FfiConverterTypeEmoji: FfiConverter {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Emoji {
        let builtinValue = try FfiConverterString.read(from: &buf)
        return Emoji(builtinValue)
    }

    public static func write(_ value: Emoji, into buf: inout [UInt8]) {
        let builtinValue = value.rawValue
        return FfiConverterString.write(builtinValue, into: &buf)
    }

    public static func lift(_ value: RustBuffer) throws -> Emoji {
        let builtinValue = try FfiConverterString.lift(value)
        return Emoji(builtinValue)
    }

    public static func lower(_ value: Emoji) -> RustBuffer {
        let builtinValue = value.rawValue
        return FfiConverterString.lower(builtinValue)
    }
}

public func FfiConverterTypeEmoji_lift(_ value: RustBuffer) throws -> Emoji {
    return try FfiConverterTypeEmoji.lift(value)
}

public func FfiConverterTypeEmoji_lower(_ value: Emoji) -> RustBuffer {
    return FfiConverterTypeEmoji.lower(value)
}

public struct FfiConverterTypeMessageId: FfiConverter {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> MessageId {
        let builtinValue = try FfiConverterString.read(from: &buf)
        return MessageId(builtinValue)
    }

    public static func write(_ value: MessageId, into buf: inout [UInt8]) {
        let builtinValue = value.rawValue
        return FfiConverterString.write(builtinValue, into: &buf)
    }

    public static func lift(_ value: RustBuffer) throws -> MessageId {
        let builtinValue = try FfiConverterString.lift(value)
        return MessageId(builtinValue)
    }

    public static func lower(_ value: MessageId) -> RustBuffer {
        let builtinValue = value.rawValue
        return FfiConverterString.lower(builtinValue)
    }
}

public func FfiConverterTypeMessageId_lift(_ value: RustBuffer) throws -> MessageId {
    return try FfiConverterTypeMessageId.lift(value)
}

public func FfiConverterTypeMessageId_lower(_ value: MessageId) -> RustBuffer {
    return FfiConverterTypeMessageId.lower(value)
}

/**
 * Typealias from the type name used in the UDL file to the custom type.  This
 * is needed because the UDL type name is used in function/method signatures.
 */
public typealias PathBuf = URL

public struct FfiConverterTypePathBuf: FfiConverter {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> PathBuf {
        let builtinValue = try FfiConverterString.read(from: &buf)
        return URL(fileURLWithPath: builtinValue)
    }

    public static func write(_ value: PathBuf, into buf: inout [UInt8]) {
        let builtinValue = value.path
        return FfiConverterString.write(builtinValue, into: &buf)
    }

    public static func lift(_ value: RustBuffer) throws -> PathBuf {
        let builtinValue = try FfiConverterString.lift(value)
        return URL(fileURLWithPath: builtinValue)
    }

    public static func lower(_ value: PathBuf) -> RustBuffer {
        let builtinValue = value.path
        return FfiConverterString.lower(builtinValue)
    }
}

public func FfiConverterTypePathBuf_lift(_ value: RustBuffer) throws -> PathBuf {
    return try FfiConverterTypePathBuf.lift(value)
}

public func FfiConverterTypePathBuf_lower(_ value: PathBuf) -> RustBuffer {
    return FfiConverterTypePathBuf.lower(value)
}

/**
 * Typealias from the type name used in the UDL file to the builtin type.  This
 * is needed because the UDL type name is used in function/method signatures.
 */
public typealias StanzaId = String
public struct FfiConverterTypeStanzaId: FfiConverter {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> StanzaId {
        return try FfiConverterString.read(from: &buf)
    }

    public static func write(_ value: StanzaId, into buf: inout [UInt8]) {
        return FfiConverterString.write(value, into: &buf)
    }

    public static func lift(_ value: RustBuffer) throws -> StanzaId {
        return try FfiConverterString.lift(value)
    }

    public static func lower(_ value: StanzaId) -> RustBuffer {
        return FfiConverterString.lower(value)
    }
}

/**
 * Typealias from the type name used in the UDL file to the custom type.  This
 * is needed because the UDL type name is used in function/method signatures.
 */
public typealias Url = URL

public struct FfiConverterTypeUrl: FfiConverter {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Url {
        let builtinValue = try FfiConverterString.read(from: &buf)
        return URL(string: builtinValue)!
    }

    public static func write(_ value: Url, into buf: inout [UInt8]) {
        let builtinValue = value.path
        return FfiConverterString.write(builtinValue, into: &buf)
    }

    public static func lift(_ value: RustBuffer) throws -> Url {
        let builtinValue = try FfiConverterString.lift(value)
        return URL(string: builtinValue)!
    }

    public static func lower(_ value: Url) -> RustBuffer {
        let builtinValue = value.path
        return FfiConverterString.lower(builtinValue)
    }
}

public func FfiConverterTypeUrl_lift(_ value: RustBuffer) throws -> Url {
    return try FfiConverterTypeUrl.lift(value)
}

public func FfiConverterTypeUrl_lower(_ value: Url) -> RustBuffer {
    return FfiConverterTypeUrl.lower(value)
}

public func setLogger(logger: Logger, maxLevel: LogLevel) {
    try! rustCall {
        prose_core_ffi_3ba6_set_logger(
            FfiConverterCallbackInterfaceLogger.lower(logger),
            FfiConverterTypeLogLevel.lower(maxLevel), $0
        )
    }
}

public func formatJid(jid: BareJid) -> String {
    return try! FfiConverterString.lift(
        try! rustCall {
            _uniffi_prose_core_ffi_format_jid_59dc(
                FfiConverterTypeBareJid.lower(jid), $0
            )
        }
    )
}

public func parseJid(jid: String) throws -> BareJid {
    return try FfiConverterTypeBareJid.lift(
        rustCallWithError(FfiConverterTypeJidParseError.self) {
            _uniffi_prose_core_ffi_parse_jid_5ef6(
                FfiConverterString.lower(jid), $0
            )
        }
    )
}

/**
 * Top level initializers and tear down methods.
 *
 * This is generated by uniffi.
 */
public enum ProseCoreFfiLifecycle {
    /**
     * Initialize the FFI and Rust library. This should be only called once per application.
     */
    func initialize() {}
}
