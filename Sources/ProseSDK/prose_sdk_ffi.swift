// This file was autogenerated by some hot garbage in the `uniffi` crate.
// Trust me, you don't want to mess with it!

// swiftlint:disable all
import Foundation
import Foundation

// Depending on the consumer's build setup, the low-level FFI code
// might be in a separate module, or it might be compiled inline into
// this module. This is a bit of light hackery to work with both.
#if canImport(prose_sdk_ffiFFI)
import prose_sdk_ffiFFI
#endif

fileprivate extension RustBuffer {
    // Allocate a new buffer, copying the contents of a `UInt8` array.
    init(bytes: [UInt8]) {
        let rbuf = bytes.withUnsafeBufferPointer { ptr in
            RustBuffer.from(ptr)
        }
        self.init(capacity: rbuf.capacity, len: rbuf.len, data: rbuf.data)
    }

    static func empty() -> RustBuffer {
        RustBuffer(capacity: 0, len:0, data: nil)
    }

    static func from(_ ptr: UnsafeBufferPointer<UInt8>) -> RustBuffer {
        try! rustCall { ffi_prose_sdk_ffi_rustbuffer_from_bytes(ForeignBytes(bufferPointer: ptr), $0) }
    }

    // Frees the buffer in place.
    // The buffer must not be used after this is called.
    func deallocate() {
        try! rustCall { ffi_prose_sdk_ffi_rustbuffer_free(self, $0) }
    }
}

fileprivate extension ForeignBytes {
    init(bufferPointer: UnsafeBufferPointer<UInt8>) {
        self.init(len: Int32(bufferPointer.count), data: bufferPointer.baseAddress)
    }
}

// For every type used in the interface, we provide helper methods for conveniently
// lifting and lowering that type from C-compatible data, and for reading and writing
// values of that type in a buffer.

// Helper classes/extensions that don't change.
// Someday, this will be in a library of its own.

fileprivate extension Data {
    init(rustBuffer: RustBuffer) {
        self.init(
            bytesNoCopy: rustBuffer.data!,
            count: Int(rustBuffer.len),
            deallocator: .none
        )
    }
}

// Define reader functionality.  Normally this would be defined in a class or
// struct, but we use standalone functions instead in order to make external
// types work.
//
// With external types, one swift source file needs to be able to call the read
// method on another source file's FfiConverter, but then what visibility
// should Reader have?
// - If Reader is fileprivate, then this means the read() must also
//   be fileprivate, which doesn't work with external types.
// - If Reader is internal/public, we'll get compile errors since both source
//   files will try define the same type.
//
// Instead, the read() method and these helper functions input a tuple of data

fileprivate func createReader(data: Data) -> (data: Data, offset: Data.Index) {
    (data: data, offset: 0)
}

// Reads an integer at the current offset, in big-endian order, and advances
// the offset on success. Throws if reading the integer would move the
// offset past the end of the buffer.
fileprivate func readInt<T: FixedWidthInteger>(_ reader: inout (data: Data, offset: Data.Index)) throws -> T {
    let range = reader.offset..<reader.offset + MemoryLayout<T>.size
    guard reader.data.count >= range.upperBound else {
        throw UniffiInternalError.bufferOverflow
    }
    if T.self == UInt8.self {
        let value = reader.data[reader.offset]
        reader.offset += 1
        return value as! T
    }
    var value: T = 0
    let _ = withUnsafeMutableBytes(of: &value, { reader.data.copyBytes(to: $0, from: range)})
    reader.offset = range.upperBound
    return value.bigEndian
}

// Reads an arbitrary number of bytes, to be used to read
// raw bytes, this is useful when lifting strings
fileprivate func readBytes(_ reader: inout (data: Data, offset: Data.Index), count: Int) throws -> Array<UInt8> {
    let range = reader.offset..<(reader.offset+count)
    guard reader.data.count >= range.upperBound else {
        throw UniffiInternalError.bufferOverflow
    }
    var value = [UInt8](repeating: 0, count: count)
    value.withUnsafeMutableBufferPointer({ buffer in
        reader.data.copyBytes(to: buffer, from: range)
    })
    reader.offset = range.upperBound
    return value
}

// Reads a float at the current offset.
fileprivate func readFloat(_ reader: inout (data: Data, offset: Data.Index)) throws -> Float {
    return Float(bitPattern: try readInt(&reader))
}

// Reads a float at the current offset.
fileprivate func readDouble(_ reader: inout (data: Data, offset: Data.Index)) throws -> Double {
    return Double(bitPattern: try readInt(&reader))
}

// Indicates if the offset has reached the end of the buffer.
fileprivate func hasRemaining(_ reader: (data: Data, offset: Data.Index)) -> Bool {
    return reader.offset < reader.data.count
}

// Define writer functionality.  Normally this would be defined in a class or
// struct, but we use standalone functions instead in order to make external
// types work.  See the above discussion on Readers for details.

fileprivate func createWriter() -> [UInt8] {
    return []
}

fileprivate func writeBytes<S>(_ writer: inout [UInt8], _ byteArr: S) where S: Sequence, S.Element == UInt8 {
    writer.append(contentsOf: byteArr)
}

// Writes an integer in big-endian order.
//
// Warning: make sure what you are trying to write
// is in the correct type!
fileprivate func writeInt<T: FixedWidthInteger>(_ writer: inout [UInt8], _ value: T) {
    var value = value.bigEndian
    withUnsafeBytes(of: &value) { writer.append(contentsOf: $0) }
}

fileprivate func writeFloat(_ writer: inout [UInt8], _ value: Float) {
    writeInt(&writer, value.bitPattern)
}

fileprivate func writeDouble(_ writer: inout [UInt8], _ value: Double) {
    writeInt(&writer, value.bitPattern)
}

// Protocol for types that transfer other types across the FFI. This is
// analogous to the Rust trait of the same name.
fileprivate protocol FfiConverter {
    associatedtype FfiType
    associatedtype SwiftType

    static func lift(_ value: FfiType) throws -> SwiftType
    static func lower(_ value: SwiftType) -> FfiType
    static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType
    static func write(_ value: SwiftType, into buf: inout [UInt8])
}

// Types conforming to `Primitive` pass themselves directly over the FFI.
fileprivate protocol FfiConverterPrimitive: FfiConverter where FfiType == SwiftType { }

extension FfiConverterPrimitive {
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public static func lift(_ value: FfiType) throws -> SwiftType {
        return value
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public static func lower(_ value: SwiftType) -> FfiType {
        return value
    }
}

// Types conforming to `FfiConverterRustBuffer` lift and lower into a `RustBuffer`.
// Used for complex types where it's hard to write a custom lift/lower.
fileprivate protocol FfiConverterRustBuffer: FfiConverter where FfiType == RustBuffer {}

extension FfiConverterRustBuffer {
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public static func lift(_ buf: RustBuffer) throws -> SwiftType {
        var reader = createReader(data: Data(rustBuffer: buf))
        let value = try read(from: &reader)
        if hasRemaining(reader) {
            throw UniffiInternalError.incompleteData
        }
        buf.deallocate()
        return value
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public static func lower(_ value: SwiftType) -> RustBuffer {
          var writer = createWriter()
          write(value, into: &writer)
          return RustBuffer(bytes: writer)
    }
}
// An error type for FFI errors. These errors occur at the UniFFI level, not
// the library level.
fileprivate enum UniffiInternalError: LocalizedError {
    case bufferOverflow
    case incompleteData
    case unexpectedOptionalTag
    case unexpectedEnumCase
    case unexpectedNullPointer
    case unexpectedRustCallStatusCode
    case unexpectedRustCallError
    case unexpectedStaleHandle
    case rustPanic(_ message: String)

    public var errorDescription: String? {
        switch self {
        case .bufferOverflow: return "Reading the requested value would read past the end of the buffer"
        case .incompleteData: return "The buffer still has data after lifting its containing value"
        case .unexpectedOptionalTag: return "Unexpected optional tag; should be 0 or 1"
        case .unexpectedEnumCase: return "Raw enum value doesn't match any cases"
        case .unexpectedNullPointer: return "Raw pointer value was null"
        case .unexpectedRustCallStatusCode: return "Unexpected RustCallStatus code"
        case .unexpectedRustCallError: return "CALL_ERROR but no errorClass specified"
        case .unexpectedStaleHandle: return "The object in the handle map has been dropped already"
        case let .rustPanic(message): return message
        }
    }
}

fileprivate extension NSLock {
    func withLock<T>(f: () throws -> T) rethrows -> T {
        self.lock()
        defer { self.unlock() }
        return try f()
    }
}

fileprivate let CALL_SUCCESS: Int8 = 0
fileprivate let CALL_ERROR: Int8 = 1
fileprivate let CALL_UNEXPECTED_ERROR: Int8 = 2
fileprivate let CALL_CANCELLED: Int8 = 3

fileprivate extension RustCallStatus {
    init() {
        self.init(
            code: CALL_SUCCESS,
            errorBuf: RustBuffer.init(
                capacity: 0,
                len: 0,
                data: nil
            )
        )
    }
}

private func rustCall<T>(_ callback: (UnsafeMutablePointer<RustCallStatus>) -> T) throws -> T {
    let neverThrow: ((RustBuffer) throws -> Never)? = nil
    return try makeRustCall(callback, errorHandler: neverThrow)
}

private func rustCallWithError<T, E: Swift.Error>(
    _ errorHandler: @escaping (RustBuffer) throws -> E,
    _ callback: (UnsafeMutablePointer<RustCallStatus>) -> T) throws -> T {
    try makeRustCall(callback, errorHandler: errorHandler)
}

private func makeRustCall<T, E: Swift.Error>(
    _ callback: (UnsafeMutablePointer<RustCallStatus>) -> T,
    errorHandler: ((RustBuffer) throws -> E)?
) throws -> T {
    uniffiEnsureProseSdkFfiInitialized()
    var callStatus = RustCallStatus.init()
    let returnedVal = callback(&callStatus)
    try uniffiCheckCallStatus(callStatus: callStatus, errorHandler: errorHandler)
    return returnedVal
}

private func uniffiCheckCallStatus<E: Swift.Error>(
    callStatus: RustCallStatus,
    errorHandler: ((RustBuffer) throws -> E)?
) throws {
    switch callStatus.code {
        case CALL_SUCCESS:
            return

        case CALL_ERROR:
            if let errorHandler = errorHandler {
                throw try errorHandler(callStatus.errorBuf)
            } else {
                callStatus.errorBuf.deallocate()
                throw UniffiInternalError.unexpectedRustCallError
            }

        case CALL_UNEXPECTED_ERROR:
            // When the rust code sees a panic, it tries to construct a RustBuffer
            // with the message.  But if that code panics, then it just sends back
            // an empty buffer.
            if callStatus.errorBuf.len > 0 {
                throw UniffiInternalError.rustPanic(try FfiConverterString.lift(callStatus.errorBuf))
            } else {
                callStatus.errorBuf.deallocate()
                throw UniffiInternalError.rustPanic("Rust panic")
            }

        case CALL_CANCELLED:
            fatalError("Cancellation not supported yet")

        default:
            throw UniffiInternalError.unexpectedRustCallStatusCode
    }
}

private func uniffiTraitInterfaceCall<T>(
    callStatus: UnsafeMutablePointer<RustCallStatus>,
    makeCall: () throws -> T,
    writeReturn: (T) -> ()
) {
    do {
        try writeReturn(makeCall())
    } catch let error {
        callStatus.pointee.code = CALL_UNEXPECTED_ERROR
        callStatus.pointee.errorBuf = FfiConverterString.lower(String(describing: error))
    }
}

private func uniffiTraitInterfaceCallWithError<T, E>(
    callStatus: UnsafeMutablePointer<RustCallStatus>,
    makeCall: () throws -> T,
    writeReturn: (T) -> (),
    lowerError: (E) -> RustBuffer
) {
    do {
        try writeReturn(makeCall())
    } catch let error as E {
        callStatus.pointee.code = CALL_ERROR
        callStatus.pointee.errorBuf = lowerError(error)
    } catch {
        callStatus.pointee.code = CALL_UNEXPECTED_ERROR
        callStatus.pointee.errorBuf = FfiConverterString.lower(String(describing: error))
    }
}
fileprivate final class UniffiHandleMap<T>: @unchecked Sendable {
    // All mutation happens with this lock held, which is why we implement @unchecked Sendable.
    private let lock = NSLock()
    private var map: [UInt64: T] = [:]
    private var currentHandle: UInt64 = 1

    func insert(obj: T) -> UInt64 {
        lock.withLock {
            let handle = currentHandle
            currentHandle += 1
            map[handle] = obj
            return handle
        }
    }

     func get(handle: UInt64) throws -> T {
        try lock.withLock {
            guard let obj = map[handle] else {
                throw UniffiInternalError.unexpectedStaleHandle
            }
            return obj
        }
    }

    @discardableResult
    func remove(handle: UInt64) throws -> T {
        try lock.withLock {
            guard let obj = map.removeValue(forKey: handle) else {
                throw UniffiInternalError.unexpectedStaleHandle
            }
            return obj
        }
    }

    var count: Int {
        get {
            map.count
        }
    }
}


// Public interface members begin here.


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterUInt32: FfiConverterPrimitive {
    typealias FfiType = UInt32
    typealias SwiftType = UInt32

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> UInt32 {
        return try lift(readInt(&buf))
    }

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterUInt64: FfiConverterPrimitive {
    typealias FfiType = UInt64
    typealias SwiftType = UInt64

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> UInt64 {
        return try lift(readInt(&buf))
    }

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterInt64: FfiConverterPrimitive {
    typealias FfiType = Int64
    typealias SwiftType = Int64

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Int64 {
        return try lift(readInt(&buf))
    }

    public static func write(_ value: Int64, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterBool : FfiConverter {
    typealias FfiType = Int8
    typealias SwiftType = Bool

    public static func lift(_ value: Int8) throws -> Bool {
        return value != 0
    }

    public static func lower(_ value: Bool) -> Int8 {
        return value ? 1 : 0
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Bool {
        return try lift(readInt(&buf))
    }

    public static func write(_ value: Bool, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterString: FfiConverter {
    typealias SwiftType = String
    typealias FfiType = RustBuffer

    public static func lift(_ value: RustBuffer) throws -> String {
        defer {
            value.deallocate()
        }
        if value.data == nil {
            return String()
        }
        let bytes = UnsafeBufferPointer<UInt8>(start: value.data!, count: Int(value.len))
        return String(bytes: bytes, encoding: String.Encoding.utf8)!
    }

    public static func lower(_ value: String) -> RustBuffer {
        return value.utf8CString.withUnsafeBufferPointer { ptr in
            // The swift string gives us int8_t, we want uint8_t.
            ptr.withMemoryRebound(to: UInt8.self) { ptr in
                // The swift string gives us a trailing null byte, we don't want it.
                let buf = UnsafeBufferPointer(rebasing: ptr.prefix(upTo: ptr.count - 1))
                return RustBuffer.from(buf)
            }
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> String {
        let len: Int32 = try readInt(&buf)
        return String(bytes: try readBytes(&buf, count: Int(len)), encoding: String.Encoding.utf8)!
    }

    public static func write(_ value: String, into buf: inout [UInt8]) {
        let len = Int32(value.utf8.count)
        writeInt(&buf, len)
        writeBytes(&buf, value.utf8)
    }
}




public protocol AccountBookmarksClientProtocol: AnyObject, Sendable {
    
    func addBookmark(userId: UserId, selectBookmark: Bool) throws 
    
    func loadBookmarks() throws  -> [AccountBookmark]
    
    func removeBookmark(userId: UserId) throws 
    
    func saveBookmarks(bookmarks: [AccountBookmark]) throws 
    
    func selectBookmark(userId: UserId) throws 
    
}
open class AccountBookmarksClient: AccountBookmarksClientProtocol, @unchecked Sendable {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    // This constructor can be used to instantiate a fake object.
    // - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    //
    // - Warning:
    //     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_prose_sdk_ffi_fn_clone_accountbookmarksclient(self.pointer, $0) }
    }
public convenience init(bookmarksPath: PathBuf) {
    let pointer =
        try! rustCall() {
    uniffi_prose_sdk_ffi_fn_constructor_accountbookmarksclient_new(
        FfiConverterTypePathBuf_lower(bookmarksPath),$0
    )
}
    self.init(unsafeFromRawPointer: pointer)
}

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_prose_sdk_ffi_fn_free_accountbookmarksclient(pointer, $0) }
    }

    

    
open func addBookmark(userId: UserId, selectBookmark: Bool)throws   {try rustCallWithError(FfiConverterTypeClientError_lift) {
    uniffi_prose_sdk_ffi_fn_method_accountbookmarksclient_add_bookmark(self.uniffiClonePointer(),
        FfiConverterTypeUserId_lower(userId),
        FfiConverterBool.lower(selectBookmark),$0
    )
}
}
    
open func loadBookmarks()throws  -> [AccountBookmark]  {
    return try  FfiConverterSequenceTypeAccountBookmark.lift(try rustCallWithError(FfiConverterTypeClientError_lift) {
    uniffi_prose_sdk_ffi_fn_method_accountbookmarksclient_load_bookmarks(self.uniffiClonePointer(),$0
    )
})
}
    
open func removeBookmark(userId: UserId)throws   {try rustCallWithError(FfiConverterTypeClientError_lift) {
    uniffi_prose_sdk_ffi_fn_method_accountbookmarksclient_remove_bookmark(self.uniffiClonePointer(),
        FfiConverterTypeUserId_lower(userId),$0
    )
}
}
    
open func saveBookmarks(bookmarks: [AccountBookmark])throws   {try rustCallWithError(FfiConverterTypeClientError_lift) {
    uniffi_prose_sdk_ffi_fn_method_accountbookmarksclient_save_bookmarks(self.uniffiClonePointer(),
        FfiConverterSequenceTypeAccountBookmark.lower(bookmarks),$0
    )
}
}
    
open func selectBookmark(userId: UserId)throws   {try rustCallWithError(FfiConverterTypeClientError_lift) {
    uniffi_prose_sdk_ffi_fn_method_accountbookmarksclient_select_bookmark(self.uniffiClonePointer(),
        FfiConverterTypeUserId_lower(userId),$0
    )
}
}
    

}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeAccountBookmarksClient: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = AccountBookmarksClient

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> AccountBookmarksClient {
        return AccountBookmarksClient(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: AccountBookmarksClient) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> AccountBookmarksClient {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: AccountBookmarksClient, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeAccountBookmarksClient_lift(_ pointer: UnsafeMutableRawPointer) throws -> AccountBookmarksClient {
    return try FfiConverterTypeAccountBookmarksClient.lift(pointer)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeAccountBookmarksClient_lower(_ value: AccountBookmarksClient) -> UnsafeMutableRawPointer {
    return FfiConverterTypeAccountBookmarksClient.lower(value)
}






public protocol AvatarProtocol: AnyObject, Sendable {
    
    /**
     * An opaque identifier to check if the contents of the `Avatar` have changed.
     * While `ProseClient` caches loaded avatars, checking for a change in the `Avatar` might
     * still make sense, since `Client::loadAvatarDataURL` is asynchronous.
     */
    func id()  -> String
    
}
open class Avatar: AvatarProtocol, @unchecked Sendable {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    // This constructor can be used to instantiate a fake object.
    // - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    //
    // - Warning:
    //     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_prose_sdk_ffi_fn_clone_avatar(self.pointer, $0) }
    }
    // No primary constructor declared for this class.

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_prose_sdk_ffi_fn_free_avatar(pointer, $0) }
    }

    

    
    /**
     * An opaque identifier to check if the contents of the `Avatar` have changed.
     * While `ProseClient` caches loaded avatars, checking for a change in the `Avatar` might
     * still make sense, since `Client::loadAvatarDataURL` is asynchronous.
     */
open func id() -> String  {
    return try!  FfiConverterString.lift(try! rustCall() {
    uniffi_prose_sdk_ffi_fn_method_avatar_id(self.uniffiClonePointer(),$0
    )
})
}
    

}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeAvatar: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = Avatar

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> Avatar {
        return Avatar(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: Avatar) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Avatar {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: Avatar, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeAvatar_lift(_ pointer: UnsafeMutableRawPointer) throws -> Avatar {
    return try FfiConverterTypeAvatar.lift(pointer)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeAvatar_lower(_ value: Avatar) -> UnsafeMutableRawPointer {
    return FfiConverterTypeAvatar.lower(value)
}






public protocol ChannelProtocol: AnyObject, Sendable {
    
    func inviteUsers(users: [UserId]) async throws 
    
}
open class Channel: ChannelProtocol, @unchecked Sendable {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    // This constructor can be used to instantiate a fake object.
    // - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    //
    // - Warning:
    //     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_prose_sdk_ffi_fn_clone_channel(self.pointer, $0) }
    }
    // No primary constructor declared for this class.

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_prose_sdk_ffi_fn_free_channel(pointer, $0) }
    }

    

    
open func inviteUsers(users: [UserId])async throws   {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_prose_sdk_ffi_fn_method_channel_invite_users(
                    self.uniffiClonePointer(),
                    FfiConverterSequenceTypeUserId.lower(users)
                )
            },
            pollFunc: ffi_prose_sdk_ffi_rust_future_poll_void,
            completeFunc: ffi_prose_sdk_ffi_rust_future_complete_void,
            freeFunc: ffi_prose_sdk_ffi_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeClientError_lift
        )
}
    

}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeChannel: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = Channel

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> Channel {
        return Channel(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: Channel) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Channel {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: Channel, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeChannel_lift(_ pointer: UnsafeMutableRawPointer) throws -> Channel {
    return try FfiConverterTypeChannel.lift(pointer)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeChannel_lower(_ value: Channel) -> UnsafeMutableRawPointer {
    return FfiConverterTypeChannel.lower(value)
}






public protocol ClientProtocol: AnyObject, Sendable {
    
    /**
     * Adds a contact to the roster and sends a presence subscription request.
     */
    func addContact(userId: UserId) async throws 
    
    /**
     * Approves the presence subscription request identified by `id`.
     */
    func approvePresenceSubRequest(id: PresenceSubRequestId) async throws 
    
    /**
     * Blocks the user identified by `user_id`.
     */
    func blockUser(userId: UserId) async throws 
    
    /**
     * XEP-0077: In-Band Registration
     * https://xmpp.org/extensions/xep-0077.html#usecases-changepw
     */
    func changePassword(newPassword: String) async throws 
    
    /**
     * Removes all users from the block list.
     */
    func clearBlockList() async throws 
    
    func connect(userId: UserId, password: String) async throws 
    
    /**
     * Creates the group or joins it if it already exists and returns the `BareJid`.
     * Sends invites to all participants if the group was created.
     */
    func createGroup(participants: [UserId]) async throws  -> RoomId
    
    /**
     * Creates the private channel and returns the `BareJid` of the created room.
     */
    func createPrivateChannel(channelName: String) async throws  -> RoomId
    
    /**
     * Creates the public channel and returns the `BareJid` of the created room. Fails if another
     * channel with the same name exists.
     */
    func createPublicChannel(channelName: String) async throws  -> RoomId
    
    func deleteCachedData() async throws 
    
    /**
     * Denies the presence subscription request identified by `id`.
     */
    func denyPresenceSubRequest(id: PresenceSubRequestId) async throws 
    
    /**
     * Destroys the room identified by `room_jid`.
     */
    func destroyRoom(roomId: MucId) async throws 
    
    func disconnect() async throws 
    
    func enableLogging(minLevel: String) 
    
    func findPublicChannelByName(name: String) async throws  -> RoomId?
    
    /**
     * Joins the room identified by `room_jid` and returns its `BareJid`.
     */
    func joinRoom(roomId: MucId, password: String?) async throws  -> RoomId
    
    func loadAccountInfo() async throws  -> AccountInfo
    
    /**
     * XEP-0084: User Avatar
     * https://xmpp.org/extensions/xep-0084.html
     */
    func loadAvatar(avatar: Avatar) async throws  -> PathBuf?
    
    /**
     * Returns the list of blocked users.
     */
    func loadBlockList() async throws  -> [UserBasicInfo]
    
    func loadContacts() async throws  -> [Contact]
    
    /**
     * Loads pending presence subscription requests.
     */
    func loadPresenceSubRequests() async throws  -> [PresenceSubRequest]
    
    /**
     * XEP-0292: vCard4 Over XMPP
     * https://xmpp.org/extensions/xep-0292.html
     */
    func loadProfile(from: UserId) async throws  -> UserProfile?
    
    func loadPublicChannels() async throws  -> [PublicRoomInfo]
    
    func loadUserMetadata(userId: UserId) async throws  -> UserMetadata
    
    func loadWorkspaceIcon(icon: WorkspaceIcon) async throws  -> PathBuf?
    
    func loadWorkspaceInfo() async throws  -> WorkspaceInfo
    
    func previewMarkdown(markdown: String)  -> String
    
    /**
     * Removes a contact from the roster
     */
    func removeContact(userId: UserId) async throws 
    
    /**
     * Requests a presence subscription from `jid`. Note that happens automatically when you
     * call `add_contact`. This method can be useful though when our user needs to re-request
     * the presence subscription in case the contact hasn't reacted in a while.
     */
    func requestPresenceSub(userId: UserId) async throws 
    
    /**
     * Request a slot for uploading a file to attach it to a message.
     */
    func requestUploadSlot(fileName: String, fileSize: UInt64, mediaType: Mime?) async throws  -> UploadSlot
    
    /**
     * XEP-0084: User Avatar
     * https://xmpp.org/extensions/xep-0084.html
     */
    func saveAvatar(imagePath: PathBuf) async throws 
    
    /**
     * XEP-0292: vCard4 Over XMPP
     * https://xmpp.org/extensions/xep-0292.html
     */
    func saveProfile(profile: UserProfile) async throws 
    
    /**
     * XMPP: Instant Messaging and Presence
     * https://xmpp.org/rfcs/rfc6121.html#presence
     */
    func setAvailability(availability: Availability) async throws 
    
    /**
     * XEP-0108: User Activity
     * https://xmpp.org/extensions/xep-0108.html
     */
    func setUserActivity(status: UserStatus?) async throws 
    
    func sidebarItems() async  -> [SidebarItem]
    
    /**
     * Creates the direct message or joins it if it already exists and returns the `BareJid`.
     * Sends invites to all participants if the group was created.
     */
    func startConversation(participants: [UserId]) async throws  -> RoomId
    
    func startObservingRooms() async throws 
    
    /**
     * Unblocks the user identified by `user_id`.
     */
    func unblockUser(userId: UserId) async throws 
    
}
open class Client: ClientProtocol, @unchecked Sendable {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    // This constructor can be used to instantiate a fake object.
    // - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    //
    // - Warning:
    //     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_prose_sdk_ffi_fn_clone_client(self.pointer, $0) }
    }
public convenience init(cacheDir: PathBuf, delegate: ClientDelegate?, config: ClientConfig?)async throws  {
    let pointer =
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_prose_sdk_ffi_fn_constructor_client_new(FfiConverterTypePathBuf_lower(cacheDir),FfiConverterOptionTypeClientDelegate.lower(delegate),FfiConverterOptionTypeClientConfig.lower(config)
                )
            },
            pollFunc: ffi_prose_sdk_ffi_rust_future_poll_pointer,
            completeFunc: ffi_prose_sdk_ffi_rust_future_complete_pointer,
            freeFunc: ffi_prose_sdk_ffi_rust_future_free_pointer,
            liftFunc: FfiConverterTypeClient_lift,
            errorHandler: FfiConverterTypeClientError_lift
        )
        
        .uniffiClonePointer()
    self.init(unsafeFromRawPointer: pointer)
}

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_prose_sdk_ffi_fn_free_client(pointer, $0) }
    }

    

    
    /**
     * Adds a contact to the roster and sends a presence subscription request.
     */
open func addContact(userId: UserId)async throws   {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_prose_sdk_ffi_fn_method_client_add_contact(
                    self.uniffiClonePointer(),
                    FfiConverterTypeUserId_lower(userId)
                )
            },
            pollFunc: ffi_prose_sdk_ffi_rust_future_poll_void,
            completeFunc: ffi_prose_sdk_ffi_rust_future_complete_void,
            freeFunc: ffi_prose_sdk_ffi_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeClientError_lift
        )
}
    
    /**
     * Approves the presence subscription request identified by `id`.
     */
open func approvePresenceSubRequest(id: PresenceSubRequestId)async throws   {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_prose_sdk_ffi_fn_method_client_approve_presence_sub_request(
                    self.uniffiClonePointer(),
                    FfiConverterTypePresenceSubRequestId_lower(id)
                )
            },
            pollFunc: ffi_prose_sdk_ffi_rust_future_poll_void,
            completeFunc: ffi_prose_sdk_ffi_rust_future_complete_void,
            freeFunc: ffi_prose_sdk_ffi_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeClientError_lift
        )
}
    
    /**
     * Blocks the user identified by `user_id`.
     */
open func blockUser(userId: UserId)async throws   {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_prose_sdk_ffi_fn_method_client_block_user(
                    self.uniffiClonePointer(),
                    FfiConverterTypeUserId_lower(userId)
                )
            },
            pollFunc: ffi_prose_sdk_ffi_rust_future_poll_void,
            completeFunc: ffi_prose_sdk_ffi_rust_future_complete_void,
            freeFunc: ffi_prose_sdk_ffi_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeClientError_lift
        )
}
    
    /**
     * XEP-0077: In-Band Registration
     * https://xmpp.org/extensions/xep-0077.html#usecases-changepw
     */
open func changePassword(newPassword: String)async throws   {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_prose_sdk_ffi_fn_method_client_change_password(
                    self.uniffiClonePointer(),
                    FfiConverterString.lower(newPassword)
                )
            },
            pollFunc: ffi_prose_sdk_ffi_rust_future_poll_void,
            completeFunc: ffi_prose_sdk_ffi_rust_future_complete_void,
            freeFunc: ffi_prose_sdk_ffi_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeClientError_lift
        )
}
    
    /**
     * Removes all users from the block list.
     */
open func clearBlockList()async throws   {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_prose_sdk_ffi_fn_method_client_clear_block_list(
                    self.uniffiClonePointer()
                    
                )
            },
            pollFunc: ffi_prose_sdk_ffi_rust_future_poll_void,
            completeFunc: ffi_prose_sdk_ffi_rust_future_complete_void,
            freeFunc: ffi_prose_sdk_ffi_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeClientError_lift
        )
}
    
open func connect(userId: UserId, password: String)async throws   {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_prose_sdk_ffi_fn_method_client_connect(
                    self.uniffiClonePointer(),
                    FfiConverterTypeUserId_lower(userId),FfiConverterString.lower(password)
                )
            },
            pollFunc: ffi_prose_sdk_ffi_rust_future_poll_void,
            completeFunc: ffi_prose_sdk_ffi_rust_future_complete_void,
            freeFunc: ffi_prose_sdk_ffi_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeConnectionError_lift
        )
}
    
    /**
     * Creates the group or joins it if it already exists and returns the `BareJid`.
     * Sends invites to all participants if the group was created.
     */
open func createGroup(participants: [UserId])async throws  -> RoomId  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_prose_sdk_ffi_fn_method_client_create_group(
                    self.uniffiClonePointer(),
                    FfiConverterSequenceTypeUserId.lower(participants)
                )
            },
            pollFunc: ffi_prose_sdk_ffi_rust_future_poll_rust_buffer,
            completeFunc: ffi_prose_sdk_ffi_rust_future_complete_rust_buffer,
            freeFunc: ffi_prose_sdk_ffi_rust_future_free_rust_buffer,
            liftFunc: FfiConverterTypeRoomId_lift,
            errorHandler: FfiConverterTypeClientError_lift
        )
}
    
    /**
     * Creates the private channel and returns the `BareJid` of the created room.
     */
open func createPrivateChannel(channelName: String)async throws  -> RoomId  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_prose_sdk_ffi_fn_method_client_create_private_channel(
                    self.uniffiClonePointer(),
                    FfiConverterString.lower(channelName)
                )
            },
            pollFunc: ffi_prose_sdk_ffi_rust_future_poll_rust_buffer,
            completeFunc: ffi_prose_sdk_ffi_rust_future_complete_rust_buffer,
            freeFunc: ffi_prose_sdk_ffi_rust_future_free_rust_buffer,
            liftFunc: FfiConverterTypeRoomId_lift,
            errorHandler: FfiConverterTypeClientError_lift
        )
}
    
    /**
     * Creates the public channel and returns the `BareJid` of the created room. Fails if another
     * channel with the same name exists.
     */
open func createPublicChannel(channelName: String)async throws  -> RoomId  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_prose_sdk_ffi_fn_method_client_create_public_channel(
                    self.uniffiClonePointer(),
                    FfiConverterString.lower(channelName)
                )
            },
            pollFunc: ffi_prose_sdk_ffi_rust_future_poll_rust_buffer,
            completeFunc: ffi_prose_sdk_ffi_rust_future_complete_rust_buffer,
            freeFunc: ffi_prose_sdk_ffi_rust_future_free_rust_buffer,
            liftFunc: FfiConverterTypeRoomId_lift,
            errorHandler: FfiConverterTypeClientError_lift
        )
}
    
open func deleteCachedData()async throws   {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_prose_sdk_ffi_fn_method_client_delete_cached_data(
                    self.uniffiClonePointer()
                    
                )
            },
            pollFunc: ffi_prose_sdk_ffi_rust_future_poll_void,
            completeFunc: ffi_prose_sdk_ffi_rust_future_complete_void,
            freeFunc: ffi_prose_sdk_ffi_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeClientError_lift
        )
}
    
    /**
     * Denies the presence subscription request identified by `id`.
     */
open func denyPresenceSubRequest(id: PresenceSubRequestId)async throws   {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_prose_sdk_ffi_fn_method_client_deny_presence_sub_request(
                    self.uniffiClonePointer(),
                    FfiConverterTypePresenceSubRequestId_lower(id)
                )
            },
            pollFunc: ffi_prose_sdk_ffi_rust_future_poll_void,
            completeFunc: ffi_prose_sdk_ffi_rust_future_complete_void,
            freeFunc: ffi_prose_sdk_ffi_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeClientError_lift
        )
}
    
    /**
     * Destroys the room identified by `room_jid`.
     */
open func destroyRoom(roomId: MucId)async throws   {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_prose_sdk_ffi_fn_method_client_destroy_room(
                    self.uniffiClonePointer(),
                    FfiConverterTypeMucId_lower(roomId)
                )
            },
            pollFunc: ffi_prose_sdk_ffi_rust_future_poll_void,
            completeFunc: ffi_prose_sdk_ffi_rust_future_complete_void,
            freeFunc: ffi_prose_sdk_ffi_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeClientError_lift
        )
}
    
open func disconnect()async throws   {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_prose_sdk_ffi_fn_method_client_disconnect(
                    self.uniffiClonePointer()
                    
                )
            },
            pollFunc: ffi_prose_sdk_ffi_rust_future_poll_void,
            completeFunc: ffi_prose_sdk_ffi_rust_future_complete_void,
            freeFunc: ffi_prose_sdk_ffi_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeClientError_lift
        )
}
    
open func enableLogging(minLevel: String)  {try! rustCall() {
    uniffi_prose_sdk_ffi_fn_method_client_enable_logging(self.uniffiClonePointer(),
        FfiConverterString.lower(minLevel),$0
    )
}
}
    
open func findPublicChannelByName(name: String)async throws  -> RoomId?  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_prose_sdk_ffi_fn_method_client_find_public_channel_by_name(
                    self.uniffiClonePointer(),
                    FfiConverterString.lower(name)
                )
            },
            pollFunc: ffi_prose_sdk_ffi_rust_future_poll_rust_buffer,
            completeFunc: ffi_prose_sdk_ffi_rust_future_complete_rust_buffer,
            freeFunc: ffi_prose_sdk_ffi_rust_future_free_rust_buffer,
            liftFunc: FfiConverterOptionTypeRoomId.lift,
            errorHandler: FfiConverterTypeClientError_lift
        )
}
    
    /**
     * Joins the room identified by `room_jid` and returns its `BareJid`.
     */
open func joinRoom(roomId: MucId, password: String?)async throws  -> RoomId  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_prose_sdk_ffi_fn_method_client_join_room(
                    self.uniffiClonePointer(),
                    FfiConverterTypeMucId_lower(roomId),FfiConverterOptionString.lower(password)
                )
            },
            pollFunc: ffi_prose_sdk_ffi_rust_future_poll_rust_buffer,
            completeFunc: ffi_prose_sdk_ffi_rust_future_complete_rust_buffer,
            freeFunc: ffi_prose_sdk_ffi_rust_future_free_rust_buffer,
            liftFunc: FfiConverterTypeRoomId_lift,
            errorHandler: FfiConverterTypeClientError_lift
        )
}
    
open func loadAccountInfo()async throws  -> AccountInfo  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_prose_sdk_ffi_fn_method_client_load_account_info(
                    self.uniffiClonePointer()
                    
                )
            },
            pollFunc: ffi_prose_sdk_ffi_rust_future_poll_rust_buffer,
            completeFunc: ffi_prose_sdk_ffi_rust_future_complete_rust_buffer,
            freeFunc: ffi_prose_sdk_ffi_rust_future_free_rust_buffer,
            liftFunc: FfiConverterTypeAccountInfo_lift,
            errorHandler: FfiConverterTypeClientError_lift
        )
}
    
    /**
     * XEP-0084: User Avatar
     * https://xmpp.org/extensions/xep-0084.html
     */
open func loadAvatar(avatar: Avatar)async throws  -> PathBuf?  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_prose_sdk_ffi_fn_method_client_load_avatar(
                    self.uniffiClonePointer(),
                    FfiConverterTypeAvatar_lower(avatar)
                )
            },
            pollFunc: ffi_prose_sdk_ffi_rust_future_poll_rust_buffer,
            completeFunc: ffi_prose_sdk_ffi_rust_future_complete_rust_buffer,
            freeFunc: ffi_prose_sdk_ffi_rust_future_free_rust_buffer,
            liftFunc: FfiConverterOptionTypePathBuf.lift,
            errorHandler: FfiConverterTypeClientError_lift
        )
}
    
    /**
     * Returns the list of blocked users.
     */
open func loadBlockList()async throws  -> [UserBasicInfo]  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_prose_sdk_ffi_fn_method_client_load_block_list(
                    self.uniffiClonePointer()
                    
                )
            },
            pollFunc: ffi_prose_sdk_ffi_rust_future_poll_rust_buffer,
            completeFunc: ffi_prose_sdk_ffi_rust_future_complete_rust_buffer,
            freeFunc: ffi_prose_sdk_ffi_rust_future_free_rust_buffer,
            liftFunc: FfiConverterSequenceTypeUserBasicInfo.lift,
            errorHandler: FfiConverterTypeClientError_lift
        )
}
    
open func loadContacts()async throws  -> [Contact]  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_prose_sdk_ffi_fn_method_client_load_contacts(
                    self.uniffiClonePointer()
                    
                )
            },
            pollFunc: ffi_prose_sdk_ffi_rust_future_poll_rust_buffer,
            completeFunc: ffi_prose_sdk_ffi_rust_future_complete_rust_buffer,
            freeFunc: ffi_prose_sdk_ffi_rust_future_free_rust_buffer,
            liftFunc: FfiConverterSequenceTypeContact.lift,
            errorHandler: FfiConverterTypeClientError_lift
        )
}
    
    /**
     * Loads pending presence subscription requests.
     */
open func loadPresenceSubRequests()async throws  -> [PresenceSubRequest]  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_prose_sdk_ffi_fn_method_client_load_presence_sub_requests(
                    self.uniffiClonePointer()
                    
                )
            },
            pollFunc: ffi_prose_sdk_ffi_rust_future_poll_rust_buffer,
            completeFunc: ffi_prose_sdk_ffi_rust_future_complete_rust_buffer,
            freeFunc: ffi_prose_sdk_ffi_rust_future_free_rust_buffer,
            liftFunc: FfiConverterSequenceTypePresenceSubRequest.lift,
            errorHandler: FfiConverterTypeClientError_lift
        )
}
    
    /**
     * XEP-0292: vCard4 Over XMPP
     * https://xmpp.org/extensions/xep-0292.html
     */
open func loadProfile(from: UserId)async throws  -> UserProfile?  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_prose_sdk_ffi_fn_method_client_load_profile(
                    self.uniffiClonePointer(),
                    FfiConverterTypeUserId_lower(from)
                )
            },
            pollFunc: ffi_prose_sdk_ffi_rust_future_poll_rust_buffer,
            completeFunc: ffi_prose_sdk_ffi_rust_future_complete_rust_buffer,
            freeFunc: ffi_prose_sdk_ffi_rust_future_free_rust_buffer,
            liftFunc: FfiConverterOptionTypeUserProfile.lift,
            errorHandler: FfiConverterTypeClientError_lift
        )
}
    
open func loadPublicChannels()async throws  -> [PublicRoomInfo]  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_prose_sdk_ffi_fn_method_client_load_public_channels(
                    self.uniffiClonePointer()
                    
                )
            },
            pollFunc: ffi_prose_sdk_ffi_rust_future_poll_rust_buffer,
            completeFunc: ffi_prose_sdk_ffi_rust_future_complete_rust_buffer,
            freeFunc: ffi_prose_sdk_ffi_rust_future_free_rust_buffer,
            liftFunc: FfiConverterSequenceTypePublicRoomInfo.lift,
            errorHandler: FfiConverterTypeClientError_lift
        )
}
    
open func loadUserMetadata(userId: UserId)async throws  -> UserMetadata  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_prose_sdk_ffi_fn_method_client_load_user_metadata(
                    self.uniffiClonePointer(),
                    FfiConverterTypeUserId_lower(userId)
                )
            },
            pollFunc: ffi_prose_sdk_ffi_rust_future_poll_rust_buffer,
            completeFunc: ffi_prose_sdk_ffi_rust_future_complete_rust_buffer,
            freeFunc: ffi_prose_sdk_ffi_rust_future_free_rust_buffer,
            liftFunc: FfiConverterTypeUserMetadata_lift,
            errorHandler: FfiConverterTypeClientError_lift
        )
}
    
open func loadWorkspaceIcon(icon: WorkspaceIcon)async throws  -> PathBuf?  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_prose_sdk_ffi_fn_method_client_load_workspace_icon(
                    self.uniffiClonePointer(),
                    FfiConverterTypeWorkspaceIcon_lower(icon)
                )
            },
            pollFunc: ffi_prose_sdk_ffi_rust_future_poll_rust_buffer,
            completeFunc: ffi_prose_sdk_ffi_rust_future_complete_rust_buffer,
            freeFunc: ffi_prose_sdk_ffi_rust_future_free_rust_buffer,
            liftFunc: FfiConverterOptionTypePathBuf.lift,
            errorHandler: FfiConverterTypeClientError_lift
        )
}
    
open func loadWorkspaceInfo()async throws  -> WorkspaceInfo  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_prose_sdk_ffi_fn_method_client_load_workspace_info(
                    self.uniffiClonePointer()
                    
                )
            },
            pollFunc: ffi_prose_sdk_ffi_rust_future_poll_rust_buffer,
            completeFunc: ffi_prose_sdk_ffi_rust_future_complete_rust_buffer,
            freeFunc: ffi_prose_sdk_ffi_rust_future_free_rust_buffer,
            liftFunc: FfiConverterTypeWorkspaceInfo_lift,
            errorHandler: FfiConverterTypeClientError_lift
        )
}
    
open func previewMarkdown(markdown: String) -> String  {
    return try!  FfiConverterString.lift(try! rustCall() {
    uniffi_prose_sdk_ffi_fn_method_client_preview_markdown(self.uniffiClonePointer(),
        FfiConverterString.lower(markdown),$0
    )
})
}
    
    /**
     * Removes a contact from the roster
     */
open func removeContact(userId: UserId)async throws   {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_prose_sdk_ffi_fn_method_client_remove_contact(
                    self.uniffiClonePointer(),
                    FfiConverterTypeUserId_lower(userId)
                )
            },
            pollFunc: ffi_prose_sdk_ffi_rust_future_poll_void,
            completeFunc: ffi_prose_sdk_ffi_rust_future_complete_void,
            freeFunc: ffi_prose_sdk_ffi_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeClientError_lift
        )
}
    
    /**
     * Requests a presence subscription from `jid`. Note that happens automatically when you
     * call `add_contact`. This method can be useful though when our user needs to re-request
     * the presence subscription in case the contact hasn't reacted in a while.
     */
open func requestPresenceSub(userId: UserId)async throws   {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_prose_sdk_ffi_fn_method_client_request_presence_sub(
                    self.uniffiClonePointer(),
                    FfiConverterTypeUserId_lower(userId)
                )
            },
            pollFunc: ffi_prose_sdk_ffi_rust_future_poll_void,
            completeFunc: ffi_prose_sdk_ffi_rust_future_complete_void,
            freeFunc: ffi_prose_sdk_ffi_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeClientError_lift
        )
}
    
    /**
     * Request a slot for uploading a file to attach it to a message.
     */
open func requestUploadSlot(fileName: String, fileSize: UInt64, mediaType: Mime?)async throws  -> UploadSlot  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_prose_sdk_ffi_fn_method_client_request_upload_slot(
                    self.uniffiClonePointer(),
                    FfiConverterString.lower(fileName),FfiConverterUInt64.lower(fileSize),FfiConverterOptionTypeMime.lower(mediaType)
                )
            },
            pollFunc: ffi_prose_sdk_ffi_rust_future_poll_rust_buffer,
            completeFunc: ffi_prose_sdk_ffi_rust_future_complete_rust_buffer,
            freeFunc: ffi_prose_sdk_ffi_rust_future_free_rust_buffer,
            liftFunc: FfiConverterTypeUploadSlot_lift,
            errorHandler: FfiConverterTypeClientError_lift
        )
}
    
    /**
     * XEP-0084: User Avatar
     * https://xmpp.org/extensions/xep-0084.html
     */
open func saveAvatar(imagePath: PathBuf)async throws   {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_prose_sdk_ffi_fn_method_client_save_avatar(
                    self.uniffiClonePointer(),
                    FfiConverterTypePathBuf_lower(imagePath)
                )
            },
            pollFunc: ffi_prose_sdk_ffi_rust_future_poll_void,
            completeFunc: ffi_prose_sdk_ffi_rust_future_complete_void,
            freeFunc: ffi_prose_sdk_ffi_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeClientError_lift
        )
}
    
    /**
     * XEP-0292: vCard4 Over XMPP
     * https://xmpp.org/extensions/xep-0292.html
     */
open func saveProfile(profile: UserProfile)async throws   {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_prose_sdk_ffi_fn_method_client_save_profile(
                    self.uniffiClonePointer(),
                    FfiConverterTypeUserProfile_lower(profile)
                )
            },
            pollFunc: ffi_prose_sdk_ffi_rust_future_poll_void,
            completeFunc: ffi_prose_sdk_ffi_rust_future_complete_void,
            freeFunc: ffi_prose_sdk_ffi_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeClientError_lift
        )
}
    
    /**
     * XMPP: Instant Messaging and Presence
     * https://xmpp.org/rfcs/rfc6121.html#presence
     */
open func setAvailability(availability: Availability)async throws   {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_prose_sdk_ffi_fn_method_client_set_availability(
                    self.uniffiClonePointer(),
                    FfiConverterTypeAvailability_lower(availability)
                )
            },
            pollFunc: ffi_prose_sdk_ffi_rust_future_poll_void,
            completeFunc: ffi_prose_sdk_ffi_rust_future_complete_void,
            freeFunc: ffi_prose_sdk_ffi_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeClientError_lift
        )
}
    
    /**
     * XEP-0108: User Activity
     * https://xmpp.org/extensions/xep-0108.html
     */
open func setUserActivity(status: UserStatus?)async throws   {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_prose_sdk_ffi_fn_method_client_set_user_activity(
                    self.uniffiClonePointer(),
                    FfiConverterOptionTypeUserStatus.lower(status)
                )
            },
            pollFunc: ffi_prose_sdk_ffi_rust_future_poll_void,
            completeFunc: ffi_prose_sdk_ffi_rust_future_complete_void,
            freeFunc: ffi_prose_sdk_ffi_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeClientError_lift
        )
}
    
open func sidebarItems()async  -> [SidebarItem]  {
    return
        try!  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_prose_sdk_ffi_fn_method_client_sidebar_items(
                    self.uniffiClonePointer()
                    
                )
            },
            pollFunc: ffi_prose_sdk_ffi_rust_future_poll_rust_buffer,
            completeFunc: ffi_prose_sdk_ffi_rust_future_complete_rust_buffer,
            freeFunc: ffi_prose_sdk_ffi_rust_future_free_rust_buffer,
            liftFunc: FfiConverterSequenceTypeSidebarItem.lift,
            errorHandler: nil
            
        )
}
    
    /**
     * Creates the direct message or joins it if it already exists and returns the `BareJid`.
     * Sends invites to all participants if the group was created.
     */
open func startConversation(participants: [UserId])async throws  -> RoomId  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_prose_sdk_ffi_fn_method_client_start_conversation(
                    self.uniffiClonePointer(),
                    FfiConverterSequenceTypeUserId.lower(participants)
                )
            },
            pollFunc: ffi_prose_sdk_ffi_rust_future_poll_rust_buffer,
            completeFunc: ffi_prose_sdk_ffi_rust_future_complete_rust_buffer,
            freeFunc: ffi_prose_sdk_ffi_rust_future_free_rust_buffer,
            liftFunc: FfiConverterTypeRoomId_lift,
            errorHandler: FfiConverterTypeClientError_lift
        )
}
    
open func startObservingRooms()async throws   {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_prose_sdk_ffi_fn_method_client_start_observing_rooms(
                    self.uniffiClonePointer()
                    
                )
            },
            pollFunc: ffi_prose_sdk_ffi_rust_future_poll_void,
            completeFunc: ffi_prose_sdk_ffi_rust_future_complete_void,
            freeFunc: ffi_prose_sdk_ffi_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeClientError_lift
        )
}
    
    /**
     * Unblocks the user identified by `user_id`.
     */
open func unblockUser(userId: UserId)async throws   {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_prose_sdk_ffi_fn_method_client_unblock_user(
                    self.uniffiClonePointer(),
                    FfiConverterTypeUserId_lower(userId)
                )
            },
            pollFunc: ffi_prose_sdk_ffi_rust_future_poll_void,
            completeFunc: ffi_prose_sdk_ffi_rust_future_complete_void,
            freeFunc: ffi_prose_sdk_ffi_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeClientError_lift
        )
}
    

}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeClient: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = Client

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> Client {
        return Client(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: Client) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Client {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: Client, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeClient_lift(_ pointer: UnsafeMutableRawPointer) throws -> Client {
    return try FfiConverterTypeClient.lift(pointer)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeClient_lower(_ value: Client) -> UnsafeMutableRawPointer {
    return FfiConverterTypeClient.lower(value)
}






public protocol ClientDelegate: AnyObject, Sendable {
    
    func handleEvent(event: ClientEvent) 
    
}
open class ClientDelegateImpl: ClientDelegate, @unchecked Sendable {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    // This constructor can be used to instantiate a fake object.
    // - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    //
    // - Warning:
    //     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_prose_sdk_ffi_fn_clone_clientdelegate(self.pointer, $0) }
    }
    // No primary constructor declared for this class.

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_prose_sdk_ffi_fn_free_clientdelegate(pointer, $0) }
    }

    

    
open func handleEvent(event: ClientEvent)  {try! rustCall() {
    uniffi_prose_sdk_ffi_fn_method_clientdelegate_handle_event(self.uniffiClonePointer(),
        FfiConverterTypeClientEvent_lower(event),$0
    )
}
}
    

}
// Magic number for the Rust proxy to call using the same mechanism as every other method,
// to free the callback once it's dropped by Rust.
private let IDX_CALLBACK_FREE: Int32 = 0
// Callback return codes
private let UNIFFI_CALLBACK_SUCCESS: Int32 = 0
private let UNIFFI_CALLBACK_ERROR: Int32 = 1
private let UNIFFI_CALLBACK_UNEXPECTED_ERROR: Int32 = 2

// Put the implementation in a struct so we don't pollute the top-level namespace
fileprivate struct UniffiCallbackInterfaceClientDelegate {

    // Create the VTable using a series of closures.
    // Swift automatically converts these into C callback functions.
    //
    // This creates 1-element array, since this seems to be the only way to construct a const
    // pointer that we can pass to the Rust code.
    static let vtable: [UniffiVTableCallbackInterfaceClientDelegate] = [UniffiVTableCallbackInterfaceClientDelegate(
        handleEvent: { (
            uniffiHandle: UInt64,
            event: RustBuffer,
            uniffiOutReturn: UnsafeMutableRawPointer,
            uniffiCallStatus: UnsafeMutablePointer<RustCallStatus>
        ) in
            let makeCall = {
                () throws -> () in
                guard let uniffiObj = try? FfiConverterTypeClientDelegate.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return uniffiObj.handleEvent(
                     event: try FfiConverterTypeClientEvent_lift(event)
                )
            }

            
            let writeReturn = { () }
            uniffiTraitInterfaceCall(
                callStatus: uniffiCallStatus,
                makeCall: makeCall,
                writeReturn: writeReturn
            )
        },
        uniffiFree: { (uniffiHandle: UInt64) -> () in
            let result = try? FfiConverterTypeClientDelegate.handleMap.remove(handle: uniffiHandle)
            if result == nil {
                print("Uniffi callback interface ClientDelegate: handle missing in uniffiFree")
            }
        }
    )]
}

private func uniffiCallbackInitClientDelegate() {
    uniffi_prose_sdk_ffi_fn_init_callback_vtable_clientdelegate(UniffiCallbackInterfaceClientDelegate.vtable)
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeClientDelegate: FfiConverter {
    fileprivate static let handleMap = UniffiHandleMap<ClientDelegate>()

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = ClientDelegate

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> ClientDelegate {
        return ClientDelegateImpl(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: ClientDelegate) -> UnsafeMutableRawPointer {
        guard let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: handleMap.insert(obj: value))) else {
            fatalError("Cast to UnsafeMutableRawPointer failed")
        }
        return ptr
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ClientDelegate {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: ClientDelegate, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeClientDelegate_lift(_ pointer: UnsafeMutableRawPointer) throws -> ClientDelegate {
    return try FfiConverterTypeClientDelegate.lift(pointer)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeClientDelegate_lower(_ value: ClientDelegate) -> UnsafeMutableRawPointer {
    return FfiConverterTypeClientDelegate.lower(value)
}






public protocol HasMutableNameProtocol: AnyObject, Sendable {
    
    func setName(name: String) async throws 
    
}
open class HasMutableName: HasMutableNameProtocol, @unchecked Sendable {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    // This constructor can be used to instantiate a fake object.
    // - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    //
    // - Warning:
    //     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_prose_sdk_ffi_fn_clone_hasmutablename(self.pointer, $0) }
    }
    // No primary constructor declared for this class.

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_prose_sdk_ffi_fn_free_hasmutablename(pointer, $0) }
    }

    

    
open func setName(name: String)async throws   {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_prose_sdk_ffi_fn_method_hasmutablename_set_name(
                    self.uniffiClonePointer(),
                    FfiConverterString.lower(name)
                )
            },
            pollFunc: ffi_prose_sdk_ffi_rust_future_poll_void,
            completeFunc: ffi_prose_sdk_ffi_rust_future_complete_void,
            freeFunc: ffi_prose_sdk_ffi_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeClientError_lift
        )
}
    

}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeHasMutableName: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = HasMutableName

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> HasMutableName {
        return HasMutableName(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: HasMutableName) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> HasMutableName {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: HasMutableName, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeHasMutableName_lift(_ pointer: UnsafeMutableRawPointer) throws -> HasMutableName {
    return try FfiConverterTypeHasMutableName.lift(pointer)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeHasMutableName_lower(_ value: HasMutableName) -> UnsafeMutableRawPointer {
    return FfiConverterTypeHasMutableName.lower(value)
}






public protocol MucRoomProtocol: AnyObject, Sendable {
    
    func subject()  -> String?
    
    func setTopic(topic: String?) async throws 
    
}
open class MucRoom: MucRoomProtocol, @unchecked Sendable {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    // This constructor can be used to instantiate a fake object.
    // - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    //
    // - Warning:
    //     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_prose_sdk_ffi_fn_clone_mucroom(self.pointer, $0) }
    }
    // No primary constructor declared for this class.

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_prose_sdk_ffi_fn_free_mucroom(pointer, $0) }
    }

    

    
open func subject() -> String?  {
    return try!  FfiConverterOptionString.lift(try! rustCall() {
    uniffi_prose_sdk_ffi_fn_method_mucroom_subject(self.uniffiClonePointer(),$0
    )
})
}
    
open func setTopic(topic: String?)async throws   {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_prose_sdk_ffi_fn_method_mucroom_set_topic(
                    self.uniffiClonePointer(),
                    FfiConverterOptionString.lower(topic)
                )
            },
            pollFunc: ffi_prose_sdk_ffi_rust_future_poll_void,
            completeFunc: ffi_prose_sdk_ffi_rust_future_complete_void,
            freeFunc: ffi_prose_sdk_ffi_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeClientError_lift
        )
}
    

}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeMucRoom: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = MucRoom

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> MucRoom {
        return MucRoom(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: MucRoom) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> MucRoom {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: MucRoom, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeMucRoom_lift(_ pointer: UnsafeMutableRawPointer) throws -> MucRoom {
    return try FfiConverterTypeMucRoom.lift(pointer)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeMucRoom_lower(_ value: MucRoom) -> UnsafeMutableRawPointer {
    return FfiConverterTypeMucRoom.lower(value)
}






public protocol RoomBaseProtocol: AnyObject, Sendable {
    
    func state()  -> RoomState
    
    func id()  -> RoomId
    
    func name()  -> String
    
    func participants()  -> [ParticipantInfo]
    
    func sendMessage(request: SendMessageRequest) async throws 
    
    func updateMessage(messageId: MessageId, request: SendMessageRequest) async throws 
    
    func retractMessage(messageId: MessageId) async throws 
    
    func toggleReactionToMessage(messageId: MessageId, emoji: Emoji) async throws 
    
    func loadLatestMessages() async throws  -> MessageResultSet
    
    func loadMessagesBefore(before: MessageId) async throws  -> MessageResultSet
    
    func loadMessagesWithIds(ids: [MessageId]) async throws  -> [Message]
    
    func loadUnreadMessages() async throws  -> MessageResultSet
    
    func setUserIsComposing(isComposing: Bool) async throws 
    
    func loadComposingUsers() async throws  -> [ParticipantBasicInfo]
    
    func saveDraft(message: String?) async throws 
    
    func loadDraft() async throws  -> String?
    
    func markAsRead() async throws 
    
    func setLastReadMessage(messageId: MessageId) async throws 
    
}
open class RoomBase: RoomBaseProtocol, @unchecked Sendable {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    // This constructor can be used to instantiate a fake object.
    // - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    //
    // - Warning:
    //     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_prose_sdk_ffi_fn_clone_roombase(self.pointer, $0) }
    }
    // No primary constructor declared for this class.

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_prose_sdk_ffi_fn_free_roombase(pointer, $0) }
    }

    

    
open func state() -> RoomState  {
    return try!  FfiConverterTypeRoomState_lift(try! rustCall() {
    uniffi_prose_sdk_ffi_fn_method_roombase_state(self.uniffiClonePointer(),$0
    )
})
}
    
open func id() -> RoomId  {
    return try!  FfiConverterTypeRoomId_lift(try! rustCall() {
    uniffi_prose_sdk_ffi_fn_method_roombase_id(self.uniffiClonePointer(),$0
    )
})
}
    
open func name() -> String  {
    return try!  FfiConverterString.lift(try! rustCall() {
    uniffi_prose_sdk_ffi_fn_method_roombase_name(self.uniffiClonePointer(),$0
    )
})
}
    
open func participants() -> [ParticipantInfo]  {
    return try!  FfiConverterSequenceTypeParticipantInfo.lift(try! rustCall() {
    uniffi_prose_sdk_ffi_fn_method_roombase_participants(self.uniffiClonePointer(),$0
    )
})
}
    
open func sendMessage(request: SendMessageRequest)async throws   {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_prose_sdk_ffi_fn_method_roombase_send_message(
                    self.uniffiClonePointer(),
                    FfiConverterTypeSendMessageRequest_lower(request)
                )
            },
            pollFunc: ffi_prose_sdk_ffi_rust_future_poll_void,
            completeFunc: ffi_prose_sdk_ffi_rust_future_complete_void,
            freeFunc: ffi_prose_sdk_ffi_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeClientError_lift
        )
}
    
open func updateMessage(messageId: MessageId, request: SendMessageRequest)async throws   {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_prose_sdk_ffi_fn_method_roombase_update_message(
                    self.uniffiClonePointer(),
                    FfiConverterTypeMessageId_lower(messageId),FfiConverterTypeSendMessageRequest_lower(request)
                )
            },
            pollFunc: ffi_prose_sdk_ffi_rust_future_poll_void,
            completeFunc: ffi_prose_sdk_ffi_rust_future_complete_void,
            freeFunc: ffi_prose_sdk_ffi_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeClientError_lift
        )
}
    
open func retractMessage(messageId: MessageId)async throws   {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_prose_sdk_ffi_fn_method_roombase_retract_message(
                    self.uniffiClonePointer(),
                    FfiConverterTypeMessageId_lower(messageId)
                )
            },
            pollFunc: ffi_prose_sdk_ffi_rust_future_poll_void,
            completeFunc: ffi_prose_sdk_ffi_rust_future_complete_void,
            freeFunc: ffi_prose_sdk_ffi_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeClientError_lift
        )
}
    
open func toggleReactionToMessage(messageId: MessageId, emoji: Emoji)async throws   {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_prose_sdk_ffi_fn_method_roombase_toggle_reaction_to_message(
                    self.uniffiClonePointer(),
                    FfiConverterTypeMessageId_lower(messageId),FfiConverterTypeEmoji_lower(emoji)
                )
            },
            pollFunc: ffi_prose_sdk_ffi_rust_future_poll_void,
            completeFunc: ffi_prose_sdk_ffi_rust_future_complete_void,
            freeFunc: ffi_prose_sdk_ffi_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeClientError_lift
        )
}
    
open func loadLatestMessages()async throws  -> MessageResultSet  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_prose_sdk_ffi_fn_method_roombase_load_latest_messages(
                    self.uniffiClonePointer()
                    
                )
            },
            pollFunc: ffi_prose_sdk_ffi_rust_future_poll_rust_buffer,
            completeFunc: ffi_prose_sdk_ffi_rust_future_complete_rust_buffer,
            freeFunc: ffi_prose_sdk_ffi_rust_future_free_rust_buffer,
            liftFunc: FfiConverterTypeMessageResultSet_lift,
            errorHandler: FfiConverterTypeClientError_lift
        )
}
    
open func loadMessagesBefore(before: MessageId)async throws  -> MessageResultSet  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_prose_sdk_ffi_fn_method_roombase_load_messages_before(
                    self.uniffiClonePointer(),
                    FfiConverterTypeMessageId_lower(before)
                )
            },
            pollFunc: ffi_prose_sdk_ffi_rust_future_poll_rust_buffer,
            completeFunc: ffi_prose_sdk_ffi_rust_future_complete_rust_buffer,
            freeFunc: ffi_prose_sdk_ffi_rust_future_free_rust_buffer,
            liftFunc: FfiConverterTypeMessageResultSet_lift,
            errorHandler: FfiConverterTypeClientError_lift
        )
}
    
open func loadMessagesWithIds(ids: [MessageId])async throws  -> [Message]  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_prose_sdk_ffi_fn_method_roombase_load_messages_with_ids(
                    self.uniffiClonePointer(),
                    FfiConverterSequenceTypeMessageId.lower(ids)
                )
            },
            pollFunc: ffi_prose_sdk_ffi_rust_future_poll_rust_buffer,
            completeFunc: ffi_prose_sdk_ffi_rust_future_complete_rust_buffer,
            freeFunc: ffi_prose_sdk_ffi_rust_future_free_rust_buffer,
            liftFunc: FfiConverterSequenceTypeMessage.lift,
            errorHandler: FfiConverterTypeClientError_lift
        )
}
    
open func loadUnreadMessages()async throws  -> MessageResultSet  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_prose_sdk_ffi_fn_method_roombase_load_unread_messages(
                    self.uniffiClonePointer()
                    
                )
            },
            pollFunc: ffi_prose_sdk_ffi_rust_future_poll_rust_buffer,
            completeFunc: ffi_prose_sdk_ffi_rust_future_complete_rust_buffer,
            freeFunc: ffi_prose_sdk_ffi_rust_future_free_rust_buffer,
            liftFunc: FfiConverterTypeMessageResultSet_lift,
            errorHandler: FfiConverterTypeClientError_lift
        )
}
    
open func setUserIsComposing(isComposing: Bool)async throws   {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_prose_sdk_ffi_fn_method_roombase_set_user_is_composing(
                    self.uniffiClonePointer(),
                    FfiConverterBool.lower(isComposing)
                )
            },
            pollFunc: ffi_prose_sdk_ffi_rust_future_poll_void,
            completeFunc: ffi_prose_sdk_ffi_rust_future_complete_void,
            freeFunc: ffi_prose_sdk_ffi_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeClientError_lift
        )
}
    
open func loadComposingUsers()async throws  -> [ParticipantBasicInfo]  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_prose_sdk_ffi_fn_method_roombase_load_composing_users(
                    self.uniffiClonePointer()
                    
                )
            },
            pollFunc: ffi_prose_sdk_ffi_rust_future_poll_rust_buffer,
            completeFunc: ffi_prose_sdk_ffi_rust_future_complete_rust_buffer,
            freeFunc: ffi_prose_sdk_ffi_rust_future_free_rust_buffer,
            liftFunc: FfiConverterSequenceTypeParticipantBasicInfo.lift,
            errorHandler: FfiConverterTypeClientError_lift
        )
}
    
open func saveDraft(message: String?)async throws   {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_prose_sdk_ffi_fn_method_roombase_save_draft(
                    self.uniffiClonePointer(),
                    FfiConverterOptionString.lower(message)
                )
            },
            pollFunc: ffi_prose_sdk_ffi_rust_future_poll_void,
            completeFunc: ffi_prose_sdk_ffi_rust_future_complete_void,
            freeFunc: ffi_prose_sdk_ffi_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeClientError_lift
        )
}
    
open func loadDraft()async throws  -> String?  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_prose_sdk_ffi_fn_method_roombase_load_draft(
                    self.uniffiClonePointer()
                    
                )
            },
            pollFunc: ffi_prose_sdk_ffi_rust_future_poll_rust_buffer,
            completeFunc: ffi_prose_sdk_ffi_rust_future_complete_rust_buffer,
            freeFunc: ffi_prose_sdk_ffi_rust_future_free_rust_buffer,
            liftFunc: FfiConverterOptionString.lift,
            errorHandler: FfiConverterTypeClientError_lift
        )
}
    
open func markAsRead()async throws   {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_prose_sdk_ffi_fn_method_roombase_mark_as_read(
                    self.uniffiClonePointer()
                    
                )
            },
            pollFunc: ffi_prose_sdk_ffi_rust_future_poll_void,
            completeFunc: ffi_prose_sdk_ffi_rust_future_complete_void,
            freeFunc: ffi_prose_sdk_ffi_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeClientError_lift
        )
}
    
open func setLastReadMessage(messageId: MessageId)async throws   {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_prose_sdk_ffi_fn_method_roombase_set_last_read_message(
                    self.uniffiClonePointer(),
                    FfiConverterTypeMessageId_lower(messageId)
                )
            },
            pollFunc: ffi_prose_sdk_ffi_rust_future_poll_void,
            completeFunc: ffi_prose_sdk_ffi_rust_future_complete_void,
            freeFunc: ffi_prose_sdk_ffi_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeClientError_lift
        )
}
    

}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeRoomBase: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = RoomBase

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> RoomBase {
        return RoomBase(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: RoomBase) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> RoomBase {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: RoomBase, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeRoomBase_lift(_ pointer: UnsafeMutableRawPointer) throws -> RoomBase {
    return try FfiConverterTypeRoomBase.lift(pointer)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeRoomBase_lower(_ value: RoomBase) -> UnsafeMutableRawPointer {
    return FfiConverterTypeRoomBase.lower(value)
}






public protocol RoomDirectMessageProtocol: AnyObject, Sendable {
    
    func id()  -> RoomId
    
    func isEncryptionEnabled()  -> Bool
    
    func loadComposingUsers() async throws  -> [ParticipantBasicInfo]
    
    func loadDraft() async throws  -> String?
    
    func loadLatestMessages() async throws  -> MessageResultSet
    
    func loadMessagesBefore(before: MessageId) async throws  -> MessageResultSet
    
    func loadMessagesWithIds(ids: [MessageId]) async throws  -> [Message]
    
    func loadUnreadMessages() async throws  -> MessageResultSet
    
    func markAsRead() async throws 
    
    func name()  -> String
    
    func participants()  -> [ParticipantInfo]
    
    func retractMessage(messageId: MessageId) async throws 
    
    func saveDraft(message: String?) async throws 
    
    func sendMessage(request: SendMessageRequest) async throws 
    
    func setIsEncryptionEnabled(enabled: Bool) async 
    
    func setLastReadMessage(messageId: MessageId) async throws 
    
    func setUserIsComposing(isComposing: Bool) async throws 
    
    func state()  -> RoomState
    
    func toggleReactionToMessage(messageId: MessageId, emoji: Emoji) async throws 
    
    func updateMessage(messageId: MessageId, request: SendMessageRequest) async throws 
    
}
open class RoomDirectMessage: RoomDirectMessageProtocol, @unchecked Sendable {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    // This constructor can be used to instantiate a fake object.
    // - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    //
    // - Warning:
    //     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_prose_sdk_ffi_fn_clone_roomdirectmessage(self.pointer, $0) }
    }
    // No primary constructor declared for this class.

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_prose_sdk_ffi_fn_free_roomdirectmessage(pointer, $0) }
    }

    

    
open func id() -> RoomId  {
    return try!  FfiConverterTypeRoomId_lift(try! rustCall() {
    uniffi_prose_sdk_ffi_fn_method_roomdirectmessage_id(self.uniffiClonePointer(),$0
    )
})
}
    
open func isEncryptionEnabled() -> Bool  {
    return try!  FfiConverterBool.lift(try! rustCall() {
    uniffi_prose_sdk_ffi_fn_method_roomdirectmessage_is_encryption_enabled(self.uniffiClonePointer(),$0
    )
})
}
    
open func loadComposingUsers()async throws  -> [ParticipantBasicInfo]  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_prose_sdk_ffi_fn_method_roomdirectmessage_load_composing_users(
                    self.uniffiClonePointer()
                    
                )
            },
            pollFunc: ffi_prose_sdk_ffi_rust_future_poll_rust_buffer,
            completeFunc: ffi_prose_sdk_ffi_rust_future_complete_rust_buffer,
            freeFunc: ffi_prose_sdk_ffi_rust_future_free_rust_buffer,
            liftFunc: FfiConverterSequenceTypeParticipantBasicInfo.lift,
            errorHandler: FfiConverterTypeClientError_lift
        )
}
    
open func loadDraft()async throws  -> String?  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_prose_sdk_ffi_fn_method_roomdirectmessage_load_draft(
                    self.uniffiClonePointer()
                    
                )
            },
            pollFunc: ffi_prose_sdk_ffi_rust_future_poll_rust_buffer,
            completeFunc: ffi_prose_sdk_ffi_rust_future_complete_rust_buffer,
            freeFunc: ffi_prose_sdk_ffi_rust_future_free_rust_buffer,
            liftFunc: FfiConverterOptionString.lift,
            errorHandler: FfiConverterTypeClientError_lift
        )
}
    
open func loadLatestMessages()async throws  -> MessageResultSet  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_prose_sdk_ffi_fn_method_roomdirectmessage_load_latest_messages(
                    self.uniffiClonePointer()
                    
                )
            },
            pollFunc: ffi_prose_sdk_ffi_rust_future_poll_rust_buffer,
            completeFunc: ffi_prose_sdk_ffi_rust_future_complete_rust_buffer,
            freeFunc: ffi_prose_sdk_ffi_rust_future_free_rust_buffer,
            liftFunc: FfiConverterTypeMessageResultSet_lift,
            errorHandler: FfiConverterTypeClientError_lift
        )
}
    
open func loadMessagesBefore(before: MessageId)async throws  -> MessageResultSet  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_prose_sdk_ffi_fn_method_roomdirectmessage_load_messages_before(
                    self.uniffiClonePointer(),
                    FfiConverterTypeMessageId_lower(before)
                )
            },
            pollFunc: ffi_prose_sdk_ffi_rust_future_poll_rust_buffer,
            completeFunc: ffi_prose_sdk_ffi_rust_future_complete_rust_buffer,
            freeFunc: ffi_prose_sdk_ffi_rust_future_free_rust_buffer,
            liftFunc: FfiConverterTypeMessageResultSet_lift,
            errorHandler: FfiConverterTypeClientError_lift
        )
}
    
open func loadMessagesWithIds(ids: [MessageId])async throws  -> [Message]  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_prose_sdk_ffi_fn_method_roomdirectmessage_load_messages_with_ids(
                    self.uniffiClonePointer(),
                    FfiConverterSequenceTypeMessageId.lower(ids)
                )
            },
            pollFunc: ffi_prose_sdk_ffi_rust_future_poll_rust_buffer,
            completeFunc: ffi_prose_sdk_ffi_rust_future_complete_rust_buffer,
            freeFunc: ffi_prose_sdk_ffi_rust_future_free_rust_buffer,
            liftFunc: FfiConverterSequenceTypeMessage.lift,
            errorHandler: FfiConverterTypeClientError_lift
        )
}
    
open func loadUnreadMessages()async throws  -> MessageResultSet  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_prose_sdk_ffi_fn_method_roomdirectmessage_load_unread_messages(
                    self.uniffiClonePointer()
                    
                )
            },
            pollFunc: ffi_prose_sdk_ffi_rust_future_poll_rust_buffer,
            completeFunc: ffi_prose_sdk_ffi_rust_future_complete_rust_buffer,
            freeFunc: ffi_prose_sdk_ffi_rust_future_free_rust_buffer,
            liftFunc: FfiConverterTypeMessageResultSet_lift,
            errorHandler: FfiConverterTypeClientError_lift
        )
}
    
open func markAsRead()async throws   {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_prose_sdk_ffi_fn_method_roomdirectmessage_mark_as_read(
                    self.uniffiClonePointer()
                    
                )
            },
            pollFunc: ffi_prose_sdk_ffi_rust_future_poll_void,
            completeFunc: ffi_prose_sdk_ffi_rust_future_complete_void,
            freeFunc: ffi_prose_sdk_ffi_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeClientError_lift
        )
}
    
open func name() -> String  {
    return try!  FfiConverterString.lift(try! rustCall() {
    uniffi_prose_sdk_ffi_fn_method_roomdirectmessage_name(self.uniffiClonePointer(),$0
    )
})
}
    
open func participants() -> [ParticipantInfo]  {
    return try!  FfiConverterSequenceTypeParticipantInfo.lift(try! rustCall() {
    uniffi_prose_sdk_ffi_fn_method_roomdirectmessage_participants(self.uniffiClonePointer(),$0
    )
})
}
    
open func retractMessage(messageId: MessageId)async throws   {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_prose_sdk_ffi_fn_method_roomdirectmessage_retract_message(
                    self.uniffiClonePointer(),
                    FfiConverterTypeMessageId_lower(messageId)
                )
            },
            pollFunc: ffi_prose_sdk_ffi_rust_future_poll_void,
            completeFunc: ffi_prose_sdk_ffi_rust_future_complete_void,
            freeFunc: ffi_prose_sdk_ffi_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeClientError_lift
        )
}
    
open func saveDraft(message: String?)async throws   {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_prose_sdk_ffi_fn_method_roomdirectmessage_save_draft(
                    self.uniffiClonePointer(),
                    FfiConverterOptionString.lower(message)
                )
            },
            pollFunc: ffi_prose_sdk_ffi_rust_future_poll_void,
            completeFunc: ffi_prose_sdk_ffi_rust_future_complete_void,
            freeFunc: ffi_prose_sdk_ffi_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeClientError_lift
        )
}
    
open func sendMessage(request: SendMessageRequest)async throws   {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_prose_sdk_ffi_fn_method_roomdirectmessage_send_message(
                    self.uniffiClonePointer(),
                    FfiConverterTypeSendMessageRequest_lower(request)
                )
            },
            pollFunc: ffi_prose_sdk_ffi_rust_future_poll_void,
            completeFunc: ffi_prose_sdk_ffi_rust_future_complete_void,
            freeFunc: ffi_prose_sdk_ffi_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeClientError_lift
        )
}
    
open func setIsEncryptionEnabled(enabled: Bool)async   {
    return
        try!  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_prose_sdk_ffi_fn_method_roomdirectmessage_set_is_encryption_enabled(
                    self.uniffiClonePointer(),
                    FfiConverterBool.lower(enabled)
                )
            },
            pollFunc: ffi_prose_sdk_ffi_rust_future_poll_void,
            completeFunc: ffi_prose_sdk_ffi_rust_future_complete_void,
            freeFunc: ffi_prose_sdk_ffi_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: nil
            
        )
}
    
open func setLastReadMessage(messageId: MessageId)async throws   {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_prose_sdk_ffi_fn_method_roomdirectmessage_set_last_read_message(
                    self.uniffiClonePointer(),
                    FfiConverterTypeMessageId_lower(messageId)
                )
            },
            pollFunc: ffi_prose_sdk_ffi_rust_future_poll_void,
            completeFunc: ffi_prose_sdk_ffi_rust_future_complete_void,
            freeFunc: ffi_prose_sdk_ffi_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeClientError_lift
        )
}
    
open func setUserIsComposing(isComposing: Bool)async throws   {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_prose_sdk_ffi_fn_method_roomdirectmessage_set_user_is_composing(
                    self.uniffiClonePointer(),
                    FfiConverterBool.lower(isComposing)
                )
            },
            pollFunc: ffi_prose_sdk_ffi_rust_future_poll_void,
            completeFunc: ffi_prose_sdk_ffi_rust_future_complete_void,
            freeFunc: ffi_prose_sdk_ffi_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeClientError_lift
        )
}
    
open func state() -> RoomState  {
    return try!  FfiConverterTypeRoomState_lift(try! rustCall() {
    uniffi_prose_sdk_ffi_fn_method_roomdirectmessage_state(self.uniffiClonePointer(),$0
    )
})
}
    
open func toggleReactionToMessage(messageId: MessageId, emoji: Emoji)async throws   {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_prose_sdk_ffi_fn_method_roomdirectmessage_toggle_reaction_to_message(
                    self.uniffiClonePointer(),
                    FfiConverterTypeMessageId_lower(messageId),FfiConverterTypeEmoji_lower(emoji)
                )
            },
            pollFunc: ffi_prose_sdk_ffi_rust_future_poll_void,
            completeFunc: ffi_prose_sdk_ffi_rust_future_complete_void,
            freeFunc: ffi_prose_sdk_ffi_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeClientError_lift
        )
}
    
open func updateMessage(messageId: MessageId, request: SendMessageRequest)async throws   {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_prose_sdk_ffi_fn_method_roomdirectmessage_update_message(
                    self.uniffiClonePointer(),
                    FfiConverterTypeMessageId_lower(messageId),FfiConverterTypeSendMessageRequest_lower(request)
                )
            },
            pollFunc: ffi_prose_sdk_ffi_rust_future_poll_void,
            completeFunc: ffi_prose_sdk_ffi_rust_future_complete_void,
            freeFunc: ffi_prose_sdk_ffi_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeClientError_lift
        )
}
    

}
extension RoomDirectMessage: RoomBaseProtocol {}



#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeRoomDirectMessage: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = RoomDirectMessage

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> RoomDirectMessage {
        return RoomDirectMessage(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: RoomDirectMessage) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> RoomDirectMessage {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: RoomDirectMessage, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeRoomDirectMessage_lift(_ pointer: UnsafeMutableRawPointer) throws -> RoomDirectMessage {
    return try FfiConverterTypeRoomDirectMessage.lift(pointer)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeRoomDirectMessage_lower(_ value: RoomDirectMessage) -> UnsafeMutableRawPointer {
    return FfiConverterTypeRoomDirectMessage.lower(value)
}






public protocol RoomGenericProtocol: AnyObject, Sendable {
    
    func id()  -> RoomId
    
    func loadComposingUsers() async throws  -> [ParticipantBasicInfo]
    
    func loadDraft() async throws  -> String?
    
    func loadLatestMessages() async throws  -> MessageResultSet
    
    func loadMessagesBefore(before: MessageId) async throws  -> MessageResultSet
    
    func loadMessagesWithIds(ids: [MessageId]) async throws  -> [Message]
    
    func loadUnreadMessages() async throws  -> MessageResultSet
    
    func markAsRead() async throws 
    
    func name()  -> String
    
    func participants()  -> [ParticipantInfo]
    
    func retractMessage(messageId: MessageId) async throws 
    
    func saveDraft(message: String?) async throws 
    
    func sendMessage(request: SendMessageRequest) async throws 
    
    func setLastReadMessage(messageId: MessageId) async throws 
    
    func setName(name: String) async throws 
    
    func setTopic(topic: String?) async throws 
    
    func setUserIsComposing(isComposing: Bool) async throws 
    
    func state()  -> RoomState
    
    func subject()  -> String?
    
    func toggleReactionToMessage(messageId: MessageId, emoji: Emoji) async throws 
    
    func updateMessage(messageId: MessageId, request: SendMessageRequest) async throws 
    
}
open class RoomGeneric: RoomGenericProtocol, @unchecked Sendable {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    // This constructor can be used to instantiate a fake object.
    // - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    //
    // - Warning:
    //     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_prose_sdk_ffi_fn_clone_roomgeneric(self.pointer, $0) }
    }
    // No primary constructor declared for this class.

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_prose_sdk_ffi_fn_free_roomgeneric(pointer, $0) }
    }

    

    
open func id() -> RoomId  {
    return try!  FfiConverterTypeRoomId_lift(try! rustCall() {
    uniffi_prose_sdk_ffi_fn_method_roomgeneric_id(self.uniffiClonePointer(),$0
    )
})
}
    
open func loadComposingUsers()async throws  -> [ParticipantBasicInfo]  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_prose_sdk_ffi_fn_method_roomgeneric_load_composing_users(
                    self.uniffiClonePointer()
                    
                )
            },
            pollFunc: ffi_prose_sdk_ffi_rust_future_poll_rust_buffer,
            completeFunc: ffi_prose_sdk_ffi_rust_future_complete_rust_buffer,
            freeFunc: ffi_prose_sdk_ffi_rust_future_free_rust_buffer,
            liftFunc: FfiConverterSequenceTypeParticipantBasicInfo.lift,
            errorHandler: FfiConverterTypeClientError_lift
        )
}
    
open func loadDraft()async throws  -> String?  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_prose_sdk_ffi_fn_method_roomgeneric_load_draft(
                    self.uniffiClonePointer()
                    
                )
            },
            pollFunc: ffi_prose_sdk_ffi_rust_future_poll_rust_buffer,
            completeFunc: ffi_prose_sdk_ffi_rust_future_complete_rust_buffer,
            freeFunc: ffi_prose_sdk_ffi_rust_future_free_rust_buffer,
            liftFunc: FfiConverterOptionString.lift,
            errorHandler: FfiConverterTypeClientError_lift
        )
}
    
open func loadLatestMessages()async throws  -> MessageResultSet  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_prose_sdk_ffi_fn_method_roomgeneric_load_latest_messages(
                    self.uniffiClonePointer()
                    
                )
            },
            pollFunc: ffi_prose_sdk_ffi_rust_future_poll_rust_buffer,
            completeFunc: ffi_prose_sdk_ffi_rust_future_complete_rust_buffer,
            freeFunc: ffi_prose_sdk_ffi_rust_future_free_rust_buffer,
            liftFunc: FfiConverterTypeMessageResultSet_lift,
            errorHandler: FfiConverterTypeClientError_lift
        )
}
    
open func loadMessagesBefore(before: MessageId)async throws  -> MessageResultSet  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_prose_sdk_ffi_fn_method_roomgeneric_load_messages_before(
                    self.uniffiClonePointer(),
                    FfiConverterTypeMessageId_lower(before)
                )
            },
            pollFunc: ffi_prose_sdk_ffi_rust_future_poll_rust_buffer,
            completeFunc: ffi_prose_sdk_ffi_rust_future_complete_rust_buffer,
            freeFunc: ffi_prose_sdk_ffi_rust_future_free_rust_buffer,
            liftFunc: FfiConverterTypeMessageResultSet_lift,
            errorHandler: FfiConverterTypeClientError_lift
        )
}
    
open func loadMessagesWithIds(ids: [MessageId])async throws  -> [Message]  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_prose_sdk_ffi_fn_method_roomgeneric_load_messages_with_ids(
                    self.uniffiClonePointer(),
                    FfiConverterSequenceTypeMessageId.lower(ids)
                )
            },
            pollFunc: ffi_prose_sdk_ffi_rust_future_poll_rust_buffer,
            completeFunc: ffi_prose_sdk_ffi_rust_future_complete_rust_buffer,
            freeFunc: ffi_prose_sdk_ffi_rust_future_free_rust_buffer,
            liftFunc: FfiConverterSequenceTypeMessage.lift,
            errorHandler: FfiConverterTypeClientError_lift
        )
}
    
open func loadUnreadMessages()async throws  -> MessageResultSet  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_prose_sdk_ffi_fn_method_roomgeneric_load_unread_messages(
                    self.uniffiClonePointer()
                    
                )
            },
            pollFunc: ffi_prose_sdk_ffi_rust_future_poll_rust_buffer,
            completeFunc: ffi_prose_sdk_ffi_rust_future_complete_rust_buffer,
            freeFunc: ffi_prose_sdk_ffi_rust_future_free_rust_buffer,
            liftFunc: FfiConverterTypeMessageResultSet_lift,
            errorHandler: FfiConverterTypeClientError_lift
        )
}
    
open func markAsRead()async throws   {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_prose_sdk_ffi_fn_method_roomgeneric_mark_as_read(
                    self.uniffiClonePointer()
                    
                )
            },
            pollFunc: ffi_prose_sdk_ffi_rust_future_poll_void,
            completeFunc: ffi_prose_sdk_ffi_rust_future_complete_void,
            freeFunc: ffi_prose_sdk_ffi_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeClientError_lift
        )
}
    
open func name() -> String  {
    return try!  FfiConverterString.lift(try! rustCall() {
    uniffi_prose_sdk_ffi_fn_method_roomgeneric_name(self.uniffiClonePointer(),$0
    )
})
}
    
open func participants() -> [ParticipantInfo]  {
    return try!  FfiConverterSequenceTypeParticipantInfo.lift(try! rustCall() {
    uniffi_prose_sdk_ffi_fn_method_roomgeneric_participants(self.uniffiClonePointer(),$0
    )
})
}
    
open func retractMessage(messageId: MessageId)async throws   {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_prose_sdk_ffi_fn_method_roomgeneric_retract_message(
                    self.uniffiClonePointer(),
                    FfiConverterTypeMessageId_lower(messageId)
                )
            },
            pollFunc: ffi_prose_sdk_ffi_rust_future_poll_void,
            completeFunc: ffi_prose_sdk_ffi_rust_future_complete_void,
            freeFunc: ffi_prose_sdk_ffi_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeClientError_lift
        )
}
    
open func saveDraft(message: String?)async throws   {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_prose_sdk_ffi_fn_method_roomgeneric_save_draft(
                    self.uniffiClonePointer(),
                    FfiConverterOptionString.lower(message)
                )
            },
            pollFunc: ffi_prose_sdk_ffi_rust_future_poll_void,
            completeFunc: ffi_prose_sdk_ffi_rust_future_complete_void,
            freeFunc: ffi_prose_sdk_ffi_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeClientError_lift
        )
}
    
open func sendMessage(request: SendMessageRequest)async throws   {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_prose_sdk_ffi_fn_method_roomgeneric_send_message(
                    self.uniffiClonePointer(),
                    FfiConverterTypeSendMessageRequest_lower(request)
                )
            },
            pollFunc: ffi_prose_sdk_ffi_rust_future_poll_void,
            completeFunc: ffi_prose_sdk_ffi_rust_future_complete_void,
            freeFunc: ffi_prose_sdk_ffi_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeClientError_lift
        )
}
    
open func setLastReadMessage(messageId: MessageId)async throws   {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_prose_sdk_ffi_fn_method_roomgeneric_set_last_read_message(
                    self.uniffiClonePointer(),
                    FfiConverterTypeMessageId_lower(messageId)
                )
            },
            pollFunc: ffi_prose_sdk_ffi_rust_future_poll_void,
            completeFunc: ffi_prose_sdk_ffi_rust_future_complete_void,
            freeFunc: ffi_prose_sdk_ffi_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeClientError_lift
        )
}
    
open func setName(name: String)async throws   {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_prose_sdk_ffi_fn_method_roomgeneric_set_name(
                    self.uniffiClonePointer(),
                    FfiConverterString.lower(name)
                )
            },
            pollFunc: ffi_prose_sdk_ffi_rust_future_poll_void,
            completeFunc: ffi_prose_sdk_ffi_rust_future_complete_void,
            freeFunc: ffi_prose_sdk_ffi_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeClientError_lift
        )
}
    
open func setTopic(topic: String?)async throws   {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_prose_sdk_ffi_fn_method_roomgeneric_set_topic(
                    self.uniffiClonePointer(),
                    FfiConverterOptionString.lower(topic)
                )
            },
            pollFunc: ffi_prose_sdk_ffi_rust_future_poll_void,
            completeFunc: ffi_prose_sdk_ffi_rust_future_complete_void,
            freeFunc: ffi_prose_sdk_ffi_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeClientError_lift
        )
}
    
open func setUserIsComposing(isComposing: Bool)async throws   {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_prose_sdk_ffi_fn_method_roomgeneric_set_user_is_composing(
                    self.uniffiClonePointer(),
                    FfiConverterBool.lower(isComposing)
                )
            },
            pollFunc: ffi_prose_sdk_ffi_rust_future_poll_void,
            completeFunc: ffi_prose_sdk_ffi_rust_future_complete_void,
            freeFunc: ffi_prose_sdk_ffi_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeClientError_lift
        )
}
    
open func state() -> RoomState  {
    return try!  FfiConverterTypeRoomState_lift(try! rustCall() {
    uniffi_prose_sdk_ffi_fn_method_roomgeneric_state(self.uniffiClonePointer(),$0
    )
})
}
    
open func subject() -> String?  {
    return try!  FfiConverterOptionString.lift(try! rustCall() {
    uniffi_prose_sdk_ffi_fn_method_roomgeneric_subject(self.uniffiClonePointer(),$0
    )
})
}
    
open func toggleReactionToMessage(messageId: MessageId, emoji: Emoji)async throws   {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_prose_sdk_ffi_fn_method_roomgeneric_toggle_reaction_to_message(
                    self.uniffiClonePointer(),
                    FfiConverterTypeMessageId_lower(messageId),FfiConverterTypeEmoji_lower(emoji)
                )
            },
            pollFunc: ffi_prose_sdk_ffi_rust_future_poll_void,
            completeFunc: ffi_prose_sdk_ffi_rust_future_complete_void,
            freeFunc: ffi_prose_sdk_ffi_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeClientError_lift
        )
}
    
open func updateMessage(messageId: MessageId, request: SendMessageRequest)async throws   {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_prose_sdk_ffi_fn_method_roomgeneric_update_message(
                    self.uniffiClonePointer(),
                    FfiConverterTypeMessageId_lower(messageId),FfiConverterTypeSendMessageRequest_lower(request)
                )
            },
            pollFunc: ffi_prose_sdk_ffi_rust_future_poll_void,
            completeFunc: ffi_prose_sdk_ffi_rust_future_complete_void,
            freeFunc: ffi_prose_sdk_ffi_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeClientError_lift
        )
}
    

}
extension RoomGeneric: HasMutableNameProtocol {}

extension RoomGeneric: MucRoomProtocol {}

extension RoomGeneric: RoomBaseProtocol {}



#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeRoomGeneric: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = RoomGeneric

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> RoomGeneric {
        return RoomGeneric(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: RoomGeneric) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> RoomGeneric {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: RoomGeneric, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeRoomGeneric_lift(_ pointer: UnsafeMutableRawPointer) throws -> RoomGeneric {
    return try FfiConverterTypeRoomGeneric.lift(pointer)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeRoomGeneric_lower(_ value: RoomGeneric) -> UnsafeMutableRawPointer {
    return FfiConverterTypeRoomGeneric.lower(value)
}






public protocol RoomGroupProtocol: AnyObject, Sendable {
    
    func id()  -> RoomId
    
    func loadComposingUsers() async throws  -> [ParticipantBasicInfo]
    
    func loadDraft() async throws  -> String?
    
    func loadLatestMessages() async throws  -> MessageResultSet
    
    func loadMessagesBefore(before: MessageId) async throws  -> MessageResultSet
    
    func loadMessagesWithIds(ids: [MessageId]) async throws  -> [Message]
    
    func loadUnreadMessages() async throws  -> MessageResultSet
    
    func markAsRead() async throws 
    
    func name()  -> String
    
    func participants()  -> [ParticipantInfo]
    
    func resendInvitesToMembers() async throws 
    
    func retractMessage(messageId: MessageId) async throws 
    
    func saveDraft(message: String?) async throws 
    
    func sendMessage(request: SendMessageRequest) async throws 
    
    func setLastReadMessage(messageId: MessageId) async throws 
    
    func setTopic(topic: String?) async throws 
    
    func setUserIsComposing(isComposing: Bool) async throws 
    
    func state()  -> RoomState
    
    func subject()  -> String?
    
    func toggleReactionToMessage(messageId: MessageId, emoji: Emoji) async throws 
    
    func updateMessage(messageId: MessageId, request: SendMessageRequest) async throws 
    
}
open class RoomGroup: RoomGroupProtocol, @unchecked Sendable {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    // This constructor can be used to instantiate a fake object.
    // - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    //
    // - Warning:
    //     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_prose_sdk_ffi_fn_clone_roomgroup(self.pointer, $0) }
    }
    // No primary constructor declared for this class.

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_prose_sdk_ffi_fn_free_roomgroup(pointer, $0) }
    }

    

    
open func id() -> RoomId  {
    return try!  FfiConverterTypeRoomId_lift(try! rustCall() {
    uniffi_prose_sdk_ffi_fn_method_roomgroup_id(self.uniffiClonePointer(),$0
    )
})
}
    
open func loadComposingUsers()async throws  -> [ParticipantBasicInfo]  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_prose_sdk_ffi_fn_method_roomgroup_load_composing_users(
                    self.uniffiClonePointer()
                    
                )
            },
            pollFunc: ffi_prose_sdk_ffi_rust_future_poll_rust_buffer,
            completeFunc: ffi_prose_sdk_ffi_rust_future_complete_rust_buffer,
            freeFunc: ffi_prose_sdk_ffi_rust_future_free_rust_buffer,
            liftFunc: FfiConverterSequenceTypeParticipantBasicInfo.lift,
            errorHandler: FfiConverterTypeClientError_lift
        )
}
    
open func loadDraft()async throws  -> String?  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_prose_sdk_ffi_fn_method_roomgroup_load_draft(
                    self.uniffiClonePointer()
                    
                )
            },
            pollFunc: ffi_prose_sdk_ffi_rust_future_poll_rust_buffer,
            completeFunc: ffi_prose_sdk_ffi_rust_future_complete_rust_buffer,
            freeFunc: ffi_prose_sdk_ffi_rust_future_free_rust_buffer,
            liftFunc: FfiConverterOptionString.lift,
            errorHandler: FfiConverterTypeClientError_lift
        )
}
    
open func loadLatestMessages()async throws  -> MessageResultSet  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_prose_sdk_ffi_fn_method_roomgroup_load_latest_messages(
                    self.uniffiClonePointer()
                    
                )
            },
            pollFunc: ffi_prose_sdk_ffi_rust_future_poll_rust_buffer,
            completeFunc: ffi_prose_sdk_ffi_rust_future_complete_rust_buffer,
            freeFunc: ffi_prose_sdk_ffi_rust_future_free_rust_buffer,
            liftFunc: FfiConverterTypeMessageResultSet_lift,
            errorHandler: FfiConverterTypeClientError_lift
        )
}
    
open func loadMessagesBefore(before: MessageId)async throws  -> MessageResultSet  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_prose_sdk_ffi_fn_method_roomgroup_load_messages_before(
                    self.uniffiClonePointer(),
                    FfiConverterTypeMessageId_lower(before)
                )
            },
            pollFunc: ffi_prose_sdk_ffi_rust_future_poll_rust_buffer,
            completeFunc: ffi_prose_sdk_ffi_rust_future_complete_rust_buffer,
            freeFunc: ffi_prose_sdk_ffi_rust_future_free_rust_buffer,
            liftFunc: FfiConverterTypeMessageResultSet_lift,
            errorHandler: FfiConverterTypeClientError_lift
        )
}
    
open func loadMessagesWithIds(ids: [MessageId])async throws  -> [Message]  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_prose_sdk_ffi_fn_method_roomgroup_load_messages_with_ids(
                    self.uniffiClonePointer(),
                    FfiConverterSequenceTypeMessageId.lower(ids)
                )
            },
            pollFunc: ffi_prose_sdk_ffi_rust_future_poll_rust_buffer,
            completeFunc: ffi_prose_sdk_ffi_rust_future_complete_rust_buffer,
            freeFunc: ffi_prose_sdk_ffi_rust_future_free_rust_buffer,
            liftFunc: FfiConverterSequenceTypeMessage.lift,
            errorHandler: FfiConverterTypeClientError_lift
        )
}
    
open func loadUnreadMessages()async throws  -> MessageResultSet  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_prose_sdk_ffi_fn_method_roomgroup_load_unread_messages(
                    self.uniffiClonePointer()
                    
                )
            },
            pollFunc: ffi_prose_sdk_ffi_rust_future_poll_rust_buffer,
            completeFunc: ffi_prose_sdk_ffi_rust_future_complete_rust_buffer,
            freeFunc: ffi_prose_sdk_ffi_rust_future_free_rust_buffer,
            liftFunc: FfiConverterTypeMessageResultSet_lift,
            errorHandler: FfiConverterTypeClientError_lift
        )
}
    
open func markAsRead()async throws   {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_prose_sdk_ffi_fn_method_roomgroup_mark_as_read(
                    self.uniffiClonePointer()
                    
                )
            },
            pollFunc: ffi_prose_sdk_ffi_rust_future_poll_void,
            completeFunc: ffi_prose_sdk_ffi_rust_future_complete_void,
            freeFunc: ffi_prose_sdk_ffi_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeClientError_lift
        )
}
    
open func name() -> String  {
    return try!  FfiConverterString.lift(try! rustCall() {
    uniffi_prose_sdk_ffi_fn_method_roomgroup_name(self.uniffiClonePointer(),$0
    )
})
}
    
open func participants() -> [ParticipantInfo]  {
    return try!  FfiConverterSequenceTypeParticipantInfo.lift(try! rustCall() {
    uniffi_prose_sdk_ffi_fn_method_roomgroup_participants(self.uniffiClonePointer(),$0
    )
})
}
    
open func resendInvitesToMembers()async throws   {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_prose_sdk_ffi_fn_method_roomgroup_resend_invites_to_members(
                    self.uniffiClonePointer()
                    
                )
            },
            pollFunc: ffi_prose_sdk_ffi_rust_future_poll_void,
            completeFunc: ffi_prose_sdk_ffi_rust_future_complete_void,
            freeFunc: ffi_prose_sdk_ffi_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeClientError_lift
        )
}
    
open func retractMessage(messageId: MessageId)async throws   {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_prose_sdk_ffi_fn_method_roomgroup_retract_message(
                    self.uniffiClonePointer(),
                    FfiConverterTypeMessageId_lower(messageId)
                )
            },
            pollFunc: ffi_prose_sdk_ffi_rust_future_poll_void,
            completeFunc: ffi_prose_sdk_ffi_rust_future_complete_void,
            freeFunc: ffi_prose_sdk_ffi_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeClientError_lift
        )
}
    
open func saveDraft(message: String?)async throws   {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_prose_sdk_ffi_fn_method_roomgroup_save_draft(
                    self.uniffiClonePointer(),
                    FfiConverterOptionString.lower(message)
                )
            },
            pollFunc: ffi_prose_sdk_ffi_rust_future_poll_void,
            completeFunc: ffi_prose_sdk_ffi_rust_future_complete_void,
            freeFunc: ffi_prose_sdk_ffi_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeClientError_lift
        )
}
    
open func sendMessage(request: SendMessageRequest)async throws   {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_prose_sdk_ffi_fn_method_roomgroup_send_message(
                    self.uniffiClonePointer(),
                    FfiConverterTypeSendMessageRequest_lower(request)
                )
            },
            pollFunc: ffi_prose_sdk_ffi_rust_future_poll_void,
            completeFunc: ffi_prose_sdk_ffi_rust_future_complete_void,
            freeFunc: ffi_prose_sdk_ffi_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeClientError_lift
        )
}
    
open func setLastReadMessage(messageId: MessageId)async throws   {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_prose_sdk_ffi_fn_method_roomgroup_set_last_read_message(
                    self.uniffiClonePointer(),
                    FfiConverterTypeMessageId_lower(messageId)
                )
            },
            pollFunc: ffi_prose_sdk_ffi_rust_future_poll_void,
            completeFunc: ffi_prose_sdk_ffi_rust_future_complete_void,
            freeFunc: ffi_prose_sdk_ffi_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeClientError_lift
        )
}
    
open func setTopic(topic: String?)async throws   {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_prose_sdk_ffi_fn_method_roomgroup_set_topic(
                    self.uniffiClonePointer(),
                    FfiConverterOptionString.lower(topic)
                )
            },
            pollFunc: ffi_prose_sdk_ffi_rust_future_poll_void,
            completeFunc: ffi_prose_sdk_ffi_rust_future_complete_void,
            freeFunc: ffi_prose_sdk_ffi_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeClientError_lift
        )
}
    
open func setUserIsComposing(isComposing: Bool)async throws   {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_prose_sdk_ffi_fn_method_roomgroup_set_user_is_composing(
                    self.uniffiClonePointer(),
                    FfiConverterBool.lower(isComposing)
                )
            },
            pollFunc: ffi_prose_sdk_ffi_rust_future_poll_void,
            completeFunc: ffi_prose_sdk_ffi_rust_future_complete_void,
            freeFunc: ffi_prose_sdk_ffi_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeClientError_lift
        )
}
    
open func state() -> RoomState  {
    return try!  FfiConverterTypeRoomState_lift(try! rustCall() {
    uniffi_prose_sdk_ffi_fn_method_roomgroup_state(self.uniffiClonePointer(),$0
    )
})
}
    
open func subject() -> String?  {
    return try!  FfiConverterOptionString.lift(try! rustCall() {
    uniffi_prose_sdk_ffi_fn_method_roomgroup_subject(self.uniffiClonePointer(),$0
    )
})
}
    
open func toggleReactionToMessage(messageId: MessageId, emoji: Emoji)async throws   {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_prose_sdk_ffi_fn_method_roomgroup_toggle_reaction_to_message(
                    self.uniffiClonePointer(),
                    FfiConverterTypeMessageId_lower(messageId),FfiConverterTypeEmoji_lower(emoji)
                )
            },
            pollFunc: ffi_prose_sdk_ffi_rust_future_poll_void,
            completeFunc: ffi_prose_sdk_ffi_rust_future_complete_void,
            freeFunc: ffi_prose_sdk_ffi_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeClientError_lift
        )
}
    
open func updateMessage(messageId: MessageId, request: SendMessageRequest)async throws   {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_prose_sdk_ffi_fn_method_roomgroup_update_message(
                    self.uniffiClonePointer(),
                    FfiConverterTypeMessageId_lower(messageId),FfiConverterTypeSendMessageRequest_lower(request)
                )
            },
            pollFunc: ffi_prose_sdk_ffi_rust_future_poll_void,
            completeFunc: ffi_prose_sdk_ffi_rust_future_complete_void,
            freeFunc: ffi_prose_sdk_ffi_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeClientError_lift
        )
}
    

}
extension RoomGroup: MucRoomProtocol {}

extension RoomGroup: RoomBaseProtocol {}



#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeRoomGroup: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = RoomGroup

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> RoomGroup {
        return RoomGroup(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: RoomGroup) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> RoomGroup {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: RoomGroup, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeRoomGroup_lift(_ pointer: UnsafeMutableRawPointer) throws -> RoomGroup {
    return try FfiConverterTypeRoomGroup.lift(pointer)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeRoomGroup_lower(_ value: RoomGroup) -> UnsafeMutableRawPointer {
    return FfiConverterTypeRoomGroup.lower(value)
}






public protocol RoomPrivateChannelProtocol: AnyObject, Sendable {
    
    func id()  -> RoomId
    
    func inviteUsers(users: [UserId]) async throws 
    
    func loadComposingUsers() async throws  -> [ParticipantBasicInfo]
    
    func loadDraft() async throws  -> String?
    
    func loadLatestMessages() async throws  -> MessageResultSet
    
    func loadMessagesBefore(before: MessageId) async throws  -> MessageResultSet
    
    func loadMessagesWithIds(ids: [MessageId]) async throws  -> [Message]
    
    func loadUnreadMessages() async throws  -> MessageResultSet
    
    func markAsRead() async throws 
    
    func name()  -> String
    
    func participants()  -> [ParticipantInfo]
    
    func retractMessage(messageId: MessageId) async throws 
    
    func saveDraft(message: String?) async throws 
    
    func sendMessage(request: SendMessageRequest) async throws 
    
    func setLastReadMessage(messageId: MessageId) async throws 
    
    func setName(name: String) async throws 
    
    func setTopic(topic: String?) async throws 
    
    func setUserIsComposing(isComposing: Bool) async throws 
    
    func state()  -> RoomState
    
    func subject()  -> String?
    
    func toggleReactionToMessage(messageId: MessageId, emoji: Emoji) async throws 
    
    func updateMessage(messageId: MessageId, request: SendMessageRequest) async throws 
    
}
open class RoomPrivateChannel: RoomPrivateChannelProtocol, @unchecked Sendable {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    // This constructor can be used to instantiate a fake object.
    // - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    //
    // - Warning:
    //     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_prose_sdk_ffi_fn_clone_roomprivatechannel(self.pointer, $0) }
    }
    // No primary constructor declared for this class.

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_prose_sdk_ffi_fn_free_roomprivatechannel(pointer, $0) }
    }

    

    
open func id() -> RoomId  {
    return try!  FfiConverterTypeRoomId_lift(try! rustCall() {
    uniffi_prose_sdk_ffi_fn_method_roomprivatechannel_id(self.uniffiClonePointer(),$0
    )
})
}
    
open func inviteUsers(users: [UserId])async throws   {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_prose_sdk_ffi_fn_method_roomprivatechannel_invite_users(
                    self.uniffiClonePointer(),
                    FfiConverterSequenceTypeUserId.lower(users)
                )
            },
            pollFunc: ffi_prose_sdk_ffi_rust_future_poll_void,
            completeFunc: ffi_prose_sdk_ffi_rust_future_complete_void,
            freeFunc: ffi_prose_sdk_ffi_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeClientError_lift
        )
}
    
open func loadComposingUsers()async throws  -> [ParticipantBasicInfo]  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_prose_sdk_ffi_fn_method_roomprivatechannel_load_composing_users(
                    self.uniffiClonePointer()
                    
                )
            },
            pollFunc: ffi_prose_sdk_ffi_rust_future_poll_rust_buffer,
            completeFunc: ffi_prose_sdk_ffi_rust_future_complete_rust_buffer,
            freeFunc: ffi_prose_sdk_ffi_rust_future_free_rust_buffer,
            liftFunc: FfiConverterSequenceTypeParticipantBasicInfo.lift,
            errorHandler: FfiConverterTypeClientError_lift
        )
}
    
open func loadDraft()async throws  -> String?  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_prose_sdk_ffi_fn_method_roomprivatechannel_load_draft(
                    self.uniffiClonePointer()
                    
                )
            },
            pollFunc: ffi_prose_sdk_ffi_rust_future_poll_rust_buffer,
            completeFunc: ffi_prose_sdk_ffi_rust_future_complete_rust_buffer,
            freeFunc: ffi_prose_sdk_ffi_rust_future_free_rust_buffer,
            liftFunc: FfiConverterOptionString.lift,
            errorHandler: FfiConverterTypeClientError_lift
        )
}
    
open func loadLatestMessages()async throws  -> MessageResultSet  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_prose_sdk_ffi_fn_method_roomprivatechannel_load_latest_messages(
                    self.uniffiClonePointer()
                    
                )
            },
            pollFunc: ffi_prose_sdk_ffi_rust_future_poll_rust_buffer,
            completeFunc: ffi_prose_sdk_ffi_rust_future_complete_rust_buffer,
            freeFunc: ffi_prose_sdk_ffi_rust_future_free_rust_buffer,
            liftFunc: FfiConverterTypeMessageResultSet_lift,
            errorHandler: FfiConverterTypeClientError_lift
        )
}
    
open func loadMessagesBefore(before: MessageId)async throws  -> MessageResultSet  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_prose_sdk_ffi_fn_method_roomprivatechannel_load_messages_before(
                    self.uniffiClonePointer(),
                    FfiConverterTypeMessageId_lower(before)
                )
            },
            pollFunc: ffi_prose_sdk_ffi_rust_future_poll_rust_buffer,
            completeFunc: ffi_prose_sdk_ffi_rust_future_complete_rust_buffer,
            freeFunc: ffi_prose_sdk_ffi_rust_future_free_rust_buffer,
            liftFunc: FfiConverterTypeMessageResultSet_lift,
            errorHandler: FfiConverterTypeClientError_lift
        )
}
    
open func loadMessagesWithIds(ids: [MessageId])async throws  -> [Message]  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_prose_sdk_ffi_fn_method_roomprivatechannel_load_messages_with_ids(
                    self.uniffiClonePointer(),
                    FfiConverterSequenceTypeMessageId.lower(ids)
                )
            },
            pollFunc: ffi_prose_sdk_ffi_rust_future_poll_rust_buffer,
            completeFunc: ffi_prose_sdk_ffi_rust_future_complete_rust_buffer,
            freeFunc: ffi_prose_sdk_ffi_rust_future_free_rust_buffer,
            liftFunc: FfiConverterSequenceTypeMessage.lift,
            errorHandler: FfiConverterTypeClientError_lift
        )
}
    
open func loadUnreadMessages()async throws  -> MessageResultSet  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_prose_sdk_ffi_fn_method_roomprivatechannel_load_unread_messages(
                    self.uniffiClonePointer()
                    
                )
            },
            pollFunc: ffi_prose_sdk_ffi_rust_future_poll_rust_buffer,
            completeFunc: ffi_prose_sdk_ffi_rust_future_complete_rust_buffer,
            freeFunc: ffi_prose_sdk_ffi_rust_future_free_rust_buffer,
            liftFunc: FfiConverterTypeMessageResultSet_lift,
            errorHandler: FfiConverterTypeClientError_lift
        )
}
    
open func markAsRead()async throws   {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_prose_sdk_ffi_fn_method_roomprivatechannel_mark_as_read(
                    self.uniffiClonePointer()
                    
                )
            },
            pollFunc: ffi_prose_sdk_ffi_rust_future_poll_void,
            completeFunc: ffi_prose_sdk_ffi_rust_future_complete_void,
            freeFunc: ffi_prose_sdk_ffi_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeClientError_lift
        )
}
    
open func name() -> String  {
    return try!  FfiConverterString.lift(try! rustCall() {
    uniffi_prose_sdk_ffi_fn_method_roomprivatechannel_name(self.uniffiClonePointer(),$0
    )
})
}
    
open func participants() -> [ParticipantInfo]  {
    return try!  FfiConverterSequenceTypeParticipantInfo.lift(try! rustCall() {
    uniffi_prose_sdk_ffi_fn_method_roomprivatechannel_participants(self.uniffiClonePointer(),$0
    )
})
}
    
open func retractMessage(messageId: MessageId)async throws   {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_prose_sdk_ffi_fn_method_roomprivatechannel_retract_message(
                    self.uniffiClonePointer(),
                    FfiConverterTypeMessageId_lower(messageId)
                )
            },
            pollFunc: ffi_prose_sdk_ffi_rust_future_poll_void,
            completeFunc: ffi_prose_sdk_ffi_rust_future_complete_void,
            freeFunc: ffi_prose_sdk_ffi_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeClientError_lift
        )
}
    
open func saveDraft(message: String?)async throws   {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_prose_sdk_ffi_fn_method_roomprivatechannel_save_draft(
                    self.uniffiClonePointer(),
                    FfiConverterOptionString.lower(message)
                )
            },
            pollFunc: ffi_prose_sdk_ffi_rust_future_poll_void,
            completeFunc: ffi_prose_sdk_ffi_rust_future_complete_void,
            freeFunc: ffi_prose_sdk_ffi_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeClientError_lift
        )
}
    
open func sendMessage(request: SendMessageRequest)async throws   {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_prose_sdk_ffi_fn_method_roomprivatechannel_send_message(
                    self.uniffiClonePointer(),
                    FfiConverterTypeSendMessageRequest_lower(request)
                )
            },
            pollFunc: ffi_prose_sdk_ffi_rust_future_poll_void,
            completeFunc: ffi_prose_sdk_ffi_rust_future_complete_void,
            freeFunc: ffi_prose_sdk_ffi_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeClientError_lift
        )
}
    
open func setLastReadMessage(messageId: MessageId)async throws   {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_prose_sdk_ffi_fn_method_roomprivatechannel_set_last_read_message(
                    self.uniffiClonePointer(),
                    FfiConverterTypeMessageId_lower(messageId)
                )
            },
            pollFunc: ffi_prose_sdk_ffi_rust_future_poll_void,
            completeFunc: ffi_prose_sdk_ffi_rust_future_complete_void,
            freeFunc: ffi_prose_sdk_ffi_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeClientError_lift
        )
}
    
open func setName(name: String)async throws   {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_prose_sdk_ffi_fn_method_roomprivatechannel_set_name(
                    self.uniffiClonePointer(),
                    FfiConverterString.lower(name)
                )
            },
            pollFunc: ffi_prose_sdk_ffi_rust_future_poll_void,
            completeFunc: ffi_prose_sdk_ffi_rust_future_complete_void,
            freeFunc: ffi_prose_sdk_ffi_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeClientError_lift
        )
}
    
open func setTopic(topic: String?)async throws   {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_prose_sdk_ffi_fn_method_roomprivatechannel_set_topic(
                    self.uniffiClonePointer(),
                    FfiConverterOptionString.lower(topic)
                )
            },
            pollFunc: ffi_prose_sdk_ffi_rust_future_poll_void,
            completeFunc: ffi_prose_sdk_ffi_rust_future_complete_void,
            freeFunc: ffi_prose_sdk_ffi_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeClientError_lift
        )
}
    
open func setUserIsComposing(isComposing: Bool)async throws   {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_prose_sdk_ffi_fn_method_roomprivatechannel_set_user_is_composing(
                    self.uniffiClonePointer(),
                    FfiConverterBool.lower(isComposing)
                )
            },
            pollFunc: ffi_prose_sdk_ffi_rust_future_poll_void,
            completeFunc: ffi_prose_sdk_ffi_rust_future_complete_void,
            freeFunc: ffi_prose_sdk_ffi_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeClientError_lift
        )
}
    
open func state() -> RoomState  {
    return try!  FfiConverterTypeRoomState_lift(try! rustCall() {
    uniffi_prose_sdk_ffi_fn_method_roomprivatechannel_state(self.uniffiClonePointer(),$0
    )
})
}
    
open func subject() -> String?  {
    return try!  FfiConverterOptionString.lift(try! rustCall() {
    uniffi_prose_sdk_ffi_fn_method_roomprivatechannel_subject(self.uniffiClonePointer(),$0
    )
})
}
    
open func toggleReactionToMessage(messageId: MessageId, emoji: Emoji)async throws   {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_prose_sdk_ffi_fn_method_roomprivatechannel_toggle_reaction_to_message(
                    self.uniffiClonePointer(),
                    FfiConverterTypeMessageId_lower(messageId),FfiConverterTypeEmoji_lower(emoji)
                )
            },
            pollFunc: ffi_prose_sdk_ffi_rust_future_poll_void,
            completeFunc: ffi_prose_sdk_ffi_rust_future_complete_void,
            freeFunc: ffi_prose_sdk_ffi_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeClientError_lift
        )
}
    
open func updateMessage(messageId: MessageId, request: SendMessageRequest)async throws   {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_prose_sdk_ffi_fn_method_roomprivatechannel_update_message(
                    self.uniffiClonePointer(),
                    FfiConverterTypeMessageId_lower(messageId),FfiConverterTypeSendMessageRequest_lower(request)
                )
            },
            pollFunc: ffi_prose_sdk_ffi_rust_future_poll_void,
            completeFunc: ffi_prose_sdk_ffi_rust_future_complete_void,
            freeFunc: ffi_prose_sdk_ffi_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeClientError_lift
        )
}
    

}
extension RoomPrivateChannel: ChannelProtocol {}

extension RoomPrivateChannel: HasMutableNameProtocol {}

extension RoomPrivateChannel: MucRoomProtocol {}

extension RoomPrivateChannel: RoomBaseProtocol {}



#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeRoomPrivateChannel: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = RoomPrivateChannel

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> RoomPrivateChannel {
        return RoomPrivateChannel(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: RoomPrivateChannel) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> RoomPrivateChannel {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: RoomPrivateChannel, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeRoomPrivateChannel_lift(_ pointer: UnsafeMutableRawPointer) throws -> RoomPrivateChannel {
    return try FfiConverterTypeRoomPrivateChannel.lift(pointer)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeRoomPrivateChannel_lower(_ value: RoomPrivateChannel) -> UnsafeMutableRawPointer {
    return FfiConverterTypeRoomPrivateChannel.lower(value)
}






public protocol RoomPublicChannelProtocol: AnyObject, Sendable {
    
    func id()  -> RoomId
    
    func inviteUsers(users: [UserId]) async throws 
    
    func loadComposingUsers() async throws  -> [ParticipantBasicInfo]
    
    func loadDraft() async throws  -> String?
    
    func loadLatestMessages() async throws  -> MessageResultSet
    
    func loadMessagesBefore(before: MessageId) async throws  -> MessageResultSet
    
    func loadMessagesWithIds(ids: [MessageId]) async throws  -> [Message]
    
    func loadUnreadMessages() async throws  -> MessageResultSet
    
    func markAsRead() async throws 
    
    func name()  -> String
    
    func participants()  -> [ParticipantInfo]
    
    func retractMessage(messageId: MessageId) async throws 
    
    func saveDraft(message: String?) async throws 
    
    func sendMessage(request: SendMessageRequest) async throws 
    
    func setLastReadMessage(messageId: MessageId) async throws 
    
    func setName(name: String) async throws 
    
    func setTopic(topic: String?) async throws 
    
    func setUserIsComposing(isComposing: Bool) async throws 
    
    func state()  -> RoomState
    
    func subject()  -> String?
    
    func toggleReactionToMessage(messageId: MessageId, emoji: Emoji) async throws 
    
    func updateMessage(messageId: MessageId, request: SendMessageRequest) async throws 
    
}
open class RoomPublicChannel: RoomPublicChannelProtocol, @unchecked Sendable {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    // This constructor can be used to instantiate a fake object.
    // - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    //
    // - Warning:
    //     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_prose_sdk_ffi_fn_clone_roompublicchannel(self.pointer, $0) }
    }
    // No primary constructor declared for this class.

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_prose_sdk_ffi_fn_free_roompublicchannel(pointer, $0) }
    }

    

    
open func id() -> RoomId  {
    return try!  FfiConverterTypeRoomId_lift(try! rustCall() {
    uniffi_prose_sdk_ffi_fn_method_roompublicchannel_id(self.uniffiClonePointer(),$0
    )
})
}
    
open func inviteUsers(users: [UserId])async throws   {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_prose_sdk_ffi_fn_method_roompublicchannel_invite_users(
                    self.uniffiClonePointer(),
                    FfiConverterSequenceTypeUserId.lower(users)
                )
            },
            pollFunc: ffi_prose_sdk_ffi_rust_future_poll_void,
            completeFunc: ffi_prose_sdk_ffi_rust_future_complete_void,
            freeFunc: ffi_prose_sdk_ffi_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeClientError_lift
        )
}
    
open func loadComposingUsers()async throws  -> [ParticipantBasicInfo]  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_prose_sdk_ffi_fn_method_roompublicchannel_load_composing_users(
                    self.uniffiClonePointer()
                    
                )
            },
            pollFunc: ffi_prose_sdk_ffi_rust_future_poll_rust_buffer,
            completeFunc: ffi_prose_sdk_ffi_rust_future_complete_rust_buffer,
            freeFunc: ffi_prose_sdk_ffi_rust_future_free_rust_buffer,
            liftFunc: FfiConverterSequenceTypeParticipantBasicInfo.lift,
            errorHandler: FfiConverterTypeClientError_lift
        )
}
    
open func loadDraft()async throws  -> String?  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_prose_sdk_ffi_fn_method_roompublicchannel_load_draft(
                    self.uniffiClonePointer()
                    
                )
            },
            pollFunc: ffi_prose_sdk_ffi_rust_future_poll_rust_buffer,
            completeFunc: ffi_prose_sdk_ffi_rust_future_complete_rust_buffer,
            freeFunc: ffi_prose_sdk_ffi_rust_future_free_rust_buffer,
            liftFunc: FfiConverterOptionString.lift,
            errorHandler: FfiConverterTypeClientError_lift
        )
}
    
open func loadLatestMessages()async throws  -> MessageResultSet  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_prose_sdk_ffi_fn_method_roompublicchannel_load_latest_messages(
                    self.uniffiClonePointer()
                    
                )
            },
            pollFunc: ffi_prose_sdk_ffi_rust_future_poll_rust_buffer,
            completeFunc: ffi_prose_sdk_ffi_rust_future_complete_rust_buffer,
            freeFunc: ffi_prose_sdk_ffi_rust_future_free_rust_buffer,
            liftFunc: FfiConverterTypeMessageResultSet_lift,
            errorHandler: FfiConverterTypeClientError_lift
        )
}
    
open func loadMessagesBefore(before: MessageId)async throws  -> MessageResultSet  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_prose_sdk_ffi_fn_method_roompublicchannel_load_messages_before(
                    self.uniffiClonePointer(),
                    FfiConverterTypeMessageId_lower(before)
                )
            },
            pollFunc: ffi_prose_sdk_ffi_rust_future_poll_rust_buffer,
            completeFunc: ffi_prose_sdk_ffi_rust_future_complete_rust_buffer,
            freeFunc: ffi_prose_sdk_ffi_rust_future_free_rust_buffer,
            liftFunc: FfiConverterTypeMessageResultSet_lift,
            errorHandler: FfiConverterTypeClientError_lift
        )
}
    
open func loadMessagesWithIds(ids: [MessageId])async throws  -> [Message]  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_prose_sdk_ffi_fn_method_roompublicchannel_load_messages_with_ids(
                    self.uniffiClonePointer(),
                    FfiConverterSequenceTypeMessageId.lower(ids)
                )
            },
            pollFunc: ffi_prose_sdk_ffi_rust_future_poll_rust_buffer,
            completeFunc: ffi_prose_sdk_ffi_rust_future_complete_rust_buffer,
            freeFunc: ffi_prose_sdk_ffi_rust_future_free_rust_buffer,
            liftFunc: FfiConverterSequenceTypeMessage.lift,
            errorHandler: FfiConverterTypeClientError_lift
        )
}
    
open func loadUnreadMessages()async throws  -> MessageResultSet  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_prose_sdk_ffi_fn_method_roompublicchannel_load_unread_messages(
                    self.uniffiClonePointer()
                    
                )
            },
            pollFunc: ffi_prose_sdk_ffi_rust_future_poll_rust_buffer,
            completeFunc: ffi_prose_sdk_ffi_rust_future_complete_rust_buffer,
            freeFunc: ffi_prose_sdk_ffi_rust_future_free_rust_buffer,
            liftFunc: FfiConverterTypeMessageResultSet_lift,
            errorHandler: FfiConverterTypeClientError_lift
        )
}
    
open func markAsRead()async throws   {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_prose_sdk_ffi_fn_method_roompublicchannel_mark_as_read(
                    self.uniffiClonePointer()
                    
                )
            },
            pollFunc: ffi_prose_sdk_ffi_rust_future_poll_void,
            completeFunc: ffi_prose_sdk_ffi_rust_future_complete_void,
            freeFunc: ffi_prose_sdk_ffi_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeClientError_lift
        )
}
    
open func name() -> String  {
    return try!  FfiConverterString.lift(try! rustCall() {
    uniffi_prose_sdk_ffi_fn_method_roompublicchannel_name(self.uniffiClonePointer(),$0
    )
})
}
    
open func participants() -> [ParticipantInfo]  {
    return try!  FfiConverterSequenceTypeParticipantInfo.lift(try! rustCall() {
    uniffi_prose_sdk_ffi_fn_method_roompublicchannel_participants(self.uniffiClonePointer(),$0
    )
})
}
    
open func retractMessage(messageId: MessageId)async throws   {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_prose_sdk_ffi_fn_method_roompublicchannel_retract_message(
                    self.uniffiClonePointer(),
                    FfiConverterTypeMessageId_lower(messageId)
                )
            },
            pollFunc: ffi_prose_sdk_ffi_rust_future_poll_void,
            completeFunc: ffi_prose_sdk_ffi_rust_future_complete_void,
            freeFunc: ffi_prose_sdk_ffi_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeClientError_lift
        )
}
    
open func saveDraft(message: String?)async throws   {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_prose_sdk_ffi_fn_method_roompublicchannel_save_draft(
                    self.uniffiClonePointer(),
                    FfiConverterOptionString.lower(message)
                )
            },
            pollFunc: ffi_prose_sdk_ffi_rust_future_poll_void,
            completeFunc: ffi_prose_sdk_ffi_rust_future_complete_void,
            freeFunc: ffi_prose_sdk_ffi_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeClientError_lift
        )
}
    
open func sendMessage(request: SendMessageRequest)async throws   {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_prose_sdk_ffi_fn_method_roompublicchannel_send_message(
                    self.uniffiClonePointer(),
                    FfiConverterTypeSendMessageRequest_lower(request)
                )
            },
            pollFunc: ffi_prose_sdk_ffi_rust_future_poll_void,
            completeFunc: ffi_prose_sdk_ffi_rust_future_complete_void,
            freeFunc: ffi_prose_sdk_ffi_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeClientError_lift
        )
}
    
open func setLastReadMessage(messageId: MessageId)async throws   {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_prose_sdk_ffi_fn_method_roompublicchannel_set_last_read_message(
                    self.uniffiClonePointer(),
                    FfiConverterTypeMessageId_lower(messageId)
                )
            },
            pollFunc: ffi_prose_sdk_ffi_rust_future_poll_void,
            completeFunc: ffi_prose_sdk_ffi_rust_future_complete_void,
            freeFunc: ffi_prose_sdk_ffi_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeClientError_lift
        )
}
    
open func setName(name: String)async throws   {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_prose_sdk_ffi_fn_method_roompublicchannel_set_name(
                    self.uniffiClonePointer(),
                    FfiConverterString.lower(name)
                )
            },
            pollFunc: ffi_prose_sdk_ffi_rust_future_poll_void,
            completeFunc: ffi_prose_sdk_ffi_rust_future_complete_void,
            freeFunc: ffi_prose_sdk_ffi_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeClientError_lift
        )
}
    
open func setTopic(topic: String?)async throws   {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_prose_sdk_ffi_fn_method_roompublicchannel_set_topic(
                    self.uniffiClonePointer(),
                    FfiConverterOptionString.lower(topic)
                )
            },
            pollFunc: ffi_prose_sdk_ffi_rust_future_poll_void,
            completeFunc: ffi_prose_sdk_ffi_rust_future_complete_void,
            freeFunc: ffi_prose_sdk_ffi_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeClientError_lift
        )
}
    
open func setUserIsComposing(isComposing: Bool)async throws   {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_prose_sdk_ffi_fn_method_roompublicchannel_set_user_is_composing(
                    self.uniffiClonePointer(),
                    FfiConverterBool.lower(isComposing)
                )
            },
            pollFunc: ffi_prose_sdk_ffi_rust_future_poll_void,
            completeFunc: ffi_prose_sdk_ffi_rust_future_complete_void,
            freeFunc: ffi_prose_sdk_ffi_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeClientError_lift
        )
}
    
open func state() -> RoomState  {
    return try!  FfiConverterTypeRoomState_lift(try! rustCall() {
    uniffi_prose_sdk_ffi_fn_method_roompublicchannel_state(self.uniffiClonePointer(),$0
    )
})
}
    
open func subject() -> String?  {
    return try!  FfiConverterOptionString.lift(try! rustCall() {
    uniffi_prose_sdk_ffi_fn_method_roompublicchannel_subject(self.uniffiClonePointer(),$0
    )
})
}
    
open func toggleReactionToMessage(messageId: MessageId, emoji: Emoji)async throws   {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_prose_sdk_ffi_fn_method_roompublicchannel_toggle_reaction_to_message(
                    self.uniffiClonePointer(),
                    FfiConverterTypeMessageId_lower(messageId),FfiConverterTypeEmoji_lower(emoji)
                )
            },
            pollFunc: ffi_prose_sdk_ffi_rust_future_poll_void,
            completeFunc: ffi_prose_sdk_ffi_rust_future_complete_void,
            freeFunc: ffi_prose_sdk_ffi_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeClientError_lift
        )
}
    
open func updateMessage(messageId: MessageId, request: SendMessageRequest)async throws   {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_prose_sdk_ffi_fn_method_roompublicchannel_update_message(
                    self.uniffiClonePointer(),
                    FfiConverterTypeMessageId_lower(messageId),FfiConverterTypeSendMessageRequest_lower(request)
                )
            },
            pollFunc: ffi_prose_sdk_ffi_rust_future_poll_void,
            completeFunc: ffi_prose_sdk_ffi_rust_future_complete_void,
            freeFunc: ffi_prose_sdk_ffi_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeClientError_lift
        )
}
    

}
extension RoomPublicChannel: ChannelProtocol {}

extension RoomPublicChannel: HasMutableNameProtocol {}

extension RoomPublicChannel: MucRoomProtocol {}

extension RoomPublicChannel: RoomBaseProtocol {}



#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeRoomPublicChannel: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = RoomPublicChannel

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> RoomPublicChannel {
        return RoomPublicChannel(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: RoomPublicChannel) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> RoomPublicChannel {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: RoomPublicChannel, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeRoomPublicChannel_lift(_ pointer: UnsafeMutableRawPointer) throws -> RoomPublicChannel {
    return try FfiConverterTypeRoomPublicChannel.lift(pointer)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeRoomPublicChannel_lower(_ value: RoomPublicChannel) -> UnsafeMutableRawPointer {
    return FfiConverterTypeRoomPublicChannel.lower(value)
}




public struct AccountBookmark {
    public var userId: UserId
    public var isSelected: Bool

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(userId: UserId, isSelected: Bool) {
        self.userId = userId
        self.isSelected = isSelected
    }
}

#if compiler(>=6)
extension AccountBookmark: Sendable {}
#endif


extension AccountBookmark: Equatable, Hashable {
    public static func ==(lhs: AccountBookmark, rhs: AccountBookmark) -> Bool {
        if lhs.userId != rhs.userId {
            return false
        }
        if lhs.isSelected != rhs.isSelected {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(userId)
        hasher.combine(isSelected)
    }
}



#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeAccountBookmark: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> AccountBookmark {
        return
            try AccountBookmark(
                userId: FfiConverterTypeUserId.read(from: &buf), 
                isSelected: FfiConverterBool.read(from: &buf)
        )
    }

    public static func write(_ value: AccountBookmark, into buf: inout [UInt8]) {
        FfiConverterTypeUserId.write(value.userId, into: &buf)
        FfiConverterBool.write(value.isSelected, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeAccountBookmark_lift(_ buf: RustBuffer) throws -> AccountBookmark {
    return try FfiConverterTypeAccountBookmark.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeAccountBookmark_lower(_ value: AccountBookmark) -> RustBuffer {
    return FfiConverterTypeAccountBookmark.lower(value)
}


public struct AccountInfo {
    public var id: UserId
    public var name: String
    public var avatar: Avatar?
    public var availability: Availability
    public var status: UserStatus?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(id: UserId, name: String, avatar: Avatar?, availability: Availability, status: UserStatus?) {
        self.id = id
        self.name = name
        self.avatar = avatar
        self.availability = availability
        self.status = status
    }
}

#if compiler(>=6)
extension AccountInfo: Sendable {}
#endif



#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeAccountInfo: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> AccountInfo {
        return
            try AccountInfo(
                id: FfiConverterTypeUserId.read(from: &buf), 
                name: FfiConverterString.read(from: &buf), 
                avatar: FfiConverterOptionTypeAvatar.read(from: &buf), 
                availability: FfiConverterTypeAvailability.read(from: &buf), 
                status: FfiConverterOptionTypeUserStatus.read(from: &buf)
        )
    }

    public static func write(_ value: AccountInfo, into buf: inout [UInt8]) {
        FfiConverterTypeUserId.write(value.id, into: &buf)
        FfiConverterString.write(value.name, into: &buf)
        FfiConverterOptionTypeAvatar.write(value.avatar, into: &buf)
        FfiConverterTypeAvailability.write(value.availability, into: &buf)
        FfiConverterOptionTypeUserStatus.write(value.status, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeAccountInfo_lift(_ buf: RustBuffer) throws -> AccountInfo {
    return try FfiConverterTypeAccountInfo.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeAccountInfo_lower(_ value: AccountInfo) -> RustBuffer {
    return FfiConverterTypeAccountInfo.lower(value)
}


public struct Address {
    public var locality: String?
    public var country: String?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(locality: String?, country: String?) {
        self.locality = locality
        self.country = country
    }
}

#if compiler(>=6)
extension Address: Sendable {}
#endif


extension Address: Equatable, Hashable {
    public static func ==(lhs: Address, rhs: Address) -> Bool {
        if lhs.locality != rhs.locality {
            return false
        }
        if lhs.country != rhs.country {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(locality)
        hasher.combine(country)
    }
}



#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeAddress: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Address {
        return
            try Address(
                locality: FfiConverterOptionString.read(from: &buf), 
                country: FfiConverterOptionString.read(from: &buf)
        )
    }

    public static func write(_ value: Address, into buf: inout [UInt8]) {
        FfiConverterOptionString.write(value.locality, into: &buf)
        FfiConverterOptionString.write(value.country, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeAddress_lift(_ buf: RustBuffer) throws -> Address {
    return try FfiConverterTypeAddress.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeAddress_lower(_ value: Address) -> RustBuffer {
    return FfiConverterTypeAddress.lower(value)
}


public struct Attachment {
    public var type: AttachmentType
    public var url: Url
    public var mediaType: Mime
    public var fileName: String
    public var fileSize: UInt64?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(type: AttachmentType, url: Url, mediaType: Mime, fileName: String, fileSize: UInt64?) {
        self.type = type
        self.url = url
        self.mediaType = mediaType
        self.fileName = fileName
        self.fileSize = fileSize
    }
}

#if compiler(>=6)
extension Attachment: Sendable {}
#endif


extension Attachment: Equatable, Hashable {
    public static func ==(lhs: Attachment, rhs: Attachment) -> Bool {
        if lhs.type != rhs.type {
            return false
        }
        if lhs.url != rhs.url {
            return false
        }
        if lhs.mediaType != rhs.mediaType {
            return false
        }
        if lhs.fileName != rhs.fileName {
            return false
        }
        if lhs.fileSize != rhs.fileSize {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(type)
        hasher.combine(url)
        hasher.combine(mediaType)
        hasher.combine(fileName)
        hasher.combine(fileSize)
    }
}



#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeAttachment: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Attachment {
        return
            try Attachment(
                type: FfiConverterTypeAttachmentType.read(from: &buf), 
                url: FfiConverterTypeUrl.read(from: &buf), 
                mediaType: FfiConverterTypeMime.read(from: &buf), 
                fileName: FfiConverterString.read(from: &buf), 
                fileSize: FfiConverterOptionUInt64.read(from: &buf)
        )
    }

    public static func write(_ value: Attachment, into buf: inout [UInt8]) {
        FfiConverterTypeAttachmentType.write(value.type, into: &buf)
        FfiConverterTypeUrl.write(value.url, into: &buf)
        FfiConverterTypeMime.write(value.mediaType, into: &buf)
        FfiConverterString.write(value.fileName, into: &buf)
        FfiConverterOptionUInt64.write(value.fileSize, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeAttachment_lift(_ buf: RustBuffer) throws -> Attachment {
    return try FfiConverterTypeAttachment.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeAttachment_lower(_ value: Attachment) -> RustBuffer {
    return FfiConverterTypeAttachment.lower(value)
}


public struct ClientConfig {
    public var clientName: String
    public var clientVersion: String
    public var clientOs: String?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(clientName: String, clientVersion: String, clientOs: String?) {
        self.clientName = clientName
        self.clientVersion = clientVersion
        self.clientOs = clientOs
    }
}

#if compiler(>=6)
extension ClientConfig: Sendable {}
#endif


extension ClientConfig: Equatable, Hashable {
    public static func ==(lhs: ClientConfig, rhs: ClientConfig) -> Bool {
        if lhs.clientName != rhs.clientName {
            return false
        }
        if lhs.clientVersion != rhs.clientVersion {
            return false
        }
        if lhs.clientOs != rhs.clientOs {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(clientName)
        hasher.combine(clientVersion)
        hasher.combine(clientOs)
    }
}



#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeClientConfig: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ClientConfig {
        return
            try ClientConfig(
                clientName: FfiConverterString.read(from: &buf), 
                clientVersion: FfiConverterString.read(from: &buf), 
                clientOs: FfiConverterOptionString.read(from: &buf)
        )
    }

    public static func write(_ value: ClientConfig, into buf: inout [UInt8]) {
        FfiConverterString.write(value.clientName, into: &buf)
        FfiConverterString.write(value.clientVersion, into: &buf)
        FfiConverterOptionString.write(value.clientOs, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeClientConfig_lift(_ buf: RustBuffer) throws -> ClientConfig {
    return try FfiConverterTypeClientConfig.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeClientConfig_lower(_ value: ClientConfig) -> RustBuffer {
    return FfiConverterTypeClientConfig.lower(value)
}


public struct Contact {
    public var id: UserId
    public var name: String
    public var availability: Availability
    public var status: UserStatus?
    public var group: Group

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(id: UserId, name: String, availability: Availability, status: UserStatus?, group: Group) {
        self.id = id
        self.name = name
        self.availability = availability
        self.status = status
        self.group = group
    }
}

#if compiler(>=6)
extension Contact: Sendable {}
#endif


extension Contact: Equatable, Hashable {
    public static func ==(lhs: Contact, rhs: Contact) -> Bool {
        if lhs.id != rhs.id {
            return false
        }
        if lhs.name != rhs.name {
            return false
        }
        if lhs.availability != rhs.availability {
            return false
        }
        if lhs.status != rhs.status {
            return false
        }
        if lhs.group != rhs.group {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(id)
        hasher.combine(name)
        hasher.combine(availability)
        hasher.combine(status)
        hasher.combine(group)
    }
}



#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeContact: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Contact {
        return
            try Contact(
                id: FfiConverterTypeUserId.read(from: &buf), 
                name: FfiConverterString.read(from: &buf), 
                availability: FfiConverterTypeAvailability.read(from: &buf), 
                status: FfiConverterOptionTypeUserStatus.read(from: &buf), 
                group: FfiConverterTypeGroup.read(from: &buf)
        )
    }

    public static func write(_ value: Contact, into buf: inout [UInt8]) {
        FfiConverterTypeUserId.write(value.id, into: &buf)
        FfiConverterString.write(value.name, into: &buf)
        FfiConverterTypeAvailability.write(value.availability, into: &buf)
        FfiConverterOptionTypeUserStatus.write(value.status, into: &buf)
        FfiConverterTypeGroup.write(value.group, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeContact_lift(_ buf: RustBuffer) throws -> Contact {
    return try FfiConverterTypeContact.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeContact_lower(_ value: Contact) -> RustBuffer {
    return FfiConverterTypeContact.lower(value)
}


public struct JabberClient {
    public var name: String
    public var isProse: Bool

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(name: String, isProse: Bool) {
        self.name = name
        self.isProse = isProse
    }
}

#if compiler(>=6)
extension JabberClient: Sendable {}
#endif


extension JabberClient: Equatable, Hashable {
    public static func ==(lhs: JabberClient, rhs: JabberClient) -> Bool {
        if lhs.name != rhs.name {
            return false
        }
        if lhs.isProse != rhs.isProse {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(name)
        hasher.combine(isProse)
    }
}



#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeJabberClient: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> JabberClient {
        return
            try JabberClient(
                name: FfiConverterString.read(from: &buf), 
                isProse: FfiConverterBool.read(from: &buf)
        )
    }

    public static func write(_ value: JabberClient, into buf: inout [UInt8]) {
        FfiConverterString.write(value.name, into: &buf)
        FfiConverterBool.write(value.isProse, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeJabberClient_lift(_ buf: RustBuffer) throws -> JabberClient {
    return try FfiConverterTypeJabberClient.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeJabberClient_lower(_ value: JabberClient) -> RustBuffer {
    return FfiConverterTypeJabberClient.lower(value)
}


public struct LastActivity {
    public var timestamp: DateTime
    public var status: String?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(timestamp: DateTime, status: String?) {
        self.timestamp = timestamp
        self.status = status
    }
}

#if compiler(>=6)
extension LastActivity: Sendable {}
#endif


extension LastActivity: Equatable, Hashable {
    public static func ==(lhs: LastActivity, rhs: LastActivity) -> Bool {
        if lhs.timestamp != rhs.timestamp {
            return false
        }
        if lhs.status != rhs.status {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(timestamp)
        hasher.combine(status)
    }
}



#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeLastActivity: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> LastActivity {
        return
            try LastActivity(
                timestamp: FfiConverterTypeDateTime.read(from: &buf), 
                status: FfiConverterOptionString.read(from: &buf)
        )
    }

    public static func write(_ value: LastActivity, into buf: inout [UInt8]) {
        FfiConverterTypeDateTime.write(value.timestamp, into: &buf)
        FfiConverterOptionString.write(value.status, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeLastActivity_lift(_ buf: RustBuffer) throws -> LastActivity {
    return try FfiConverterTypeLastActivity.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeLastActivity_lower(_ value: LastActivity) -> RustBuffer {
    return FfiConverterTypeLastActivity.lower(value)
}


public struct Mention {
    public var user: UserId
    public var range: UnicodeScalarRange?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(user: UserId, range: UnicodeScalarRange?) {
        self.user = user
        self.range = range
    }
}

#if compiler(>=6)
extension Mention: Sendable {}
#endif


extension Mention: Equatable, Hashable {
    public static func ==(lhs: Mention, rhs: Mention) -> Bool {
        if lhs.user != rhs.user {
            return false
        }
        if lhs.range != rhs.range {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(user)
        hasher.combine(range)
    }
}



#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeMention: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Mention {
        return
            try Mention(
                user: FfiConverterTypeUserId.read(from: &buf), 
                range: FfiConverterOptionTypeUnicodeScalarRange.read(from: &buf)
        )
    }

    public static func write(_ value: Mention, into buf: inout [UInt8]) {
        FfiConverterTypeUserId.write(value.user, into: &buf)
        FfiConverterOptionTypeUnicodeScalarRange.write(value.range, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeMention_lift(_ buf: RustBuffer) throws -> Mention {
    return try FfiConverterTypeMention.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeMention_lower(_ value: Mention) -> RustBuffer {
    return FfiConverterTypeMention.lower(value)
}


public struct Message {
    public var id: MessageId
    public var from: MessageSender
    public var body: MessageBody
    public var timestamp: DateTime
    public var flags: MessageFlags
    public var reactions: [Reaction]
    public var attachments: [Attachment]
    public var mentions: [Mention]
    public var replyTo: ReplyTo?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(id: MessageId, from: MessageSender, body: MessageBody, timestamp: DateTime, flags: MessageFlags, reactions: [Reaction], attachments: [Attachment], mentions: [Mention], replyTo: ReplyTo?) {
        self.id = id
        self.from = from
        self.body = body
        self.timestamp = timestamp
        self.flags = flags
        self.reactions = reactions
        self.attachments = attachments
        self.mentions = mentions
        self.replyTo = replyTo
    }
}

#if compiler(>=6)
extension Message: Sendable {}
#endif



#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeMessage: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Message {
        return
            try Message(
                id: FfiConverterTypeMessageId.read(from: &buf), 
                from: FfiConverterTypeMessageSender.read(from: &buf), 
                body: FfiConverterTypeMessageBody.read(from: &buf), 
                timestamp: FfiConverterTypeDateTime.read(from: &buf), 
                flags: FfiConverterTypeMessageFlags.read(from: &buf), 
                reactions: FfiConverterSequenceTypeReaction.read(from: &buf), 
                attachments: FfiConverterSequenceTypeAttachment.read(from: &buf), 
                mentions: FfiConverterSequenceTypeMention.read(from: &buf), 
                replyTo: FfiConverterOptionTypeReplyTo.read(from: &buf)
        )
    }

    public static func write(_ value: Message, into buf: inout [UInt8]) {
        FfiConverterTypeMessageId.write(value.id, into: &buf)
        FfiConverterTypeMessageSender.write(value.from, into: &buf)
        FfiConverterTypeMessageBody.write(value.body, into: &buf)
        FfiConverterTypeDateTime.write(value.timestamp, into: &buf)
        FfiConverterTypeMessageFlags.write(value.flags, into: &buf)
        FfiConverterSequenceTypeReaction.write(value.reactions, into: &buf)
        FfiConverterSequenceTypeAttachment.write(value.attachments, into: &buf)
        FfiConverterSequenceTypeMention.write(value.mentions, into: &buf)
        FfiConverterOptionTypeReplyTo.write(value.replyTo, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeMessage_lift(_ buf: RustBuffer) throws -> Message {
    return try FfiConverterTypeMessage.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeMessage_lower(_ value: Message) -> RustBuffer {
    return FfiConverterTypeMessage.lower(value)
}


public struct MessageBody {
    public var raw: String
    public var html: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(raw: String, html: String) {
        self.raw = raw
        self.html = html
    }
}

#if compiler(>=6)
extension MessageBody: Sendable {}
#endif


extension MessageBody: Equatable, Hashable {
    public static func ==(lhs: MessageBody, rhs: MessageBody) -> Bool {
        if lhs.raw != rhs.raw {
            return false
        }
        if lhs.html != rhs.html {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(raw)
        hasher.combine(html)
    }
}



#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeMessageBody: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> MessageBody {
        return
            try MessageBody(
                raw: FfiConverterString.read(from: &buf), 
                html: FfiConverterString.read(from: &buf)
        )
    }

    public static func write(_ value: MessageBody, into buf: inout [UInt8]) {
        FfiConverterString.write(value.raw, into: &buf)
        FfiConverterString.write(value.html, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeMessageBody_lift(_ buf: RustBuffer) throws -> MessageBody {
    return try FfiConverterTypeMessageBody.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeMessageBody_lower(_ value: MessageBody) -> RustBuffer {
    return FfiConverterTypeMessageBody.lower(value)
}


public struct MessageFlags {
    public var isRead: Bool
    public var isEdited: Bool
    public var isDelivered: Bool
    public var isTransient: Bool
    public var isEncrypted: Bool
    /**
     * When contained in a list, this message is the last message that our user has read.
     */
    public var isLastRead: Bool

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(isRead: Bool, isEdited: Bool, isDelivered: Bool, isTransient: Bool, isEncrypted: Bool, 
        /**
         * When contained in a list, this message is the last message that our user has read.
         */isLastRead: Bool) {
        self.isRead = isRead
        self.isEdited = isEdited
        self.isDelivered = isDelivered
        self.isTransient = isTransient
        self.isEncrypted = isEncrypted
        self.isLastRead = isLastRead
    }
}

#if compiler(>=6)
extension MessageFlags: Sendable {}
#endif


extension MessageFlags: Equatable, Hashable {
    public static func ==(lhs: MessageFlags, rhs: MessageFlags) -> Bool {
        if lhs.isRead != rhs.isRead {
            return false
        }
        if lhs.isEdited != rhs.isEdited {
            return false
        }
        if lhs.isDelivered != rhs.isDelivered {
            return false
        }
        if lhs.isTransient != rhs.isTransient {
            return false
        }
        if lhs.isEncrypted != rhs.isEncrypted {
            return false
        }
        if lhs.isLastRead != rhs.isLastRead {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(isRead)
        hasher.combine(isEdited)
        hasher.combine(isDelivered)
        hasher.combine(isTransient)
        hasher.combine(isEncrypted)
        hasher.combine(isLastRead)
    }
}



#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeMessageFlags: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> MessageFlags {
        return
            try MessageFlags(
                isRead: FfiConverterBool.read(from: &buf), 
                isEdited: FfiConverterBool.read(from: &buf), 
                isDelivered: FfiConverterBool.read(from: &buf), 
                isTransient: FfiConverterBool.read(from: &buf), 
                isEncrypted: FfiConverterBool.read(from: &buf), 
                isLastRead: FfiConverterBool.read(from: &buf)
        )
    }

    public static func write(_ value: MessageFlags, into buf: inout [UInt8]) {
        FfiConverterBool.write(value.isRead, into: &buf)
        FfiConverterBool.write(value.isEdited, into: &buf)
        FfiConverterBool.write(value.isDelivered, into: &buf)
        FfiConverterBool.write(value.isTransient, into: &buf)
        FfiConverterBool.write(value.isEncrypted, into: &buf)
        FfiConverterBool.write(value.isLastRead, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeMessageFlags_lift(_ buf: RustBuffer) throws -> MessageFlags {
    return try FfiConverterTypeMessageFlags.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeMessageFlags_lower(_ value: MessageFlags) -> RustBuffer {
    return FfiConverterTypeMessageFlags.lower(value)
}


public struct MessageResultSet {
    /**
     * The requested messages in the order from oldest to newest.
     */
    public var messages: [Message]
    /**
     * Can be used to load more messages. `last_message_id` might not be contained in `messages`.
     * If not set there are no more messages to load.
     */
    public var lastMessageId: MessageId?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * The requested messages in the order from oldest to newest.
         */messages: [Message], 
        /**
         * Can be used to load more messages. `last_message_id` might not be contained in `messages`.
         * If not set there are no more messages to load.
         */lastMessageId: MessageId?) {
        self.messages = messages
        self.lastMessageId = lastMessageId
    }
}

#if compiler(>=6)
extension MessageResultSet: Sendable {}
#endif



#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeMessageResultSet: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> MessageResultSet {
        return
            try MessageResultSet(
                messages: FfiConverterSequenceTypeMessage.read(from: &buf), 
                lastMessageId: FfiConverterOptionTypeMessageId.read(from: &buf)
        )
    }

    public static func write(_ value: MessageResultSet, into buf: inout [UInt8]) {
        FfiConverterSequenceTypeMessage.write(value.messages, into: &buf)
        FfiConverterOptionTypeMessageId.write(value.lastMessageId, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeMessageResultSet_lift(_ buf: RustBuffer) throws -> MessageResultSet {
    return try FfiConverterTypeMessageResultSet.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeMessageResultSet_lower(_ value: MessageResultSet) -> RustBuffer {
    return FfiConverterTypeMessageResultSet.lower(value)
}


public struct MessageSender {
    public var id: ParticipantId
    public var name: String
    public var avatar: Avatar?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(id: ParticipantId, name: String, avatar: Avatar?) {
        self.id = id
        self.name = name
        self.avatar = avatar
    }
}

#if compiler(>=6)
extension MessageSender: Sendable {}
#endif



#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeMessageSender: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> MessageSender {
        return
            try MessageSender(
                id: FfiConverterTypeParticipantId.read(from: &buf), 
                name: FfiConverterString.read(from: &buf), 
                avatar: FfiConverterOptionTypeAvatar.read(from: &buf)
        )
    }

    public static func write(_ value: MessageSender, into buf: inout [UInt8]) {
        FfiConverterTypeParticipantId.write(value.id, into: &buf)
        FfiConverterString.write(value.name, into: &buf)
        FfiConverterOptionTypeAvatar.write(value.avatar, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeMessageSender_lift(_ buf: RustBuffer) throws -> MessageSender {
    return try FfiConverterTypeMessageSender.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeMessageSender_lower(_ value: MessageSender) -> RustBuffer {
    return FfiConverterTypeMessageSender.lower(value)
}


public struct ParticipantBasicInfo {
    public var id: ParticipantId
    public var name: String
    public var avatar: Avatar?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(id: ParticipantId, name: String, avatar: Avatar?) {
        self.id = id
        self.name = name
        self.avatar = avatar
    }
}

#if compiler(>=6)
extension ParticipantBasicInfo: Sendable {}
#endif



#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeParticipantBasicInfo: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ParticipantBasicInfo {
        return
            try ParticipantBasicInfo(
                id: FfiConverterTypeParticipantId.read(from: &buf), 
                name: FfiConverterString.read(from: &buf), 
                avatar: FfiConverterOptionTypeAvatar.read(from: &buf)
        )
    }

    public static func write(_ value: ParticipantBasicInfo, into buf: inout [UInt8]) {
        FfiConverterTypeParticipantId.write(value.id, into: &buf)
        FfiConverterString.write(value.name, into: &buf)
        FfiConverterOptionTypeAvatar.write(value.avatar, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeParticipantBasicInfo_lift(_ buf: RustBuffer) throws -> ParticipantBasicInfo {
    return try FfiConverterTypeParticipantBasicInfo.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeParticipantBasicInfo_lower(_ value: ParticipantBasicInfo) -> RustBuffer {
    return FfiConverterTypeParticipantBasicInfo.lower(value)
}


public struct ParticipantInfo {
    public var id: ParticipantId
    public var userId: UserId?
    public var name: String
    public var isSelf: Bool
    public var availability: Availability
    public var affiliation: RoomAffiliation
    public var avatar: Avatar?
    public var client: JabberClient?
    public var status: String?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(id: ParticipantId, userId: UserId?, name: String, isSelf: Bool, availability: Availability, affiliation: RoomAffiliation, avatar: Avatar?, client: JabberClient?, status: String?) {
        self.id = id
        self.userId = userId
        self.name = name
        self.isSelf = isSelf
        self.availability = availability
        self.affiliation = affiliation
        self.avatar = avatar
        self.client = client
        self.status = status
    }
}

#if compiler(>=6)
extension ParticipantInfo: Sendable {}
#endif



#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeParticipantInfo: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ParticipantInfo {
        return
            try ParticipantInfo(
                id: FfiConverterTypeParticipantId.read(from: &buf), 
                userId: FfiConverterOptionTypeUserId.read(from: &buf), 
                name: FfiConverterString.read(from: &buf), 
                isSelf: FfiConverterBool.read(from: &buf), 
                availability: FfiConverterTypeAvailability.read(from: &buf), 
                affiliation: FfiConverterTypeRoomAffiliation.read(from: &buf), 
                avatar: FfiConverterOptionTypeAvatar.read(from: &buf), 
                client: FfiConverterOptionTypeJabberClient.read(from: &buf), 
                status: FfiConverterOptionString.read(from: &buf)
        )
    }

    public static func write(_ value: ParticipantInfo, into buf: inout [UInt8]) {
        FfiConverterTypeParticipantId.write(value.id, into: &buf)
        FfiConverterOptionTypeUserId.write(value.userId, into: &buf)
        FfiConverterString.write(value.name, into: &buf)
        FfiConverterBool.write(value.isSelf, into: &buf)
        FfiConverterTypeAvailability.write(value.availability, into: &buf)
        FfiConverterTypeRoomAffiliation.write(value.affiliation, into: &buf)
        FfiConverterOptionTypeAvatar.write(value.avatar, into: &buf)
        FfiConverterOptionTypeJabberClient.write(value.client, into: &buf)
        FfiConverterOptionString.write(value.status, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeParticipantInfo_lift(_ buf: RustBuffer) throws -> ParticipantInfo {
    return try FfiConverterTypeParticipantInfo.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeParticipantInfo_lower(_ value: ParticipantInfo) -> RustBuffer {
    return FfiConverterTypeParticipantInfo.lower(value)
}


public struct PresenceSubRequest {
    public var id: PresenceSubRequestId
    public var name: String
    public var userId: UserId

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(id: PresenceSubRequestId, name: String, userId: UserId) {
        self.id = id
        self.name = name
        self.userId = userId
    }
}

#if compiler(>=6)
extension PresenceSubRequest: Sendable {}
#endif


extension PresenceSubRequest: Equatable, Hashable {
    public static func ==(lhs: PresenceSubRequest, rhs: PresenceSubRequest) -> Bool {
        if lhs.id != rhs.id {
            return false
        }
        if lhs.name != rhs.name {
            return false
        }
        if lhs.userId != rhs.userId {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(id)
        hasher.combine(name)
        hasher.combine(userId)
    }
}



#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypePresenceSubRequest: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> PresenceSubRequest {
        return
            try PresenceSubRequest(
                id: FfiConverterTypePresenceSubRequestId.read(from: &buf), 
                name: FfiConverterString.read(from: &buf), 
                userId: FfiConverterTypeUserId.read(from: &buf)
        )
    }

    public static func write(_ value: PresenceSubRequest, into buf: inout [UInt8]) {
        FfiConverterTypePresenceSubRequestId.write(value.id, into: &buf)
        FfiConverterString.write(value.name, into: &buf)
        FfiConverterTypeUserId.write(value.userId, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypePresenceSubRequest_lift(_ buf: RustBuffer) throws -> PresenceSubRequest {
    return try FfiConverterTypePresenceSubRequest.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypePresenceSubRequest_lower(_ value: PresenceSubRequest) -> RustBuffer {
    return FfiConverterTypePresenceSubRequest.lower(value)
}


public struct PublicRoomInfo {
    public var id: MucId
    public var name: String?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(id: MucId, name: String?) {
        self.id = id
        self.name = name
    }
}

#if compiler(>=6)
extension PublicRoomInfo: Sendable {}
#endif


extension PublicRoomInfo: Equatable, Hashable {
    public static func ==(lhs: PublicRoomInfo, rhs: PublicRoomInfo) -> Bool {
        if lhs.id != rhs.id {
            return false
        }
        if lhs.name != rhs.name {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(id)
        hasher.combine(name)
    }
}



#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypePublicRoomInfo: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> PublicRoomInfo {
        return
            try PublicRoomInfo(
                id: FfiConverterTypeMucId.read(from: &buf), 
                name: FfiConverterOptionString.read(from: &buf)
        )
    }

    public static func write(_ value: PublicRoomInfo, into buf: inout [UInt8]) {
        FfiConverterTypeMucId.write(value.id, into: &buf)
        FfiConverterOptionString.write(value.name, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypePublicRoomInfo_lift(_ buf: RustBuffer) throws -> PublicRoomInfo {
    return try FfiConverterTypePublicRoomInfo.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypePublicRoomInfo_lower(_ value: PublicRoomInfo) -> RustBuffer {
    return FfiConverterTypePublicRoomInfo.lower(value)
}


public struct Reaction {
    public var emoji: Emoji
    public var from: [MessageSender]

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(emoji: Emoji, from: [MessageSender]) {
        self.emoji = emoji
        self.from = from
    }
}

#if compiler(>=6)
extension Reaction: Sendable {}
#endif



#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeReaction: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Reaction {
        return
            try Reaction(
                emoji: FfiConverterTypeEmoji.read(from: &buf), 
                from: FfiConverterSequenceTypeMessageSender.read(from: &buf)
        )
    }

    public static func write(_ value: Reaction, into buf: inout [UInt8]) {
        FfiConverterTypeEmoji.write(value.emoji, into: &buf)
        FfiConverterSequenceTypeMessageSender.write(value.from, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeReaction_lift(_ buf: RustBuffer) throws -> Reaction {
    return try FfiConverterTypeReaction.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeReaction_lower(_ value: Reaction) -> RustBuffer {
    return FfiConverterTypeReaction.lower(value)
}


public struct ReplyTo {
    public var id: MessageId?
    public var sender: MessageSender
    public var timestamp: DateTime?
    public var body: String?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(id: MessageId?, sender: MessageSender, timestamp: DateTime?, body: String?) {
        self.id = id
        self.sender = sender
        self.timestamp = timestamp
        self.body = body
    }
}

#if compiler(>=6)
extension ReplyTo: Sendable {}
#endif



#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeReplyTo: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ReplyTo {
        return
            try ReplyTo(
                id: FfiConverterOptionTypeMessageId.read(from: &buf), 
                sender: FfiConverterTypeMessageSender.read(from: &buf), 
                timestamp: FfiConverterOptionTypeDateTime.read(from: &buf), 
                body: FfiConverterOptionString.read(from: &buf)
        )
    }

    public static func write(_ value: ReplyTo, into buf: inout [UInt8]) {
        FfiConverterOptionTypeMessageId.write(value.id, into: &buf)
        FfiConverterTypeMessageSender.write(value.sender, into: &buf)
        FfiConverterOptionTypeDateTime.write(value.timestamp, into: &buf)
        FfiConverterOptionString.write(value.body, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeReplyTo_lift(_ buf: RustBuffer) throws -> ReplyTo {
    return try FfiConverterTypeReplyTo.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeReplyTo_lower(_ value: ReplyTo) -> RustBuffer {
    return FfiConverterTypeReplyTo.lower(value)
}


public struct SendMessageRequest {
    public var body: SendMessageRequestBody?
    public var attachments: [Attachment]

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(body: SendMessageRequestBody?, attachments: [Attachment]) {
        self.body = body
        self.attachments = attachments
    }
}

#if compiler(>=6)
extension SendMessageRequest: Sendable {}
#endif


extension SendMessageRequest: Equatable, Hashable {
    public static func ==(lhs: SendMessageRequest, rhs: SendMessageRequest) -> Bool {
        if lhs.body != rhs.body {
            return false
        }
        if lhs.attachments != rhs.attachments {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(body)
        hasher.combine(attachments)
    }
}



#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeSendMessageRequest: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SendMessageRequest {
        return
            try SendMessageRequest(
                body: FfiConverterOptionTypeSendMessageRequestBody.read(from: &buf), 
                attachments: FfiConverterSequenceTypeAttachment.read(from: &buf)
        )
    }

    public static func write(_ value: SendMessageRequest, into buf: inout [UInt8]) {
        FfiConverterOptionTypeSendMessageRequestBody.write(value.body, into: &buf)
        FfiConverterSequenceTypeAttachment.write(value.attachments, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSendMessageRequest_lift(_ buf: RustBuffer) throws -> SendMessageRequest {
    return try FfiConverterTypeSendMessageRequest.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSendMessageRequest_lower(_ value: SendMessageRequest) -> RustBuffer {
    return FfiConverterTypeSendMessageRequest.lower(value)
}


public struct SendMessageRequestBody {
    public var text: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(text: String) {
        self.text = text
    }
}

#if compiler(>=6)
extension SendMessageRequestBody: Sendable {}
#endif


extension SendMessageRequestBody: Equatable, Hashable {
    public static func ==(lhs: SendMessageRequestBody, rhs: SendMessageRequestBody) -> Bool {
        if lhs.text != rhs.text {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(text)
    }
}



#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeSendMessageRequestBody: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SendMessageRequestBody {
        return
            try SendMessageRequestBody(
                text: FfiConverterString.read(from: &buf)
        )
    }

    public static func write(_ value: SendMessageRequestBody, into buf: inout [UInt8]) {
        FfiConverterString.write(value.text, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSendMessageRequestBody_lift(_ buf: RustBuffer) throws -> SendMessageRequestBody {
    return try FfiConverterTypeSendMessageRequestBody.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSendMessageRequestBody_lower(_ value: SendMessageRequestBody) -> RustBuffer {
    return FfiConverterTypeSendMessageRequestBody.lower(value)
}


public struct SidebarItem {
    public var name: String
    public var room: RoomEnvelope
    public var isFavorite: Bool
    public var hasDraft: Bool
    public var unreadCount: UInt32
    public var mentionsCount: UInt32

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(name: String, room: RoomEnvelope, isFavorite: Bool, hasDraft: Bool, unreadCount: UInt32, mentionsCount: UInt32) {
        self.name = name
        self.room = room
        self.isFavorite = isFavorite
        self.hasDraft = hasDraft
        self.unreadCount = unreadCount
        self.mentionsCount = mentionsCount
    }
}

#if compiler(>=6)
extension SidebarItem: Sendable {}
#endif



#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeSidebarItem: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SidebarItem {
        return
            try SidebarItem(
                name: FfiConverterString.read(from: &buf), 
                room: FfiConverterTypeRoomEnvelope.read(from: &buf), 
                isFavorite: FfiConverterBool.read(from: &buf), 
                hasDraft: FfiConverterBool.read(from: &buf), 
                unreadCount: FfiConverterUInt32.read(from: &buf), 
                mentionsCount: FfiConverterUInt32.read(from: &buf)
        )
    }

    public static func write(_ value: SidebarItem, into buf: inout [UInt8]) {
        FfiConverterString.write(value.name, into: &buf)
        FfiConverterTypeRoomEnvelope.write(value.room, into: &buf)
        FfiConverterBool.write(value.isFavorite, into: &buf)
        FfiConverterBool.write(value.hasDraft, into: &buf)
        FfiConverterUInt32.write(value.unreadCount, into: &buf)
        FfiConverterUInt32.write(value.mentionsCount, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSidebarItem_lift(_ buf: RustBuffer) throws -> SidebarItem {
    return try FfiConverterTypeSidebarItem.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSidebarItem_lower(_ value: SidebarItem) -> RustBuffer {
    return FfiConverterTypeSidebarItem.lower(value)
}


public struct Thumbnail {
    public var url: Url
    public var mediaType: Mime
    public var width: UInt32?
    public var height: UInt32?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(url: Url, mediaType: Mime, width: UInt32?, height: UInt32?) {
        self.url = url
        self.mediaType = mediaType
        self.width = width
        self.height = height
    }
}

#if compiler(>=6)
extension Thumbnail: Sendable {}
#endif


extension Thumbnail: Equatable, Hashable {
    public static func ==(lhs: Thumbnail, rhs: Thumbnail) -> Bool {
        if lhs.url != rhs.url {
            return false
        }
        if lhs.mediaType != rhs.mediaType {
            return false
        }
        if lhs.width != rhs.width {
            return false
        }
        if lhs.height != rhs.height {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(url)
        hasher.combine(mediaType)
        hasher.combine(width)
        hasher.combine(height)
    }
}



#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeThumbnail: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Thumbnail {
        return
            try Thumbnail(
                url: FfiConverterTypeUrl.read(from: &buf), 
                mediaType: FfiConverterTypeMime.read(from: &buf), 
                width: FfiConverterOptionUInt32.read(from: &buf), 
                height: FfiConverterOptionUInt32.read(from: &buf)
        )
    }

    public static func write(_ value: Thumbnail, into buf: inout [UInt8]) {
        FfiConverterTypeUrl.write(value.url, into: &buf)
        FfiConverterTypeMime.write(value.mediaType, into: &buf)
        FfiConverterOptionUInt32.write(value.width, into: &buf)
        FfiConverterOptionUInt32.write(value.height, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeThumbnail_lift(_ buf: RustBuffer) throws -> Thumbnail {
    return try FfiConverterTypeThumbnail.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeThumbnail_lower(_ value: Thumbnail) -> RustBuffer {
    return FfiConverterTypeThumbnail.lower(value)
}


/**
 * A (half-open) range bounded inclusively below and exclusively above (start..end).
 *
 * The range start..end contains all values with start <= x < end. It is empty if start >= end.
 */
public struct UnicodeScalarRange {
    public var start: UnicodeScalarIndex
    public var end: UnicodeScalarIndex

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(start: UnicodeScalarIndex, end: UnicodeScalarIndex) {
        self.start = start
        self.end = end
    }
}

#if compiler(>=6)
extension UnicodeScalarRange: Sendable {}
#endif


extension UnicodeScalarRange: Equatable, Hashable {
    public static func ==(lhs: UnicodeScalarRange, rhs: UnicodeScalarRange) -> Bool {
        if lhs.start != rhs.start {
            return false
        }
        if lhs.end != rhs.end {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(start)
        hasher.combine(end)
    }
}



#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeUnicodeScalarRange: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> UnicodeScalarRange {
        return
            try UnicodeScalarRange(
                start: FfiConverterTypeUnicodeScalarIndex.read(from: &buf), 
                end: FfiConverterTypeUnicodeScalarIndex.read(from: &buf)
        )
    }

    public static func write(_ value: UnicodeScalarRange, into buf: inout [UInt8]) {
        FfiConverterTypeUnicodeScalarIndex.write(value.start, into: &buf)
        FfiConverterTypeUnicodeScalarIndex.write(value.end, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeUnicodeScalarRange_lift(_ buf: RustBuffer) throws -> UnicodeScalarRange {
    return try FfiConverterTypeUnicodeScalarRange.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeUnicodeScalarRange_lower(_ value: UnicodeScalarRange) -> RustBuffer {
    return FfiConverterTypeUnicodeScalarRange.lower(value)
}


public struct UploadHeader {
    public var name: String
    public var value: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(name: String, value: String) {
        self.name = name
        self.value = value
    }
}

#if compiler(>=6)
extension UploadHeader: Sendable {}
#endif


extension UploadHeader: Equatable, Hashable {
    public static func ==(lhs: UploadHeader, rhs: UploadHeader) -> Bool {
        if lhs.name != rhs.name {
            return false
        }
        if lhs.value != rhs.value {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(name)
        hasher.combine(value)
    }
}



#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeUploadHeader: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> UploadHeader {
        return
            try UploadHeader(
                name: FfiConverterString.read(from: &buf), 
                value: FfiConverterString.read(from: &buf)
        )
    }

    public static func write(_ value: UploadHeader, into buf: inout [UInt8]) {
        FfiConverterString.write(value.name, into: &buf)
        FfiConverterString.write(value.value, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeUploadHeader_lift(_ buf: RustBuffer) throws -> UploadHeader {
    return try FfiConverterTypeUploadHeader.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeUploadHeader_lower(_ value: UploadHeader) -> RustBuffer {
    return FfiConverterTypeUploadHeader.lower(value)
}


public struct UploadSlot {
    public var uploadUrl: Url
    public var uploadHeaders: [UploadHeader]
    public var downloadUrl: Url
    public var mediaType: String
    public var fileSize: UInt64
    public var fileName: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(uploadUrl: Url, uploadHeaders: [UploadHeader], downloadUrl: Url, mediaType: String, fileSize: UInt64, fileName: String) {
        self.uploadUrl = uploadUrl
        self.uploadHeaders = uploadHeaders
        self.downloadUrl = downloadUrl
        self.mediaType = mediaType
        self.fileSize = fileSize
        self.fileName = fileName
    }
}

#if compiler(>=6)
extension UploadSlot: Sendable {}
#endif


extension UploadSlot: Equatable, Hashable {
    public static func ==(lhs: UploadSlot, rhs: UploadSlot) -> Bool {
        if lhs.uploadUrl != rhs.uploadUrl {
            return false
        }
        if lhs.uploadHeaders != rhs.uploadHeaders {
            return false
        }
        if lhs.downloadUrl != rhs.downloadUrl {
            return false
        }
        if lhs.mediaType != rhs.mediaType {
            return false
        }
        if lhs.fileSize != rhs.fileSize {
            return false
        }
        if lhs.fileName != rhs.fileName {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(uploadUrl)
        hasher.combine(uploadHeaders)
        hasher.combine(downloadUrl)
        hasher.combine(mediaType)
        hasher.combine(fileSize)
        hasher.combine(fileName)
    }
}



#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeUploadSlot: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> UploadSlot {
        return
            try UploadSlot(
                uploadUrl: FfiConverterTypeUrl.read(from: &buf), 
                uploadHeaders: FfiConverterSequenceTypeUploadHeader.read(from: &buf), 
                downloadUrl: FfiConverterTypeUrl.read(from: &buf), 
                mediaType: FfiConverterString.read(from: &buf), 
                fileSize: FfiConverterUInt64.read(from: &buf), 
                fileName: FfiConverterString.read(from: &buf)
        )
    }

    public static func write(_ value: UploadSlot, into buf: inout [UInt8]) {
        FfiConverterTypeUrl.write(value.uploadUrl, into: &buf)
        FfiConverterSequenceTypeUploadHeader.write(value.uploadHeaders, into: &buf)
        FfiConverterTypeUrl.write(value.downloadUrl, into: &buf)
        FfiConverterString.write(value.mediaType, into: &buf)
        FfiConverterUInt64.write(value.fileSize, into: &buf)
        FfiConverterString.write(value.fileName, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeUploadSlot_lift(_ buf: RustBuffer) throws -> UploadSlot {
    return try FfiConverterTypeUploadSlot.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeUploadSlot_lower(_ value: UploadSlot) -> RustBuffer {
    return FfiConverterTypeUploadSlot.lower(value)
}


public struct UserBasicInfo {
    public var id: UserId
    public var name: String
    public var avatar: Avatar?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(id: UserId, name: String, avatar: Avatar?) {
        self.id = id
        self.name = name
        self.avatar = avatar
    }
}

#if compiler(>=6)
extension UserBasicInfo: Sendable {}
#endif



#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeUserBasicInfo: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> UserBasicInfo {
        return
            try UserBasicInfo(
                id: FfiConverterTypeUserId.read(from: &buf), 
                name: FfiConverterString.read(from: &buf), 
                avatar: FfiConverterOptionTypeAvatar.read(from: &buf)
        )
    }

    public static func write(_ value: UserBasicInfo, into buf: inout [UInt8]) {
        FfiConverterTypeUserId.write(value.id, into: &buf)
        FfiConverterString.write(value.name, into: &buf)
        FfiConverterOptionTypeAvatar.write(value.avatar, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeUserBasicInfo_lift(_ buf: RustBuffer) throws -> UserBasicInfo {
    return try FfiConverterTypeUserBasicInfo.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeUserBasicInfo_lower(_ value: UserBasicInfo) -> RustBuffer {
    return FfiConverterTypeUserBasicInfo.lower(value)
}


public struct UserMetadata {
    public var localTime: DateTimeFixed?
    public var lastActivity: LastActivity?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(localTime: DateTimeFixed?, lastActivity: LastActivity?) {
        self.localTime = localTime
        self.lastActivity = lastActivity
    }
}

#if compiler(>=6)
extension UserMetadata: Sendable {}
#endif


extension UserMetadata: Equatable, Hashable {
    public static func ==(lhs: UserMetadata, rhs: UserMetadata) -> Bool {
        if lhs.localTime != rhs.localTime {
            return false
        }
        if lhs.lastActivity != rhs.lastActivity {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(localTime)
        hasher.combine(lastActivity)
    }
}



#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeUserMetadata: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> UserMetadata {
        return
            try UserMetadata(
                localTime: FfiConverterOptionTypeDateTimeFixed.read(from: &buf), 
                lastActivity: FfiConverterOptionTypeLastActivity.read(from: &buf)
        )
    }

    public static func write(_ value: UserMetadata, into buf: inout [UInt8]) {
        FfiConverterOptionTypeDateTimeFixed.write(value.localTime, into: &buf)
        FfiConverterOptionTypeLastActivity.write(value.lastActivity, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeUserMetadata_lift(_ buf: RustBuffer) throws -> UserMetadata {
    return try FfiConverterTypeUserMetadata.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeUserMetadata_lower(_ value: UserMetadata) -> RustBuffer {
    return FfiConverterTypeUserMetadata.lower(value)
}


public struct UserProfile {
    public var firstName: String?
    public var lastName: String?
    public var nickname: String?
    public var org: String?
    public var role: String?
    public var title: String?
    public var email: String?
    public var tel: String?
    public var url: Url?
    public var address: Address?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(firstName: String?, lastName: String?, nickname: String?, org: String?, role: String?, title: String?, email: String?, tel: String?, url: Url?, address: Address?) {
        self.firstName = firstName
        self.lastName = lastName
        self.nickname = nickname
        self.org = org
        self.role = role
        self.title = title
        self.email = email
        self.tel = tel
        self.url = url
        self.address = address
    }
}

#if compiler(>=6)
extension UserProfile: Sendable {}
#endif


extension UserProfile: Equatable, Hashable {
    public static func ==(lhs: UserProfile, rhs: UserProfile) -> Bool {
        if lhs.firstName != rhs.firstName {
            return false
        }
        if lhs.lastName != rhs.lastName {
            return false
        }
        if lhs.nickname != rhs.nickname {
            return false
        }
        if lhs.org != rhs.org {
            return false
        }
        if lhs.role != rhs.role {
            return false
        }
        if lhs.title != rhs.title {
            return false
        }
        if lhs.email != rhs.email {
            return false
        }
        if lhs.tel != rhs.tel {
            return false
        }
        if lhs.url != rhs.url {
            return false
        }
        if lhs.address != rhs.address {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(firstName)
        hasher.combine(lastName)
        hasher.combine(nickname)
        hasher.combine(org)
        hasher.combine(role)
        hasher.combine(title)
        hasher.combine(email)
        hasher.combine(tel)
        hasher.combine(url)
        hasher.combine(address)
    }
}



#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeUserProfile: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> UserProfile {
        return
            try UserProfile(
                firstName: FfiConverterOptionString.read(from: &buf), 
                lastName: FfiConverterOptionString.read(from: &buf), 
                nickname: FfiConverterOptionString.read(from: &buf), 
                org: FfiConverterOptionString.read(from: &buf), 
                role: FfiConverterOptionString.read(from: &buf), 
                title: FfiConverterOptionString.read(from: &buf), 
                email: FfiConverterOptionString.read(from: &buf), 
                tel: FfiConverterOptionString.read(from: &buf), 
                url: FfiConverterOptionTypeUrl.read(from: &buf), 
                address: FfiConverterOptionTypeAddress.read(from: &buf)
        )
    }

    public static func write(_ value: UserProfile, into buf: inout [UInt8]) {
        FfiConverterOptionString.write(value.firstName, into: &buf)
        FfiConverterOptionString.write(value.lastName, into: &buf)
        FfiConverterOptionString.write(value.nickname, into: &buf)
        FfiConverterOptionString.write(value.org, into: &buf)
        FfiConverterOptionString.write(value.role, into: &buf)
        FfiConverterOptionString.write(value.title, into: &buf)
        FfiConverterOptionString.write(value.email, into: &buf)
        FfiConverterOptionString.write(value.tel, into: &buf)
        FfiConverterOptionTypeUrl.write(value.url, into: &buf)
        FfiConverterOptionTypeAddress.write(value.address, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeUserProfile_lift(_ buf: RustBuffer) throws -> UserProfile {
    return try FfiConverterTypeUserProfile.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeUserProfile_lower(_ value: UserProfile) -> RustBuffer {
    return FfiConverterTypeUserProfile.lower(value)
}


public struct UserStatus {
    public var emoji: String
    public var status: String?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(emoji: String, status: String?) {
        self.emoji = emoji
        self.status = status
    }
}

#if compiler(>=6)
extension UserStatus: Sendable {}
#endif


extension UserStatus: Equatable, Hashable {
    public static func ==(lhs: UserStatus, rhs: UserStatus) -> Bool {
        if lhs.emoji != rhs.emoji {
            return false
        }
        if lhs.status != rhs.status {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(emoji)
        hasher.combine(status)
    }
}



#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeUserStatus: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> UserStatus {
        return
            try UserStatus(
                emoji: FfiConverterString.read(from: &buf), 
                status: FfiConverterOptionString.read(from: &buf)
        )
    }

    public static func write(_ value: UserStatus, into buf: inout [UInt8]) {
        FfiConverterString.write(value.emoji, into: &buf)
        FfiConverterOptionString.write(value.status, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeUserStatus_lift(_ buf: RustBuffer) throws -> UserStatus {
    return try FfiConverterTypeUserStatus.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeUserStatus_lower(_ value: UserStatus) -> RustBuffer {
    return FfiConverterTypeUserStatus.lower(value)
}


public struct WorkspaceIcon {
    public var id: AvatarId
    public var owner: ServerId
    public var mimeType: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(id: AvatarId, owner: ServerId, mimeType: String) {
        self.id = id
        self.owner = owner
        self.mimeType = mimeType
    }
}

#if compiler(>=6)
extension WorkspaceIcon: Sendable {}
#endif


extension WorkspaceIcon: Equatable, Hashable {
    public static func ==(lhs: WorkspaceIcon, rhs: WorkspaceIcon) -> Bool {
        if lhs.id != rhs.id {
            return false
        }
        if lhs.owner != rhs.owner {
            return false
        }
        if lhs.mimeType != rhs.mimeType {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(id)
        hasher.combine(owner)
        hasher.combine(mimeType)
    }
}



#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeWorkspaceIcon: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> WorkspaceIcon {
        return
            try WorkspaceIcon(
                id: FfiConverterTypeAvatarId.read(from: &buf), 
                owner: FfiConverterTypeServerId.read(from: &buf), 
                mimeType: FfiConverterString.read(from: &buf)
        )
    }

    public static func write(_ value: WorkspaceIcon, into buf: inout [UInt8]) {
        FfiConverterTypeAvatarId.write(value.id, into: &buf)
        FfiConverterTypeServerId.write(value.owner, into: &buf)
        FfiConverterString.write(value.mimeType, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeWorkspaceIcon_lift(_ buf: RustBuffer) throws -> WorkspaceIcon {
    return try FfiConverterTypeWorkspaceIcon.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeWorkspaceIcon_lower(_ value: WorkspaceIcon) -> RustBuffer {
    return FfiConverterTypeWorkspaceIcon.lower(value)
}


public struct WorkspaceInfo {
    public var name: String
    public var icon: WorkspaceIcon?
    public var accentColor: String?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(name: String, icon: WorkspaceIcon?, accentColor: String?) {
        self.name = name
        self.icon = icon
        self.accentColor = accentColor
    }
}

#if compiler(>=6)
extension WorkspaceInfo: Sendable {}
#endif


extension WorkspaceInfo: Equatable, Hashable {
    public static func ==(lhs: WorkspaceInfo, rhs: WorkspaceInfo) -> Bool {
        if lhs.name != rhs.name {
            return false
        }
        if lhs.icon != rhs.icon {
            return false
        }
        if lhs.accentColor != rhs.accentColor {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(name)
        hasher.combine(icon)
        hasher.combine(accentColor)
    }
}



#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeWorkspaceInfo: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> WorkspaceInfo {
        return
            try WorkspaceInfo(
                name: FfiConverterString.read(from: &buf), 
                icon: FfiConverterOptionTypeWorkspaceIcon.read(from: &buf), 
                accentColor: FfiConverterOptionString.read(from: &buf)
        )
    }

    public static func write(_ value: WorkspaceInfo, into buf: inout [UInt8]) {
        FfiConverterString.write(value.name, into: &buf)
        FfiConverterOptionTypeWorkspaceIcon.write(value.icon, into: &buf)
        FfiConverterOptionString.write(value.accentColor, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeWorkspaceInfo_lift(_ buf: RustBuffer) throws -> WorkspaceInfo {
    return try FfiConverterTypeWorkspaceInfo.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeWorkspaceInfo_lower(_ value: WorkspaceInfo) -> RustBuffer {
    return FfiConverterTypeWorkspaceInfo.lower(value)
}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum AttachmentType {
    
    case audio(duration: UInt64?
    )
    case image(thumbnail: Thumbnail?
    )
    case video(duration: UInt64?, thumbnail: Thumbnail?
    )
    case file
}


#if compiler(>=6)
extension AttachmentType: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeAttachmentType: FfiConverterRustBuffer {
    typealias SwiftType = AttachmentType

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> AttachmentType {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .audio(duration: try FfiConverterOptionUInt64.read(from: &buf)
        )
        
        case 2: return .image(thumbnail: try FfiConverterOptionTypeThumbnail.read(from: &buf)
        )
        
        case 3: return .video(duration: try FfiConverterOptionUInt64.read(from: &buf), thumbnail: try FfiConverterOptionTypeThumbnail.read(from: &buf)
        )
        
        case 4: return .file
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: AttachmentType, into buf: inout [UInt8]) {
        switch value {
        
        
        case let .audio(duration):
            writeInt(&buf, Int32(1))
            FfiConverterOptionUInt64.write(duration, into: &buf)
            
        
        case let .image(thumbnail):
            writeInt(&buf, Int32(2))
            FfiConverterOptionTypeThumbnail.write(thumbnail, into: &buf)
            
        
        case let .video(duration,thumbnail):
            writeInt(&buf, Int32(3))
            FfiConverterOptionUInt64.write(duration, into: &buf)
            FfiConverterOptionTypeThumbnail.write(thumbnail, into: &buf)
            
        
        case .file:
            writeInt(&buf, Int32(4))
        
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeAttachmentType_lift(_ buf: RustBuffer) throws -> AttachmentType {
    return try FfiConverterTypeAttachmentType.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeAttachmentType_lower(_ value: AttachmentType) -> RustBuffer {
    return FfiConverterTypeAttachmentType.lower(value)
}


extension AttachmentType: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum Availability {
    
    case available
    case unavailable
    case doNotDisturb
    case away
    case invisible
}


#if compiler(>=6)
extension Availability: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeAvailability: FfiConverterRustBuffer {
    typealias SwiftType = Availability

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Availability {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .available
        
        case 2: return .unavailable
        
        case 3: return .doNotDisturb
        
        case 4: return .away
        
        case 5: return .invisible
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: Availability, into buf: inout [UInt8]) {
        switch value {
        
        
        case .available:
            writeInt(&buf, Int32(1))
        
        
        case .unavailable:
            writeInt(&buf, Int32(2))
        
        
        case .doNotDisturb:
            writeInt(&buf, Int32(3))
        
        
        case .away:
            writeInt(&buf, Int32(4))
        
        
        case .invisible:
            writeInt(&buf, Int32(5))
        
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeAvailability_lift(_ buf: RustBuffer) throws -> Availability {
    return try FfiConverterTypeAvailability.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeAvailability_lower(_ value: Availability) -> RustBuffer {
    return FfiConverterTypeAvailability.lower(value)
}


extension Availability: Equatable, Hashable {}




public enum ClientError: Swift.Error {

    
    
    case Generic(msg: String
    )
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeClientError: FfiConverterRustBuffer {
    typealias SwiftType = ClientError

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ClientError {
        let variant: Int32 = try readInt(&buf)
        switch variant {

        

        
        case 1: return .Generic(
            msg: try FfiConverterString.read(from: &buf)
            )

         default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: ClientError, into buf: inout [UInt8]) {
        switch value {

        

        
        
        case let .Generic(msg):
            writeInt(&buf, Int32(1))
            FfiConverterString.write(msg, into: &buf)
            
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeClientError_lift(_ buf: RustBuffer) throws -> ClientError {
    return try FfiConverterTypeClientError.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeClientError_lower(_ value: ClientError) -> RustBuffer {
    return FfiConverterTypeClientError.lower(value)
}


extension ClientError: Equatable, Hashable {}



extension ClientError: Foundation.LocalizedError {
    public var errorDescription: String? {
        String(reflecting: self)
    }
}


// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum ClientEvent {
    
    /**
     * The status of the connection has changed.
     */
    case connectionStatusChanged(event: ConnectionEvent
    )
    /**
     * The contents of the sidebar have changed.
     */
    case sidebarChanged
    /**
     * Infos about a contact have changed.
     */
    case contactChanged(ids: [UserId]
    )
    /**
     * Contacts were added, removed or their subscription status changed.
     */
    case contactListChanged
    /**
     * A presence subscription request was either added or removed.
     */
    case presenceSubRequestsChanged
    /**
     * A user was blocked or unblocked.
     */
    case blockListChanged
    /**
     * The avatar of a user changed.
     */
    case avatarChanged(ids: [UserId]
    )
    /**
     * Infos related to the logged-in user have changed.
     */
    case accountInfoChanged
    /**
     * Infos related to the server/workspace have changed.
     */
    case workspaceInfoChanged
    /**
     * The avatar of the server/workspace has changed.
     */
    case workspaceIconChanged
    case roomChanged(room: RoomEnvelope, type: ClientRoomEventType
    )
}


#if compiler(>=6)
extension ClientEvent: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeClientEvent: FfiConverterRustBuffer {
    typealias SwiftType = ClientEvent

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ClientEvent {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .connectionStatusChanged(event: try FfiConverterTypeConnectionEvent.read(from: &buf)
        )
        
        case 2: return .sidebarChanged
        
        case 3: return .contactChanged(ids: try FfiConverterSequenceTypeUserId.read(from: &buf)
        )
        
        case 4: return .contactListChanged
        
        case 5: return .presenceSubRequestsChanged
        
        case 6: return .blockListChanged
        
        case 7: return .avatarChanged(ids: try FfiConverterSequenceTypeUserId.read(from: &buf)
        )
        
        case 8: return .accountInfoChanged
        
        case 9: return .workspaceInfoChanged
        
        case 10: return .workspaceIconChanged
        
        case 11: return .roomChanged(room: try FfiConverterTypeRoomEnvelope.read(from: &buf), type: try FfiConverterTypeClientRoomEventType.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: ClientEvent, into buf: inout [UInt8]) {
        switch value {
        
        
        case let .connectionStatusChanged(event):
            writeInt(&buf, Int32(1))
            FfiConverterTypeConnectionEvent.write(event, into: &buf)
            
        
        case .sidebarChanged:
            writeInt(&buf, Int32(2))
        
        
        case let .contactChanged(ids):
            writeInt(&buf, Int32(3))
            FfiConverterSequenceTypeUserId.write(ids, into: &buf)
            
        
        case .contactListChanged:
            writeInt(&buf, Int32(4))
        
        
        case .presenceSubRequestsChanged:
            writeInt(&buf, Int32(5))
        
        
        case .blockListChanged:
            writeInt(&buf, Int32(6))
        
        
        case let .avatarChanged(ids):
            writeInt(&buf, Int32(7))
            FfiConverterSequenceTypeUserId.write(ids, into: &buf)
            
        
        case .accountInfoChanged:
            writeInt(&buf, Int32(8))
        
        
        case .workspaceInfoChanged:
            writeInt(&buf, Int32(9))
        
        
        case .workspaceIconChanged:
            writeInt(&buf, Int32(10))
        
        
        case let .roomChanged(room,type):
            writeInt(&buf, Int32(11))
            FfiConverterTypeRoomEnvelope.write(room, into: &buf)
            FfiConverterTypeClientRoomEventType.write(type, into: &buf)
            
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeClientEvent_lift(_ buf: RustBuffer) throws -> ClientEvent {
    return try FfiConverterTypeClientEvent.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeClientEvent_lower(_ value: ClientEvent) -> RustBuffer {
    return FfiConverterTypeClientEvent.lower(value)
}




// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum ClientRoomEventType {
    
    /**
     * One or many messages were either received or sent.
     */
    case messagesAppended(messageIds: [MessageId]
    )
    /**
     * One or many messages were received that affected earlier messages (e.g. a reaction).
     */
    case messagesUpdated(messageIds: [MessageId]
    )
    /**
     * A message was deleted.
     */
    case messagesDeleted(messageIds: [MessageId]
    )
    /**
     * The room went offline, came back online and contains new messages.
     */
    case messagesNeedReload
    /**
     * Attributes changed like name or topic.
     */
    case attributesChanged
    /**
     * The list of participants has changed.
     */
    case participantsChanged
    /**
     * A user in `conversation` started or stopped typing.
     */
    case composingUsersChanged
}


#if compiler(>=6)
extension ClientRoomEventType: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeClientRoomEventType: FfiConverterRustBuffer {
    typealias SwiftType = ClientRoomEventType

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ClientRoomEventType {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .messagesAppended(messageIds: try FfiConverterSequenceTypeMessageId.read(from: &buf)
        )
        
        case 2: return .messagesUpdated(messageIds: try FfiConverterSequenceTypeMessageId.read(from: &buf)
        )
        
        case 3: return .messagesDeleted(messageIds: try FfiConverterSequenceTypeMessageId.read(from: &buf)
        )
        
        case 4: return .messagesNeedReload
        
        case 5: return .attributesChanged
        
        case 6: return .participantsChanged
        
        case 7: return .composingUsersChanged
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: ClientRoomEventType, into buf: inout [UInt8]) {
        switch value {
        
        
        case let .messagesAppended(messageIds):
            writeInt(&buf, Int32(1))
            FfiConverterSequenceTypeMessageId.write(messageIds, into: &buf)
            
        
        case let .messagesUpdated(messageIds):
            writeInt(&buf, Int32(2))
            FfiConverterSequenceTypeMessageId.write(messageIds, into: &buf)
            
        
        case let .messagesDeleted(messageIds):
            writeInt(&buf, Int32(3))
            FfiConverterSequenceTypeMessageId.write(messageIds, into: &buf)
            
        
        case .messagesNeedReload:
            writeInt(&buf, Int32(4))
        
        
        case .attributesChanged:
            writeInt(&buf, Int32(5))
        
        
        case .participantsChanged:
            writeInt(&buf, Int32(6))
        
        
        case .composingUsersChanged:
            writeInt(&buf, Int32(7))
        
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeClientRoomEventType_lift(_ buf: RustBuffer) throws -> ClientRoomEventType {
    return try FfiConverterTypeClientRoomEventType.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeClientRoomEventType_lower(_ value: ClientRoomEventType) -> RustBuffer {
    return FfiConverterTypeClientRoomEventType.lower(value)
}


extension ClientRoomEventType: Equatable, Hashable {}




public enum ConnectionError: Swift.Error {

    
    
    case TimedOut
    case InvalidCredentials
    case Generic(msg: String
    )
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeConnectionError: FfiConverterRustBuffer {
    typealias SwiftType = ConnectionError

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ConnectionError {
        let variant: Int32 = try readInt(&buf)
        switch variant {

        

        
        case 1: return .TimedOut
        case 2: return .InvalidCredentials
        case 3: return .Generic(
            msg: try FfiConverterString.read(from: &buf)
            )

         default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: ConnectionError, into buf: inout [UInt8]) {
        switch value {

        

        
        
        case .TimedOut:
            writeInt(&buf, Int32(1))
        
        
        case .InvalidCredentials:
            writeInt(&buf, Int32(2))
        
        
        case let .Generic(msg):
            writeInt(&buf, Int32(3))
            FfiConverterString.write(msg, into: &buf)
            
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeConnectionError_lift(_ buf: RustBuffer) throws -> ConnectionError {
    return try FfiConverterTypeConnectionError.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeConnectionError_lower(_ value: ConnectionError) -> RustBuffer {
    return FfiConverterTypeConnectionError.lower(value)
}


extension ConnectionError: Equatable, Hashable {}



extension ConnectionError: Foundation.LocalizedError {
    public var errorDescription: String? {
        String(reflecting: self)
    }
}


// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum ConnectionEvent {
    
    case connect
    case disconnect(error: ConnectionError?
    )
}


#if compiler(>=6)
extension ConnectionEvent: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeConnectionEvent: FfiConverterRustBuffer {
    typealias SwiftType = ConnectionEvent

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ConnectionEvent {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .connect
        
        case 2: return .disconnect(error: try FfiConverterOptionTypeConnectionError.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: ConnectionEvent, into buf: inout [UInt8]) {
        switch value {
        
        
        case .connect:
            writeInt(&buf, Int32(1))
        
        
        case let .disconnect(error):
            writeInt(&buf, Int32(2))
            FfiConverterOptionTypeConnectionError.write(error, into: &buf)
            
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeConnectionEvent_lift(_ buf: RustBuffer) throws -> ConnectionEvent {
    return try FfiConverterTypeConnectionEvent.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeConnectionEvent_lower(_ value: ConnectionEvent) -> RustBuffer {
    return FfiConverterTypeConnectionEvent.lower(value)
}


extension ConnectionEvent: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum Group {
    
    case team
    case other
}


#if compiler(>=6)
extension Group: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeGroup: FfiConverterRustBuffer {
    typealias SwiftType = Group

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Group {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .team
        
        case 2: return .other
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: Group, into buf: inout [UInt8]) {
        switch value {
        
        
        case .team:
            writeInt(&buf, Int32(1))
        
        
        case .other:
            writeInt(&buf, Int32(2))
        
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeGroup_lift(_ buf: RustBuffer) throws -> Group {
    return try FfiConverterTypeGroup.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeGroup_lower(_ value: Group) -> RustBuffer {
    return FfiConverterTypeGroup.lower(value)
}


extension Group: Equatable, Hashable {}




public enum JidParseError: Swift.Error {

    
    
    /**
     * Happens when the node is empty, that is the string starts with a @.
     */
    case NodeEmpty
    /**
     * Happens when there is no domain, that is either the string is empty,
     * starts with a /, or contains the @/ sequence.
     */
    case DomainEmpty
    /**
     * Happens when the resource is empty, that is the string ends with a /.
     */
    case ResourceEmpty
    /**
     * Happens when the localpart is longer than 1023 bytes.
     */
    case NodeTooLong
    /**
     * Happens when the domain is longer than 1023 bytes.
     */
    case DomainTooLong
    /**
     * Happens when the resource is longer than 1023 bytes.
     */
    case ResourceTooLong
    /**
     * Happens when the localpart is invalid according to nodeprep.
     */
    case NodePrep
    /**
     * Happens when the domain is invalid according to nameprep.
     */
    case NamePrep
    /**
     * Happens when the resource is invalid according to resourceprep.
     */
    case ResourcePrep
    /**
     * Happens when there is no resource, that is string contains no /.
     */
    case ResourceMissingInFullJid
    /**
     * Happens when parsing a bare JID and there is a resource.
     */
    case ResourceInBareJid
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeJidParseError: FfiConverterRustBuffer {
    typealias SwiftType = JidParseError

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> JidParseError {
        let variant: Int32 = try readInt(&buf)
        switch variant {

        

        
        case 1: return .NodeEmpty
        case 2: return .DomainEmpty
        case 3: return .ResourceEmpty
        case 4: return .NodeTooLong
        case 5: return .DomainTooLong
        case 6: return .ResourceTooLong
        case 7: return .NodePrep
        case 8: return .NamePrep
        case 9: return .ResourcePrep
        case 10: return .ResourceMissingInFullJid
        case 11: return .ResourceInBareJid

         default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: JidParseError, into buf: inout [UInt8]) {
        switch value {

        

        
        
        case .NodeEmpty:
            writeInt(&buf, Int32(1))
        
        
        case .DomainEmpty:
            writeInt(&buf, Int32(2))
        
        
        case .ResourceEmpty:
            writeInt(&buf, Int32(3))
        
        
        case .NodeTooLong:
            writeInt(&buf, Int32(4))
        
        
        case .DomainTooLong:
            writeInt(&buf, Int32(5))
        
        
        case .ResourceTooLong:
            writeInt(&buf, Int32(6))
        
        
        case .NodePrep:
            writeInt(&buf, Int32(7))
        
        
        case .NamePrep:
            writeInt(&buf, Int32(8))
        
        
        case .ResourcePrep:
            writeInt(&buf, Int32(9))
        
        
        case .ResourceMissingInFullJid:
            writeInt(&buf, Int32(10))
        
        
        case .ResourceInBareJid:
            writeInt(&buf, Int32(11))
        
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeJidParseError_lift(_ buf: RustBuffer) throws -> JidParseError {
    return try FfiConverterTypeJidParseError.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeJidParseError_lower(_ value: JidParseError) -> RustBuffer {
    return FfiConverterTypeJidParseError.lower(value)
}


extension JidParseError: Equatable, Hashable {}



extension JidParseError: Foundation.LocalizedError {
    public var errorDescription: String? {
        String(reflecting: self)
    }
}


// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum ParticipantId {
    
    case user(UserId
    )
    case occupant(OccupantId
    )
}


#if compiler(>=6)
extension ParticipantId: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeParticipantId: FfiConverterRustBuffer {
    typealias SwiftType = ParticipantId

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ParticipantId {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .user(try FfiConverterTypeUserId.read(from: &buf)
        )
        
        case 2: return .occupant(try FfiConverterTypeOccupantId.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: ParticipantId, into buf: inout [UInt8]) {
        switch value {
        
        
        case let .user(v1):
            writeInt(&buf, Int32(1))
            FfiConverterTypeUserId.write(v1, into: &buf)
            
        
        case let .occupant(v1):
            writeInt(&buf, Int32(2))
            FfiConverterTypeOccupantId.write(v1, into: &buf)
            
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeParticipantId_lift(_ buf: RustBuffer) throws -> ParticipantId {
    return try FfiConverterTypeParticipantId.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeParticipantId_lower(_ value: ParticipantId) -> RustBuffer {
    return FfiConverterTypeParticipantId.lower(value)
}


extension ParticipantId: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum RoomAffiliation {
    
    case outcast
    case none
    case member
    case admin
    case owner
}


#if compiler(>=6)
extension RoomAffiliation: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeRoomAffiliation: FfiConverterRustBuffer {
    typealias SwiftType = RoomAffiliation

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> RoomAffiliation {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .outcast
        
        case 2: return .none
        
        case 3: return .member
        
        case 4: return .admin
        
        case 5: return .owner
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: RoomAffiliation, into buf: inout [UInt8]) {
        switch value {
        
        
        case .outcast:
            writeInt(&buf, Int32(1))
        
        
        case .none:
            writeInt(&buf, Int32(2))
        
        
        case .member:
            writeInt(&buf, Int32(3))
        
        
        case .admin:
            writeInt(&buf, Int32(4))
        
        
        case .owner:
            writeInt(&buf, Int32(5))
        
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeRoomAffiliation_lift(_ buf: RustBuffer) throws -> RoomAffiliation {
    return try FfiConverterTypeRoomAffiliation.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeRoomAffiliation_lower(_ value: RoomAffiliation) -> RustBuffer {
    return FfiConverterTypeRoomAffiliation.lower(value)
}


extension RoomAffiliation: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum RoomEnvelope {
    
    case directMessage(RoomDirectMessage
    )
    case group(RoomGroup
    )
    case privateChannel(RoomPrivateChannel
    )
    case publicChannel(RoomPublicChannel
    )
    case generic(RoomGeneric
    )
}


#if compiler(>=6)
extension RoomEnvelope: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeRoomEnvelope: FfiConverterRustBuffer {
    typealias SwiftType = RoomEnvelope

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> RoomEnvelope {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .directMessage(try FfiConverterTypeRoomDirectMessage.read(from: &buf)
        )
        
        case 2: return .group(try FfiConverterTypeRoomGroup.read(from: &buf)
        )
        
        case 3: return .privateChannel(try FfiConverterTypeRoomPrivateChannel.read(from: &buf)
        )
        
        case 4: return .publicChannel(try FfiConverterTypeRoomPublicChannel.read(from: &buf)
        )
        
        case 5: return .generic(try FfiConverterTypeRoomGeneric.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: RoomEnvelope, into buf: inout [UInt8]) {
        switch value {
        
        
        case let .directMessage(v1):
            writeInt(&buf, Int32(1))
            FfiConverterTypeRoomDirectMessage.write(v1, into: &buf)
            
        
        case let .group(v1):
            writeInt(&buf, Int32(2))
            FfiConverterTypeRoomGroup.write(v1, into: &buf)
            
        
        case let .privateChannel(v1):
            writeInt(&buf, Int32(3))
            FfiConverterTypeRoomPrivateChannel.write(v1, into: &buf)
            
        
        case let .publicChannel(v1):
            writeInt(&buf, Int32(4))
            FfiConverterTypeRoomPublicChannel.write(v1, into: &buf)
            
        
        case let .generic(v1):
            writeInt(&buf, Int32(5))
            FfiConverterTypeRoomGeneric.write(v1, into: &buf)
            
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeRoomEnvelope_lift(_ buf: RustBuffer) throws -> RoomEnvelope {
    return try FfiConverterTypeRoomEnvelope.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeRoomEnvelope_lower(_ value: RoomEnvelope) -> RustBuffer {
    return FfiConverterTypeRoomEnvelope.lower(value)
}




// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum RoomId {
    
    case user(UserId
    )
    case muc(MucId
    )
}


#if compiler(>=6)
extension RoomId: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeRoomId: FfiConverterRustBuffer {
    typealias SwiftType = RoomId

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> RoomId {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .user(try FfiConverterTypeUserId.read(from: &buf)
        )
        
        case 2: return .muc(try FfiConverterTypeMucId.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: RoomId, into buf: inout [UInt8]) {
        switch value {
        
        
        case let .user(v1):
            writeInt(&buf, Int32(1))
            FfiConverterTypeUserId.write(v1, into: &buf)
            
        
        case let .muc(v1):
            writeInt(&buf, Int32(2))
            FfiConverterTypeMucId.write(v1, into: &buf)
            
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeRoomId_lift(_ buf: RustBuffer) throws -> RoomId {
    return try FfiConverterTypeRoomId.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeRoomId_lower(_ value: RoomId) -> RustBuffer {
    return FfiConverterTypeRoomId.lower(value)
}


extension RoomId: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum RoomState {
    
    case connecting
    case connected
    case disconnected(error: String?, canRetry: Bool
    )
}


#if compiler(>=6)
extension RoomState: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeRoomState: FfiConverterRustBuffer {
    typealias SwiftType = RoomState

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> RoomState {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .connecting
        
        case 2: return .connected
        
        case 3: return .disconnected(error: try FfiConverterOptionString.read(from: &buf), canRetry: try FfiConverterBool.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: RoomState, into buf: inout [UInt8]) {
        switch value {
        
        
        case .connecting:
            writeInt(&buf, Int32(1))
        
        
        case .connected:
            writeInt(&buf, Int32(2))
        
        
        case let .disconnected(error,canRetry):
            writeInt(&buf, Int32(3))
            FfiConverterOptionString.write(error, into: &buf)
            FfiConverterBool.write(canRetry, into: &buf)
            
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeRoomState_lift(_ buf: RustBuffer) throws -> RoomState {
    return try FfiConverterTypeRoomState.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeRoomState_lower(_ value: RoomState) -> RustBuffer {
    return FfiConverterTypeRoomState.lower(value)
}


extension RoomState: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum RoomType {
    
    case directMessage
    case group
    case privateChannel
    case publicChannel
    case generic
}


#if compiler(>=6)
extension RoomType: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeRoomType: FfiConverterRustBuffer {
    typealias SwiftType = RoomType

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> RoomType {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .directMessage
        
        case 2: return .group
        
        case 3: return .privateChannel
        
        case 4: return .publicChannel
        
        case 5: return .generic
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: RoomType, into buf: inout [UInt8]) {
        switch value {
        
        
        case .directMessage:
            writeInt(&buf, Int32(1))
        
        
        case .group:
            writeInt(&buf, Int32(2))
        
        
        case .privateChannel:
            writeInt(&buf, Int32(3))
        
        
        case .publicChannel:
            writeInt(&buf, Int32(4))
        
        
        case .generic:
            writeInt(&buf, Int32(5))
        
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeRoomType_lift(_ buf: RustBuffer) throws -> RoomType {
    return try FfiConverterTypeRoomType.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeRoomType_lower(_ value: RoomType) -> RustBuffer {
    return FfiConverterTypeRoomType.lower(value)
}


extension RoomType: Equatable, Hashable {}



#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionUInt32: FfiConverterRustBuffer {
    typealias SwiftType = UInt32?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterUInt32.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterUInt32.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionUInt64: FfiConverterRustBuffer {
    typealias SwiftType = UInt64?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterUInt64.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterUInt64.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionString: FfiConverterRustBuffer {
    typealias SwiftType = String?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterString.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterString.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionTypeAvatar: FfiConverterRustBuffer {
    typealias SwiftType = Avatar?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeAvatar.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeAvatar.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionTypeClientDelegate: FfiConverterRustBuffer {
    typealias SwiftType = ClientDelegate?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeClientDelegate.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeClientDelegate.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionTypeAddress: FfiConverterRustBuffer {
    typealias SwiftType = Address?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeAddress.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeAddress.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionTypeClientConfig: FfiConverterRustBuffer {
    typealias SwiftType = ClientConfig?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeClientConfig.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeClientConfig.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionTypeJabberClient: FfiConverterRustBuffer {
    typealias SwiftType = JabberClient?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeJabberClient.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeJabberClient.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionTypeLastActivity: FfiConverterRustBuffer {
    typealias SwiftType = LastActivity?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeLastActivity.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeLastActivity.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionTypeReplyTo: FfiConverterRustBuffer {
    typealias SwiftType = ReplyTo?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeReplyTo.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeReplyTo.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionTypeSendMessageRequestBody: FfiConverterRustBuffer {
    typealias SwiftType = SendMessageRequestBody?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeSendMessageRequestBody.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeSendMessageRequestBody.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionTypeThumbnail: FfiConverterRustBuffer {
    typealias SwiftType = Thumbnail?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeThumbnail.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeThumbnail.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionTypeUnicodeScalarRange: FfiConverterRustBuffer {
    typealias SwiftType = UnicodeScalarRange?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeUnicodeScalarRange.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeUnicodeScalarRange.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionTypeUserProfile: FfiConverterRustBuffer {
    typealias SwiftType = UserProfile?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeUserProfile.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeUserProfile.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionTypeUserStatus: FfiConverterRustBuffer {
    typealias SwiftType = UserStatus?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeUserStatus.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeUserStatus.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionTypeWorkspaceIcon: FfiConverterRustBuffer {
    typealias SwiftType = WorkspaceIcon?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeWorkspaceIcon.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeWorkspaceIcon.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionTypeConnectionError: FfiConverterRustBuffer {
    typealias SwiftType = ConnectionError?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeConnectionError.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeConnectionError.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionTypeRoomId: FfiConverterRustBuffer {
    typealias SwiftType = RoomId?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeRoomId.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeRoomId.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionTypeDateTime: FfiConverterRustBuffer {
    typealias SwiftType = DateTime?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeDateTime.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeDateTime.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionTypeDateTimeFixed: FfiConverterRustBuffer {
    typealias SwiftType = DateTimeFixed?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeDateTimeFixed.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeDateTimeFixed.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionTypeMessageId: FfiConverterRustBuffer {
    typealias SwiftType = MessageId?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeMessageId.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeMessageId.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionTypeMime: FfiConverterRustBuffer {
    typealias SwiftType = Mime?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeMime.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeMime.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionTypePathBuf: FfiConverterRustBuffer {
    typealias SwiftType = PathBuf?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypePathBuf.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypePathBuf.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionTypeUrl: FfiConverterRustBuffer {
    typealias SwiftType = Url?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeUrl.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeUrl.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionTypeUserId: FfiConverterRustBuffer {
    typealias SwiftType = UserId?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeUserId.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeUserId.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceTypeAccountBookmark: FfiConverterRustBuffer {
    typealias SwiftType = [AccountBookmark]

    public static func write(_ value: [AccountBookmark], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeAccountBookmark.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [AccountBookmark] {
        let len: Int32 = try readInt(&buf)
        var seq = [AccountBookmark]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeAccountBookmark.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceTypeAttachment: FfiConverterRustBuffer {
    typealias SwiftType = [Attachment]

    public static func write(_ value: [Attachment], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeAttachment.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [Attachment] {
        let len: Int32 = try readInt(&buf)
        var seq = [Attachment]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeAttachment.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceTypeContact: FfiConverterRustBuffer {
    typealias SwiftType = [Contact]

    public static func write(_ value: [Contact], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeContact.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [Contact] {
        let len: Int32 = try readInt(&buf)
        var seq = [Contact]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeContact.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceTypeMention: FfiConverterRustBuffer {
    typealias SwiftType = [Mention]

    public static func write(_ value: [Mention], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeMention.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [Mention] {
        let len: Int32 = try readInt(&buf)
        var seq = [Mention]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeMention.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceTypeMessage: FfiConverterRustBuffer {
    typealias SwiftType = [Message]

    public static func write(_ value: [Message], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeMessage.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [Message] {
        let len: Int32 = try readInt(&buf)
        var seq = [Message]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeMessage.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceTypeMessageSender: FfiConverterRustBuffer {
    typealias SwiftType = [MessageSender]

    public static func write(_ value: [MessageSender], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeMessageSender.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [MessageSender] {
        let len: Int32 = try readInt(&buf)
        var seq = [MessageSender]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeMessageSender.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceTypeParticipantBasicInfo: FfiConverterRustBuffer {
    typealias SwiftType = [ParticipantBasicInfo]

    public static func write(_ value: [ParticipantBasicInfo], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeParticipantBasicInfo.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [ParticipantBasicInfo] {
        let len: Int32 = try readInt(&buf)
        var seq = [ParticipantBasicInfo]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeParticipantBasicInfo.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceTypeParticipantInfo: FfiConverterRustBuffer {
    typealias SwiftType = [ParticipantInfo]

    public static func write(_ value: [ParticipantInfo], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeParticipantInfo.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [ParticipantInfo] {
        let len: Int32 = try readInt(&buf)
        var seq = [ParticipantInfo]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeParticipantInfo.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceTypePresenceSubRequest: FfiConverterRustBuffer {
    typealias SwiftType = [PresenceSubRequest]

    public static func write(_ value: [PresenceSubRequest], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypePresenceSubRequest.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [PresenceSubRequest] {
        let len: Int32 = try readInt(&buf)
        var seq = [PresenceSubRequest]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypePresenceSubRequest.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceTypePublicRoomInfo: FfiConverterRustBuffer {
    typealias SwiftType = [PublicRoomInfo]

    public static func write(_ value: [PublicRoomInfo], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypePublicRoomInfo.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [PublicRoomInfo] {
        let len: Int32 = try readInt(&buf)
        var seq = [PublicRoomInfo]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypePublicRoomInfo.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceTypeReaction: FfiConverterRustBuffer {
    typealias SwiftType = [Reaction]

    public static func write(_ value: [Reaction], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeReaction.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [Reaction] {
        let len: Int32 = try readInt(&buf)
        var seq = [Reaction]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeReaction.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceTypeSidebarItem: FfiConverterRustBuffer {
    typealias SwiftType = [SidebarItem]

    public static func write(_ value: [SidebarItem], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeSidebarItem.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [SidebarItem] {
        let len: Int32 = try readInt(&buf)
        var seq = [SidebarItem]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeSidebarItem.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceTypeUploadHeader: FfiConverterRustBuffer {
    typealias SwiftType = [UploadHeader]

    public static func write(_ value: [UploadHeader], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeUploadHeader.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [UploadHeader] {
        let len: Int32 = try readInt(&buf)
        var seq = [UploadHeader]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeUploadHeader.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceTypeUserBasicInfo: FfiConverterRustBuffer {
    typealias SwiftType = [UserBasicInfo]

    public static func write(_ value: [UserBasicInfo], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeUserBasicInfo.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [UserBasicInfo] {
        let len: Int32 = try readInt(&buf)
        var seq = [UserBasicInfo]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeUserBasicInfo.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceTypeMessageId: FfiConverterRustBuffer {
    typealias SwiftType = [MessageId]

    public static func write(_ value: [MessageId], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeMessageId.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [MessageId] {
        let len: Int32 = try readInt(&buf)
        var seq = [MessageId]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeMessageId.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceTypeUserId: FfiConverterRustBuffer {
    typealias SwiftType = [UserId]

    public static func write(_ value: [UserId], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeUserId.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [UserId] {
        let len: Int32 = try readInt(&buf)
        var seq = [UserId]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeUserId.read(from: &buf))
        }
        return seq
    }
}


/**
 * Typealias from the type name used in the UDL file to the builtin type.  This
 * is needed because the UDL type name is used in function/method signatures.
 */
public typealias AvatarId = String

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeAvatarId: FfiConverter {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> AvatarId {
        return try FfiConverterString.read(from: &buf)
    }

    public static func write(_ value: AvatarId, into buf: inout [UInt8]) {
        return FfiConverterString.write(value, into: &buf)
    }

    public static func lift(_ value: RustBuffer) throws -> AvatarId {
        return try FfiConverterString.lift(value)
    }

    public static func lower(_ value: AvatarId) -> RustBuffer {
        return FfiConverterString.lower(value)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeAvatarId_lift(_ value: RustBuffer) throws -> AvatarId {
    return try FfiConverterTypeAvatarId.lift(value)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeAvatarId_lower(_ value: AvatarId) -> RustBuffer {
    return FfiConverterTypeAvatarId.lower(value)
}



/**
 * Typealias from the type name used in the UDL file to the builtin type.  This
 * is needed because the UDL type name is used in function/method signatures.
 */
public typealias BareJid = String

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeBareJid: FfiConverter {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> BareJid {
        return try FfiConverterString.read(from: &buf)
    }

    public static func write(_ value: BareJid, into buf: inout [UInt8]) {
        return FfiConverterString.write(value, into: &buf)
    }

    public static func lift(_ value: RustBuffer) throws -> BareJid {
        return try FfiConverterString.lift(value)
    }

    public static func lower(_ value: BareJid) -> RustBuffer {
        return FfiConverterString.lower(value)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeBareJid_lift(_ value: RustBuffer) throws -> BareJid {
    return try FfiConverterTypeBareJid.lift(value)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeBareJid_lower(_ value: BareJid) -> RustBuffer {
    return FfiConverterTypeBareJid.lower(value)
}





/**
 * Typealias from the type name used in the UDL file to the custom type.  This
 * is needed because the UDL type name is used in function/method signatures.
 */
public typealias DateTime = Date


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeDateTime: FfiConverter {

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> DateTime {
        let builtinValue = try FfiConverterInt64.read(from: &buf)
        return Date(timeIntervalSince1970: TimeInterval(builtinValue) / 1_000)
    }

    public static func write(_ value: DateTime, into buf: inout [UInt8]) {
        let builtinValue = Int64(value.timeIntervalSince1970 * 1_000)
        return FfiConverterInt64.write(builtinValue, into: &buf)
    }

    public static func lift(_ value: Int64) throws -> DateTime {
        let builtinValue = try FfiConverterInt64.lift(value)
        return Date(timeIntervalSince1970: TimeInterval(builtinValue) / 1_000)
    }

    public static func lower(_ value: DateTime) -> Int64 {
        let builtinValue = Int64(value.timeIntervalSince1970 * 1_000)
        return FfiConverterInt64.lower(builtinValue)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeDateTime_lift(_ value: Int64) throws -> DateTime {
    return try FfiConverterTypeDateTime.lift(value)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeDateTime_lower(_ value: DateTime) -> Int64 {
    return FfiConverterTypeDateTime.lower(value)
}



/**
 * Typealias from the type name used in the UDL file to the builtin type.  This
 * is needed because the UDL type name is used in function/method signatures.
 */
public typealias DateTimeFixed = Int64

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeDateTimeFixed: FfiConverter {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> DateTimeFixed {
        return try FfiConverterInt64.read(from: &buf)
    }

    public static func write(_ value: DateTimeFixed, into buf: inout [UInt8]) {
        return FfiConverterInt64.write(value, into: &buf)
    }

    public static func lift(_ value: Int64) throws -> DateTimeFixed {
        return try FfiConverterInt64.lift(value)
    }

    public static func lower(_ value: DateTimeFixed) -> Int64 {
        return FfiConverterInt64.lower(value)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeDateTimeFixed_lift(_ value: Int64) throws -> DateTimeFixed {
    return try FfiConverterTypeDateTimeFixed.lift(value)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeDateTimeFixed_lower(_ value: DateTimeFixed) -> Int64 {
    return FfiConverterTypeDateTimeFixed.lower(value)
}



/**
 * Typealias from the type name used in the UDL file to the builtin type.  This
 * is needed because the UDL type name is used in function/method signatures.
 */
public typealias Emoji = String

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeEmoji: FfiConverter {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Emoji {
        return try FfiConverterString.read(from: &buf)
    }

    public static func write(_ value: Emoji, into buf: inout [UInt8]) {
        return FfiConverterString.write(value, into: &buf)
    }

    public static func lift(_ value: RustBuffer) throws -> Emoji {
        return try FfiConverterString.lift(value)
    }

    public static func lower(_ value: Emoji) -> RustBuffer {
        return FfiConverterString.lower(value)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeEmoji_lift(_ value: RustBuffer) throws -> Emoji {
    return try FfiConverterTypeEmoji.lift(value)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeEmoji_lower(_ value: Emoji) -> RustBuffer {
    return FfiConverterTypeEmoji.lower(value)
}



/**
 * Typealias from the type name used in the UDL file to the builtin type.  This
 * is needed because the UDL type name is used in function/method signatures.
 */
public typealias MessageId = String

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeMessageId: FfiConverter {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> MessageId {
        return try FfiConverterString.read(from: &buf)
    }

    public static func write(_ value: MessageId, into buf: inout [UInt8]) {
        return FfiConverterString.write(value, into: &buf)
    }

    public static func lift(_ value: RustBuffer) throws -> MessageId {
        return try FfiConverterString.lift(value)
    }

    public static func lower(_ value: MessageId) -> RustBuffer {
        return FfiConverterString.lower(value)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeMessageId_lift(_ value: RustBuffer) throws -> MessageId {
    return try FfiConverterTypeMessageId.lift(value)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeMessageId_lower(_ value: MessageId) -> RustBuffer {
    return FfiConverterTypeMessageId.lower(value)
}



/**
 * Typealias from the type name used in the UDL file to the builtin type.  This
 * is needed because the UDL type name is used in function/method signatures.
 */
public typealias Mime = String

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeMime: FfiConverter {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Mime {
        return try FfiConverterString.read(from: &buf)
    }

    public static func write(_ value: Mime, into buf: inout [UInt8]) {
        return FfiConverterString.write(value, into: &buf)
    }

    public static func lift(_ value: RustBuffer) throws -> Mime {
        return try FfiConverterString.lift(value)
    }

    public static func lower(_ value: Mime) -> RustBuffer {
        return FfiConverterString.lower(value)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeMime_lift(_ value: RustBuffer) throws -> Mime {
    return try FfiConverterTypeMime.lift(value)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeMime_lower(_ value: Mime) -> RustBuffer {
    return FfiConverterTypeMime.lower(value)
}



/**
 * Typealias from the type name used in the UDL file to the builtin type.  This
 * is needed because the UDL type name is used in function/method signatures.
 */
public typealias MucId = BareJid

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeMucId: FfiConverter {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> MucId {
        return try FfiConverterTypeBareJid.read(from: &buf)
    }

    public static func write(_ value: MucId, into buf: inout [UInt8]) {
        return FfiConverterTypeBareJid.write(value, into: &buf)
    }

    public static func lift(_ value: RustBuffer) throws -> MucId {
        return try FfiConverterTypeBareJid_lift(value)
    }

    public static func lower(_ value: MucId) -> RustBuffer {
        return FfiConverterTypeBareJid_lower(value)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeMucId_lift(_ value: RustBuffer) throws -> MucId {
    return try FfiConverterTypeMucId.lift(value)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeMucId_lower(_ value: MucId) -> RustBuffer {
    return FfiConverterTypeMucId.lower(value)
}



/**
 * Typealias from the type name used in the UDL file to the builtin type.  This
 * is needed because the UDL type name is used in function/method signatures.
 */
public typealias OccupantId = String

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeOccupantId: FfiConverter {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> OccupantId {
        return try FfiConverterString.read(from: &buf)
    }

    public static func write(_ value: OccupantId, into buf: inout [UInt8]) {
        return FfiConverterString.write(value, into: &buf)
    }

    public static func lift(_ value: RustBuffer) throws -> OccupantId {
        return try FfiConverterString.lift(value)
    }

    public static func lower(_ value: OccupantId) -> RustBuffer {
        return FfiConverterString.lower(value)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeOccupantId_lift(_ value: RustBuffer) throws -> OccupantId {
    return try FfiConverterTypeOccupantId.lift(value)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeOccupantId_lower(_ value: OccupantId) -> RustBuffer {
    return FfiConverterTypeOccupantId.lower(value)
}





/**
 * Typealias from the type name used in the UDL file to the custom type.  This
 * is needed because the UDL type name is used in function/method signatures.
 */
public typealias PathBuf = URL


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypePathBuf: FfiConverter {

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> PathBuf {
        let builtinValue = try FfiConverterString.read(from: &buf)
        return URL(fileURLWithPath: builtinValue)
    }

    public static func write(_ value: PathBuf, into buf: inout [UInt8]) {
        let builtinValue = value.path
        return FfiConverterString.write(builtinValue, into: &buf)
    }

    public static func lift(_ value: RustBuffer) throws -> PathBuf {
        let builtinValue = try FfiConverterString.lift(value)
        return URL(fileURLWithPath: builtinValue)
    }

    public static func lower(_ value: PathBuf) -> RustBuffer {
        let builtinValue = value.path
        return FfiConverterString.lower(builtinValue)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypePathBuf_lift(_ value: RustBuffer) throws -> PathBuf {
    return try FfiConverterTypePathBuf.lift(value)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypePathBuf_lower(_ value: PathBuf) -> RustBuffer {
    return FfiConverterTypePathBuf.lower(value)
}



/**
 * Typealias from the type name used in the UDL file to the builtin type.  This
 * is needed because the UDL type name is used in function/method signatures.
 */
public typealias PresenceSubRequestId = UserId

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypePresenceSubRequestId: FfiConverter {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> PresenceSubRequestId {
        return try FfiConverterTypeUserId.read(from: &buf)
    }

    public static func write(_ value: PresenceSubRequestId, into buf: inout [UInt8]) {
        return FfiConverterTypeUserId.write(value, into: &buf)
    }

    public static func lift(_ value: RustBuffer) throws -> PresenceSubRequestId {
        return try FfiConverterTypeUserId_lift(value)
    }

    public static func lower(_ value: PresenceSubRequestId) -> RustBuffer {
        return FfiConverterTypeUserId_lower(value)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypePresenceSubRequestId_lift(_ value: RustBuffer) throws -> PresenceSubRequestId {
    return try FfiConverterTypePresenceSubRequestId.lift(value)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypePresenceSubRequestId_lower(_ value: PresenceSubRequestId) -> RustBuffer {
    return FfiConverterTypePresenceSubRequestId.lower(value)
}



/**
 * Typealias from the type name used in the UDL file to the builtin type.  This
 * is needed because the UDL type name is used in function/method signatures.
 */
public typealias ServerId = BareJid

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeServerId: FfiConverter {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ServerId {
        return try FfiConverterTypeBareJid.read(from: &buf)
    }

    public static func write(_ value: ServerId, into buf: inout [UInt8]) {
        return FfiConverterTypeBareJid.write(value, into: &buf)
    }

    public static func lift(_ value: RustBuffer) throws -> ServerId {
        return try FfiConverterTypeBareJid_lift(value)
    }

    public static func lower(_ value: ServerId) -> RustBuffer {
        return FfiConverterTypeBareJid_lower(value)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeServerId_lift(_ value: RustBuffer) throws -> ServerId {
    return try FfiConverterTypeServerId.lift(value)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeServerId_lower(_ value: ServerId) -> RustBuffer {
    return FfiConverterTypeServerId.lower(value)
}



/**
 * Typealias from the type name used in the UDL file to the builtin type.  This
 * is needed because the UDL type name is used in function/method signatures.
 */
public typealias UnicodeScalarIndex = UInt64

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeUnicodeScalarIndex: FfiConverter {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> UnicodeScalarIndex {
        return try FfiConverterUInt64.read(from: &buf)
    }

    public static func write(_ value: UnicodeScalarIndex, into buf: inout [UInt8]) {
        return FfiConverterUInt64.write(value, into: &buf)
    }

    public static func lift(_ value: UInt64) throws -> UnicodeScalarIndex {
        return try FfiConverterUInt64.lift(value)
    }

    public static func lower(_ value: UnicodeScalarIndex) -> UInt64 {
        return FfiConverterUInt64.lower(value)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeUnicodeScalarIndex_lift(_ value: UInt64) throws -> UnicodeScalarIndex {
    return try FfiConverterTypeUnicodeScalarIndex.lift(value)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeUnicodeScalarIndex_lower(_ value: UnicodeScalarIndex) -> UInt64 {
    return FfiConverterTypeUnicodeScalarIndex.lower(value)
}





/**
 * Typealias from the type name used in the UDL file to the custom type.  This
 * is needed because the UDL type name is used in function/method signatures.
 */
public typealias Url = URL


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeUrl: FfiConverter {

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Url {
        let builtinValue = try FfiConverterString.read(from: &buf)
        return URL(string: builtinValue)!
    }

    public static func write(_ value: Url, into buf: inout [UInt8]) {
        let builtinValue = value.absoluteString
        return FfiConverterString.write(builtinValue, into: &buf)
    }

    public static func lift(_ value: RustBuffer) throws -> Url {
        let builtinValue = try FfiConverterString.lift(value)
        return URL(string: builtinValue)!
    }

    public static func lower(_ value: Url) -> RustBuffer {
        let builtinValue = value.absoluteString
        return FfiConverterString.lower(builtinValue)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeUrl_lift(_ value: RustBuffer) throws -> Url {
    return try FfiConverterTypeUrl.lift(value)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeUrl_lower(_ value: Url) -> RustBuffer {
    return FfiConverterTypeUrl.lower(value)
}



/**
 * Typealias from the type name used in the UDL file to the builtin type.  This
 * is needed because the UDL type name is used in function/method signatures.
 */
public typealias UserId = BareJid

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeUserId: FfiConverter {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> UserId {
        return try FfiConverterTypeBareJid.read(from: &buf)
    }

    public static func write(_ value: UserId, into buf: inout [UInt8]) {
        return FfiConverterTypeBareJid.write(value, into: &buf)
    }

    public static func lift(_ value: RustBuffer) throws -> UserId {
        return try FfiConverterTypeBareJid_lift(value)
    }

    public static func lower(_ value: UserId) -> RustBuffer {
        return FfiConverterTypeBareJid_lower(value)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeUserId_lift(_ value: RustBuffer) throws -> UserId {
    return try FfiConverterTypeUserId.lift(value)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeUserId_lower(_ value: UserId) -> RustBuffer {
    return FfiConverterTypeUserId.lower(value)
}

private let UNIFFI_RUST_FUTURE_POLL_READY: Int8 = 0
private let UNIFFI_RUST_FUTURE_POLL_MAYBE_READY: Int8 = 1

fileprivate let uniffiContinuationHandleMap = UniffiHandleMap<UnsafeContinuation<Int8, Never>>()

fileprivate func uniffiRustCallAsync<F, T>(
    rustFutureFunc: () -> UInt64,
    pollFunc: (UInt64, @escaping UniffiRustFutureContinuationCallback, UInt64) -> (),
    completeFunc: (UInt64, UnsafeMutablePointer<RustCallStatus>) -> F,
    freeFunc: (UInt64) -> (),
    liftFunc: (F) throws -> T,
    errorHandler: ((RustBuffer) throws -> Swift.Error)?
) async throws -> T {
    // Make sure to call the ensure init function since future creation doesn't have a
    // RustCallStatus param, so doesn't use makeRustCall()
    uniffiEnsureProseSdkFfiInitialized()
    let rustFuture = rustFutureFunc()
    defer {
        freeFunc(rustFuture)
    }
    var pollResult: Int8;
    repeat {
        pollResult = await withUnsafeContinuation {
            pollFunc(
                rustFuture,
                uniffiFutureContinuationCallback,
                uniffiContinuationHandleMap.insert(obj: $0)
            )
        }
    } while pollResult != UNIFFI_RUST_FUTURE_POLL_READY

    return try liftFunc(makeRustCall(
        { completeFunc(rustFuture, $0) },
        errorHandler: errorHandler
    ))
}

// Callback handlers for an async calls.  These are invoked by Rust when the future is ready.  They
// lift the return value or error and resume the suspended function.
fileprivate func uniffiFutureContinuationCallback(handle: UInt64, pollResult: Int8) {
    if let continuation = try? uniffiContinuationHandleMap.remove(handle: handle) {
        continuation.resume(returning: pollResult)
    } else {
        print("uniffiFutureContinuationCallback invalid handle")
    }
}

private enum InitializationResult {
    case ok
    case contractVersionMismatch
    case apiChecksumMismatch
}
// Use a global variable to perform the versioning checks. Swift ensures that
// the code inside is only computed once.
private let initializationResult: InitializationResult = {
    // Get the bindings contract version from our ComponentInterface
    let bindings_contract_version = 29
    // Get the scaffolding contract version by calling the into the dylib
    let scaffolding_contract_version = ffi_prose_sdk_ffi_uniffi_contract_version()
    if bindings_contract_version != scaffolding_contract_version {
        return InitializationResult.contractVersionMismatch
    }
    if (uniffi_prose_sdk_ffi_checksum_method_accountbookmarksclient_add_bookmark() != 16579) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_prose_sdk_ffi_checksum_method_accountbookmarksclient_load_bookmarks() != 45185) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_prose_sdk_ffi_checksum_method_accountbookmarksclient_remove_bookmark() != 20768) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_prose_sdk_ffi_checksum_method_accountbookmarksclient_save_bookmarks() != 29810) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_prose_sdk_ffi_checksum_method_accountbookmarksclient_select_bookmark() != 21127) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_prose_sdk_ffi_checksum_method_avatar_id() != 51772) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_prose_sdk_ffi_checksum_method_channel_invite_users() != 31788) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_prose_sdk_ffi_checksum_method_client_add_contact() != 15569) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_prose_sdk_ffi_checksum_method_client_approve_presence_sub_request() != 13663) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_prose_sdk_ffi_checksum_method_client_block_user() != 50203) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_prose_sdk_ffi_checksum_method_client_change_password() != 62361) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_prose_sdk_ffi_checksum_method_client_clear_block_list() != 46475) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_prose_sdk_ffi_checksum_method_client_connect() != 7683) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_prose_sdk_ffi_checksum_method_client_create_group() != 26185) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_prose_sdk_ffi_checksum_method_client_create_private_channel() != 6938) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_prose_sdk_ffi_checksum_method_client_create_public_channel() != 37184) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_prose_sdk_ffi_checksum_method_client_delete_cached_data() != 5481) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_prose_sdk_ffi_checksum_method_client_deny_presence_sub_request() != 2203) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_prose_sdk_ffi_checksum_method_client_destroy_room() != 28316) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_prose_sdk_ffi_checksum_method_client_disconnect() != 21087) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_prose_sdk_ffi_checksum_method_client_enable_logging() != 39036) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_prose_sdk_ffi_checksum_method_client_find_public_channel_by_name() != 29293) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_prose_sdk_ffi_checksum_method_client_join_room() != 63549) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_prose_sdk_ffi_checksum_method_client_load_account_info() != 29622) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_prose_sdk_ffi_checksum_method_client_load_avatar() != 20790) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_prose_sdk_ffi_checksum_method_client_load_block_list() != 17594) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_prose_sdk_ffi_checksum_method_client_load_contacts() != 21398) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_prose_sdk_ffi_checksum_method_client_load_presence_sub_requests() != 54504) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_prose_sdk_ffi_checksum_method_client_load_profile() != 32088) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_prose_sdk_ffi_checksum_method_client_load_public_channels() != 36765) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_prose_sdk_ffi_checksum_method_client_load_user_metadata() != 6516) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_prose_sdk_ffi_checksum_method_client_load_workspace_icon() != 21578) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_prose_sdk_ffi_checksum_method_client_load_workspace_info() != 22705) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_prose_sdk_ffi_checksum_method_client_preview_markdown() != 64100) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_prose_sdk_ffi_checksum_method_client_remove_contact() != 18687) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_prose_sdk_ffi_checksum_method_client_request_presence_sub() != 29804) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_prose_sdk_ffi_checksum_method_client_request_upload_slot() != 5044) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_prose_sdk_ffi_checksum_method_client_save_avatar() != 38904) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_prose_sdk_ffi_checksum_method_client_save_profile() != 57919) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_prose_sdk_ffi_checksum_method_client_set_availability() != 20379) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_prose_sdk_ffi_checksum_method_client_set_user_activity() != 26520) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_prose_sdk_ffi_checksum_method_client_sidebar_items() != 55249) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_prose_sdk_ffi_checksum_method_client_start_conversation() != 3148) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_prose_sdk_ffi_checksum_method_client_start_observing_rooms() != 21767) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_prose_sdk_ffi_checksum_method_client_unblock_user() != 28062) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_prose_sdk_ffi_checksum_method_clientdelegate_handle_event() != 21258) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_prose_sdk_ffi_checksum_method_hasmutablename_set_name() != 63119) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_prose_sdk_ffi_checksum_method_mucroom_subject() != 2121) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_prose_sdk_ffi_checksum_method_mucroom_set_topic() != 42576) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_prose_sdk_ffi_checksum_method_roombase_state() != 65331) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_prose_sdk_ffi_checksum_method_roombase_id() != 35933) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_prose_sdk_ffi_checksum_method_roombase_name() != 1114) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_prose_sdk_ffi_checksum_method_roombase_participants() != 37342) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_prose_sdk_ffi_checksum_method_roombase_send_message() != 59372) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_prose_sdk_ffi_checksum_method_roombase_update_message() != 24765) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_prose_sdk_ffi_checksum_method_roombase_retract_message() != 54010) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_prose_sdk_ffi_checksum_method_roombase_toggle_reaction_to_message() != 62115) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_prose_sdk_ffi_checksum_method_roombase_load_latest_messages() != 36432) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_prose_sdk_ffi_checksum_method_roombase_load_messages_before() != 1194) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_prose_sdk_ffi_checksum_method_roombase_load_messages_with_ids() != 43873) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_prose_sdk_ffi_checksum_method_roombase_load_unread_messages() != 49150) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_prose_sdk_ffi_checksum_method_roombase_set_user_is_composing() != 38309) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_prose_sdk_ffi_checksum_method_roombase_load_composing_users() != 62161) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_prose_sdk_ffi_checksum_method_roombase_save_draft() != 54481) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_prose_sdk_ffi_checksum_method_roombase_load_draft() != 21980) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_prose_sdk_ffi_checksum_method_roombase_mark_as_read() != 17512) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_prose_sdk_ffi_checksum_method_roombase_set_last_read_message() != 46359) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_prose_sdk_ffi_checksum_method_roomdirectmessage_id() != 41656) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_prose_sdk_ffi_checksum_method_roomdirectmessage_is_encryption_enabled() != 41237) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_prose_sdk_ffi_checksum_method_roomdirectmessage_load_composing_users() != 45924) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_prose_sdk_ffi_checksum_method_roomdirectmessage_load_draft() != 60271) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_prose_sdk_ffi_checksum_method_roomdirectmessage_load_latest_messages() != 53258) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_prose_sdk_ffi_checksum_method_roomdirectmessage_load_messages_before() != 12497) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_prose_sdk_ffi_checksum_method_roomdirectmessage_load_messages_with_ids() != 42358) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_prose_sdk_ffi_checksum_method_roomdirectmessage_load_unread_messages() != 48263) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_prose_sdk_ffi_checksum_method_roomdirectmessage_mark_as_read() != 25957) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_prose_sdk_ffi_checksum_method_roomdirectmessage_name() != 17856) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_prose_sdk_ffi_checksum_method_roomdirectmessage_participants() != 14937) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_prose_sdk_ffi_checksum_method_roomdirectmessage_retract_message() != 14490) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_prose_sdk_ffi_checksum_method_roomdirectmessage_save_draft() != 54516) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_prose_sdk_ffi_checksum_method_roomdirectmessage_send_message() != 61073) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_prose_sdk_ffi_checksum_method_roomdirectmessage_set_is_encryption_enabled() != 55422) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_prose_sdk_ffi_checksum_method_roomdirectmessage_set_last_read_message() != 48067) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_prose_sdk_ffi_checksum_method_roomdirectmessage_set_user_is_composing() != 56826) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_prose_sdk_ffi_checksum_method_roomdirectmessage_state() != 23897) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_prose_sdk_ffi_checksum_method_roomdirectmessage_toggle_reaction_to_message() != 60415) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_prose_sdk_ffi_checksum_method_roomdirectmessage_update_message() != 27957) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_prose_sdk_ffi_checksum_method_roomgeneric_id() != 28892) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_prose_sdk_ffi_checksum_method_roomgeneric_load_composing_users() != 9029) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_prose_sdk_ffi_checksum_method_roomgeneric_load_draft() != 39885) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_prose_sdk_ffi_checksum_method_roomgeneric_load_latest_messages() != 16624) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_prose_sdk_ffi_checksum_method_roomgeneric_load_messages_before() != 63308) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_prose_sdk_ffi_checksum_method_roomgeneric_load_messages_with_ids() != 23108) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_prose_sdk_ffi_checksum_method_roomgeneric_load_unread_messages() != 40053) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_prose_sdk_ffi_checksum_method_roomgeneric_mark_as_read() != 51850) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_prose_sdk_ffi_checksum_method_roomgeneric_name() != 52631) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_prose_sdk_ffi_checksum_method_roomgeneric_participants() != 53689) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_prose_sdk_ffi_checksum_method_roomgeneric_retract_message() != 63140) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_prose_sdk_ffi_checksum_method_roomgeneric_save_draft() != 42838) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_prose_sdk_ffi_checksum_method_roomgeneric_send_message() != 48651) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_prose_sdk_ffi_checksum_method_roomgeneric_set_last_read_message() != 27453) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_prose_sdk_ffi_checksum_method_roomgeneric_set_name() != 32639) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_prose_sdk_ffi_checksum_method_roomgeneric_set_topic() != 9550) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_prose_sdk_ffi_checksum_method_roomgeneric_set_user_is_composing() != 5959) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_prose_sdk_ffi_checksum_method_roomgeneric_state() != 50874) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_prose_sdk_ffi_checksum_method_roomgeneric_subject() != 37575) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_prose_sdk_ffi_checksum_method_roomgeneric_toggle_reaction_to_message() != 46556) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_prose_sdk_ffi_checksum_method_roomgeneric_update_message() != 17707) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_prose_sdk_ffi_checksum_method_roomgroup_id() != 43551) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_prose_sdk_ffi_checksum_method_roomgroup_load_composing_users() != 15241) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_prose_sdk_ffi_checksum_method_roomgroup_load_draft() != 239) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_prose_sdk_ffi_checksum_method_roomgroup_load_latest_messages() != 24607) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_prose_sdk_ffi_checksum_method_roomgroup_load_messages_before() != 32647) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_prose_sdk_ffi_checksum_method_roomgroup_load_messages_with_ids() != 65109) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_prose_sdk_ffi_checksum_method_roomgroup_load_unread_messages() != 40741) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_prose_sdk_ffi_checksum_method_roomgroup_mark_as_read() != 16906) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_prose_sdk_ffi_checksum_method_roomgroup_name() != 39120) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_prose_sdk_ffi_checksum_method_roomgroup_participants() != 13992) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_prose_sdk_ffi_checksum_method_roomgroup_resend_invites_to_members() != 50465) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_prose_sdk_ffi_checksum_method_roomgroup_retract_message() != 50460) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_prose_sdk_ffi_checksum_method_roomgroup_save_draft() != 45005) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_prose_sdk_ffi_checksum_method_roomgroup_send_message() != 26791) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_prose_sdk_ffi_checksum_method_roomgroup_set_last_read_message() != 21938) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_prose_sdk_ffi_checksum_method_roomgroup_set_topic() != 58040) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_prose_sdk_ffi_checksum_method_roomgroup_set_user_is_composing() != 17750) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_prose_sdk_ffi_checksum_method_roomgroup_state() != 58138) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_prose_sdk_ffi_checksum_method_roomgroup_subject() != 11269) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_prose_sdk_ffi_checksum_method_roomgroup_toggle_reaction_to_message() != 58018) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_prose_sdk_ffi_checksum_method_roomgroup_update_message() != 56772) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_prose_sdk_ffi_checksum_method_roomprivatechannel_id() != 63426) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_prose_sdk_ffi_checksum_method_roomprivatechannel_invite_users() != 9481) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_prose_sdk_ffi_checksum_method_roomprivatechannel_load_composing_users() != 21927) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_prose_sdk_ffi_checksum_method_roomprivatechannel_load_draft() != 9707) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_prose_sdk_ffi_checksum_method_roomprivatechannel_load_latest_messages() != 11255) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_prose_sdk_ffi_checksum_method_roomprivatechannel_load_messages_before() != 26578) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_prose_sdk_ffi_checksum_method_roomprivatechannel_load_messages_with_ids() != 27475) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_prose_sdk_ffi_checksum_method_roomprivatechannel_load_unread_messages() != 9040) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_prose_sdk_ffi_checksum_method_roomprivatechannel_mark_as_read() != 64252) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_prose_sdk_ffi_checksum_method_roomprivatechannel_name() != 11095) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_prose_sdk_ffi_checksum_method_roomprivatechannel_participants() != 53272) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_prose_sdk_ffi_checksum_method_roomprivatechannel_retract_message() != 62345) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_prose_sdk_ffi_checksum_method_roomprivatechannel_save_draft() != 55764) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_prose_sdk_ffi_checksum_method_roomprivatechannel_send_message() != 52342) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_prose_sdk_ffi_checksum_method_roomprivatechannel_set_last_read_message() != 4788) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_prose_sdk_ffi_checksum_method_roomprivatechannel_set_name() != 18376) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_prose_sdk_ffi_checksum_method_roomprivatechannel_set_topic() != 48563) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_prose_sdk_ffi_checksum_method_roomprivatechannel_set_user_is_composing() != 42803) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_prose_sdk_ffi_checksum_method_roomprivatechannel_state() != 27121) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_prose_sdk_ffi_checksum_method_roomprivatechannel_subject() != 51015) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_prose_sdk_ffi_checksum_method_roomprivatechannel_toggle_reaction_to_message() != 32643) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_prose_sdk_ffi_checksum_method_roomprivatechannel_update_message() != 41482) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_prose_sdk_ffi_checksum_method_roompublicchannel_id() != 39434) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_prose_sdk_ffi_checksum_method_roompublicchannel_invite_users() != 10126) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_prose_sdk_ffi_checksum_method_roompublicchannel_load_composing_users() != 61910) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_prose_sdk_ffi_checksum_method_roompublicchannel_load_draft() != 37212) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_prose_sdk_ffi_checksum_method_roompublicchannel_load_latest_messages() != 14194) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_prose_sdk_ffi_checksum_method_roompublicchannel_load_messages_before() != 24082) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_prose_sdk_ffi_checksum_method_roompublicchannel_load_messages_with_ids() != 14233) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_prose_sdk_ffi_checksum_method_roompublicchannel_load_unread_messages() != 45432) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_prose_sdk_ffi_checksum_method_roompublicchannel_mark_as_read() != 55334) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_prose_sdk_ffi_checksum_method_roompublicchannel_name() != 45144) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_prose_sdk_ffi_checksum_method_roompublicchannel_participants() != 8284) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_prose_sdk_ffi_checksum_method_roompublicchannel_retract_message() != 15968) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_prose_sdk_ffi_checksum_method_roompublicchannel_save_draft() != 45134) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_prose_sdk_ffi_checksum_method_roompublicchannel_send_message() != 64436) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_prose_sdk_ffi_checksum_method_roompublicchannel_set_last_read_message() != 54783) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_prose_sdk_ffi_checksum_method_roompublicchannel_set_name() != 63354) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_prose_sdk_ffi_checksum_method_roompublicchannel_set_topic() != 5103) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_prose_sdk_ffi_checksum_method_roompublicchannel_set_user_is_composing() != 50060) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_prose_sdk_ffi_checksum_method_roompublicchannel_state() != 33467) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_prose_sdk_ffi_checksum_method_roompublicchannel_subject() != 64102) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_prose_sdk_ffi_checksum_method_roompublicchannel_toggle_reaction_to_message() != 56202) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_prose_sdk_ffi_checksum_method_roompublicchannel_update_message() != 11951) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_prose_sdk_ffi_checksum_constructor_accountbookmarksclient_new() != 36619) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_prose_sdk_ffi_checksum_constructor_client_new() != 29064) {
        return InitializationResult.apiChecksumMismatch
    }

    uniffiCallbackInitClientDelegate()
    return InitializationResult.ok
}()

// Make the ensure init function public so that other modules which have external type references to
// our types can call it.
public func uniffiEnsureProseSdkFfiInitialized() {
    switch initializationResult {
    case .ok:
        break
    case .contractVersionMismatch:
        fatalError("UniFFI contract version mismatch: try cleaning and rebuilding your project")
    case .apiChecksumMismatch:
        fatalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
}

// swiftlint:enable all